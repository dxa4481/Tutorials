require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":2}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":4}],5:[function(require,module,exports){
var events = require('events');
var util = require('util');

function Stream() {
  events.EventEmitter.call(this);
}
util.inherits(Stream, events.EventEmitter);
module.exports = Stream;
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once, and
  // only when all sources have ended.
  if (!dest._isStdio && (!options || options.end !== false)) {
    dest._pipeCount = dest._pipeCount || 0;
    dest._pipeCount++;

    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (this.listeners('error').length === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('end', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('end', cleanup);
  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":4,"util":3}],2:[function(require,module,exports){

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {};
  var t = {};
  for (var i in parent[key]) t[i] = parent[key][i];
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };
  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });
  return ret.base;
}

/**
 * Parse the given str.
 */

function parseString(str){
  return reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],6:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}
},{"http":7}],8:[function(require,module,exports){
// todo

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":9}],7:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');

http.request = function (params, cb) {
    if (!params) params = {};
    if (!params.host) params.host = window.location.host.split(':')[0];
    if (!params.port) params.port = window.location.port;
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"events":4,"./lib/request":10}],11:[function(require,module,exports){
(function(){var Buffer = require('buffer').Buffer
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)));
    } catch (err) { callback(err); }
  } else {
    return new Buffer(rng(size));
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

})()
},{"buffer":12,"./sha":13,"./rng":14,"./md5":15}],16:[function(require,module,exports){
try {
    var StringPrep = require('node-stringprep').StringPrep;
    var toUnicode = require('node-stringprep').toUnicode;
    var c = function(n) {
	var p = new StringPrep(n);
	return function(s) {
	    return p.prepare(s);
	};
    };
    var nameprep = c('nameprep');
    var nodeprep = c('nodeprep');
    var resourceprep = c('resourceprep');
} catch(ex) {
    console.warn("Cannot load StringPrep-0.1.0 bindings. You may need to `npm install node-stringprep'");
    var identity = function(a) { return a; };
    var toLower = function(a) { return a.toLowerCase(); };
    var toUnicode = identity;
    var nameprep = toLower;
    var nodeprep = toLower;
    var resourceprep = identity;
}

function JID(a, b, c) {
    if (a && b == null && c == null) {
        this.parseJID(a);
    } else if (b) {
        this.setUser(a);
        this.setDomain(b);
        this.setResource(c);
    } else
        throw new Error('Argument error');
}

JID.prototype.parseJID = function(s) {
    if (s.indexOf('@') >= 0) {
        this.setUser(s.substr(0, s.indexOf('@')));
        s = s.substr(s.indexOf('@') + 1);
    }
    if (s.indexOf('/') >= 0) {
        this.setResource(s.substr(s.indexOf('/') + 1));
        s = s.substr(0, s.indexOf('/'));
    }
    this.setDomain(s);
};

JID.prototype.toString = function() {
    var s = this.domain;
    if (this.user)
        s = this.user + '@' + s;
    if (this.resource)
        s = s + '/' + this.resource;
    return s;
};

/**
 * Convenience method to distinguish users
 **/
JID.prototype.bare = function() {
    if (this.resource)
        return new JID(this.user, this.domain, null);
    else
        return this;
};

/**
 * Comparison function
 **/
JID.prototype.equals = function(other) {
    return this.user == other.user &&
        this.domain == other.domain &&
        this.resource == other.resource;
};

/**
 * Setters that do stringprep normalization.
 **/
JID.prototype.setUser = function(user) {
    this.user = user && nodeprep(user);
};
/**
 * http://xmpp.org/rfcs/rfc6122.html#addressing-domain
 */
JID.prototype.setDomain = function(domain) {
    this.domain = domain &&
        nameprep(domain.split(".").
                 map(toUnicode).
                 join("."));
};
JID.prototype.setResource = function(resource) {
    this.resource = resource && resourceprep(resource);
};

if (typeof exports !== "undefined" && exports !== null) {
  exports.JID = JID;
} else if (typeof window !== "undefined" && window !== null) {
  window.JID = JID;
}

},{"node-stringprep":17}],18:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":12}],"browser-request":[function(require,module,exports){
module.exports=require('RLCzBz');
},{}],19:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],"RLCzBz":[function(require,module,exports){
(function(process,Buffer){// Copyright 2010-2012 Mikeal Rogers
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var http = require('http')
  , https = false
  , tls = false
  , url = require('url')
  , util = require('util')
  , stream = require('stream')
  , qs = require('qs')
  , querystring = require('querystring')
  , crypto = require('crypto')

  , oauth = require('oauth-sign')
  , hawk = require('hawk')
  , aws = require('aws-sign')
  , httpSignature = require('http-signature')
  , uuid = require('node-uuid')
  , mime = require('mime')
  , tunnel = require('tunnel-agent')
  , safeStringify = require('json-stringify-safe')

  , ForeverAgent = require('forever-agent')
  , FormData = require('form-data')

  , Cookie = require('cookie-jar')
  , CookieJar = Cookie.Jar
  , cookieJar = new CookieJar
  ;

try {
  https = require('https')
} catch (e) {}

try {
  tls = require('tls')
} catch (e) {}

var debug
if (/\brequest\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    console.error('REQUEST %s', util.format.apply(util, arguments))
  }
} else {
  debug = function() {}
}

function toBase64 (str) {
  return (new Buffer(str || "", "ascii")).toString("base64")
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

// Hacky fix for pre-0.4.4 https
if (https && !https.Agent) {
  https.Agent = function (options) {
    http.Agent.call(this, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = function (host, port, cb) {
    var s = tls.connect(port, host, this.options, function () {
      // do other checks here?
      if (cb) cb()
    })
    return s
  }
}

function isReadStream (rs) {
  if (rs.readable && rs.path && rs.mode) {
    return true
  }
}

function copy (obj) {
  var o = {}
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i]
  })
  return o
}

var isUrl = /^https?:/

var globalPool = {}

function Request (options) {
  stream.Stream.call(this)
  this.readable = true
  this.writable = true

  if (typeof options === 'string') {
    options = {uri:options}
  }

  var reserved = Object.keys(Request.prototype)
  for (var i in options) {
    if (reserved.indexOf(i) === -1) {
      this[i] = options[i]
    } else {
      if (typeof options[i] === 'function') {
        delete options[i]
      }
    }
  }

  if (options.method) {
    this.explicitMethod = true
  }

  this.init(options)
}
util.inherits(Request, stream.Stream)
Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) options = {}

  if (!self.method) self.method = options.method || 'GET'
  self.localAddress = options.localAddress

  debug(options)
  if (!self.pool && self.pool !== false) self.pool = globalPool
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) return // Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  if (self.url && !self.uri) {
    // People use this property instead all the time so why not just support it.
    self.uri = self.url
    delete self.url
  }

  if (!self.uri) {
    // this will throw if unhandled but is handleable when in a redirect
    return self.emit('error', new Error("options.uri is a required argument"))
  } else {
    if (typeof self.uri == "string") self.uri = url.parse(self.uri)
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (self.proxy) {
    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)

    // do the HTTP CONNECT dance using koichik/node-tunnel
    if (http.globalAgent && self.uri.protocol === "https:") {
      var tunnelFn = self.proxy.protocol === "http:"
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth
                                   , headers: { Host: self.uri.hostname + ':' +
                                        (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80) }}
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: this.ca }

      self.agent = tunnelFn(tunnelOptions)
      self.tunnel = true
    }
  }

  if (!self.uri.host || !self.uri.pathname) {
    // Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (he didn't call request directly with this URL)
      // he should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.'
    }
    self.emit('error', new Error(message))
    return // This error was fatal
  }

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10
  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false
  if (self.followRedirect || self.followAllRedirects)
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers) : {}

  self.setHost = false
  if (!(self.headers.host || self.headers.Host)) {
    self.headers.host = self.uri.hostname
    if (self.uri.port) {
      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
           !(self.uri.port === 443 && self.uri.protocol === 'https:') )
      self.headers.host += (':'+self.uri.port)
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.pathname) {self.uri.pathname = '/'}
  if (!self.uri.port) {
    if (self.uri.protocol == 'http:') {self.uri.port = 80}
    else if (self.uri.protocol == 'https:') {self.uri.port = 443}
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  self.clientErrorHandler = function (error) {
    if (self._aborted) return

    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
        && self.agent.addRequestNoreuse) {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
      self.start()
      self.req.end()
      return
    }
    if (self.timeout && self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = null
    }
    self.emit('error', error)
  }

  self._parserErrorHandler = function (error) {
    if (this.res) {
      if (this.res.request) {
        this.res.request.emit('error', error)
      } else {
        this.res.emit('error', error)
      }
    } else {
      this._httpMessage.emit('error', error)
    }
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.qs) self.qs(options.qs)

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || "")
  }

  if (self.path.length === 0) self.path = '/'


  // Auth must happen last in case signing is dependent on other headers
  if (options.oauth) {
    self.oauth(options.oauth)
  }

  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    self.auth(
      (options.auth.user==="") ? options.auth.user : (options.auth.user || options.auth.username ),
      options.auth.pass || options.auth.password,
      options.auth.sendImmediately)
  }

  if (self.uri.auth && !self.headers.authorization) {
    var authPieces = self.uri.auth.split(':').map(function(item){ return querystring.unescape(item) })
    self.auth(authPieces[0], authPieces.slice(1).join(':'), true)
  }
  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization'] && !self.tunnel) {
    self.headers['proxy-authorization'] = "Basic " + toBase64(self.proxy.auth.split(':').map(function(item){ return querystring.unescape(item)}).join(':'))
  }


  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)

  if (options.json) {
    self.json(options.json)
  } else if (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  if (self.body) {
    var length = 0
    if (!Buffer.isBuffer(self.body)) {
      if (Array.isArray(self.body)) {
        for (var i = 0; i < self.body.length; i++) {
          length += self.body[i].length
        }
      } else {
        self.body = new Buffer(self.body)
        length = self.body.length
      }
    } else {
      length = self.body.length
    }
    if (length) {
      if(!self.headers['content-length'] && !self.headers['Content-Length'])
      self.headers['content-length'] = length
    } else {
      throw new Error('Argument error, options.body.')
    }
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {'http:':http, 'https:':https}
    , httpModules = self.httpModules || {}
    ;
  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) return this.emit('error', new Error("Invalid protocol"))

  if (options.ca) self.ca = options.ca

  if (!self.agent) {
    if (options.agentOptions) self.agentOptions = options.agentOptions

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getAgent()
    if (self.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.maxSockets
    }
    if (self.pool.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.pool.maxSockets
    }
  }

  self.on('pipe', function (src) {
    if (self.ntick && self._started) throw new Error("You cannot pipe to this stream after the outbound request has started.")
    self.src = src
    if (isReadStream(src)) {
      if (!self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = mime.lookup(src.path)
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.headers[i]) {
            self.headers[i] = src.headers[i]
          }
        }
      }
      if (self._json && !self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = 'application/json'
      if (src.method && !self.explicitMethod) {
        self.method = src.method
      }
    }

    // self.on('pipe', function () {
    //   console.error("You have already piped to this stream. Pipeing twice is likely to break the request.")
    // })
  })

  process.nextTick(function () {
    if (self._aborted) return

    if (self._form) {
      self.setHeaders(self._form.getHeaders())
      self._form.pipe(self)
    }
    if (self.body) {
      if (Array.isArray(self.body)) {
        self.body.forEach(function (part) {
          self.write(part)
        })
      } else {
        self.write(self.body)
      }
      self.end()
    } else if (self.requestBodyStream) {
      console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.")
      self.requestBodyStream.pipe(self)
    } else if (!self.src) {
      if (self.method !== 'GET' && typeof self.method !== 'undefined') {
        self.headers['content-length'] = 0
      }
      self.end()
    }
    self.ntick = true
  })
}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function () {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === 'https:') {
    // previously was doing http, now doing https
    // if it's https, then we might need to tunnel now.
    if (self.proxy) {
      self.tunnel = true
      var tunnelFn = self.proxy.protocol === 'http:'
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions)
      return
    }

    self.httpModule = https
    switch (self.agentClass) {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
    }

    // if there's an agent, we need to get a new one.
    if (self.agent) self.agent = self.getAgent()

  } else {
    // previously was doing https, now doing http
    // stop any tunneling.
    if (self.tunnel) self.tunnel = false
    self.httpModule = http
    switch (self.agentClass) {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
    }

    // if there's an agent, then get a new one.
    if (self.agent) {
      self.agent = null
      self.agent = self.getAgent()
    }
  }
}

Request.prototype.getAgent = function () {
  var Agent = this.agentClass
  var options = {}
  if (this.agentOptions) {
    for (var i in this.agentOptions) {
      options[i] = this.agentOptions[i]
    }
  }
  if (this.ca) options.ca = this.ca
  if (typeof this.rejectUnauthorized !== 'undefined') options.rejectUnauthorized = this.rejectUnauthorized

  if (this.cert && this.key) {
    options.key = this.key
    options.cert = this.cert
  }

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== this.httpModule.Agent) {
    poolKey += Agent.name
  }

  if (!this.httpModule.globalAgent) {
    // node 0.4.x
    options.host = this.host
    options.port = this.port
    if (poolKey) poolKey += ':'
    poolKey += this.host + ':' + this.port
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = this.proxy
  if (typeof proxy === 'string') proxy = url.parse(proxy)
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'
  if (isHttps) {
    if (options.ca) {
      if (poolKey) poolKey += ':'
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) poolKey += ':'
      poolKey += options.rejectUnauthorized
    }

    if (options.cert)
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')

    if (options.ciphers) {
      if (poolKey) poolKey += ':'
      poolKey += options.ciphers
    }

    if (options.secureOptions) {
      if (poolKey) poolKey += ':'
      poolKey += options.secureOptions
    }
  }

  if (!poolKey && Object.keys(options).length === 0 && this.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return this.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = this.uri.protocol + poolKey

  // already generated an agent for this setting
  if (this.pool[poolKey]) return this.pool[poolKey]

  return this.pool[poolKey] = new Agent(options)
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.headers['content-length'] && !self.headers['Content-Length']) {
    self.headers['content-length'] = self.src.stat.size
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)
  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self))

  if (self.timeout && !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(function () {
      self.req.abort()
      var e = new Error("ETIMEDOUT")
      e.code = "ETIMEDOUT"
      self.emit("error", e)
    }, self.timeout)

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout) { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error("ESOCKETTIMEDOUT")
          e.code = "ESOCKETTIMEDOUT"
          self.emit("error", e)
        }
      })
    }
  }

  self.req.on('error', self.clientErrorHandler)
  self.req.on('drain', function() {
    self.emit('drain')
  })
  self.on('end', function() {
    if ( self.req.connection ) self.req.connection.removeListener('error', self._parserErrorHandler)
  })
  self.emit('request', self.req)
}
Request.prototype.onResponse = function (response) {
  var self = this
  debug('onResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function() {
    debug('response end', self.uri.href, response.statusCode, response.headers)
  });

  if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {
    response.connection.once('error', self._parserErrorHandler)
  }
  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }
  if (self._paused) response.pause()
  else response.resume()

  self.response = response
  response.request = self
  response.toJSON = toJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
      self.strictSSL &&
      !response.client.authorized) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.client.authorizationError
    self.emit('error', new Error('SSL Error: '+ sslErr))
    return
  }

  if (self.setHost) delete self.headers.host
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var addCookie = function (cookie) {
    if (self._jar) self._jar.add(new Cookie(cookie))
    else cookieJar.add(new Cookie(cookie))
  }

  if (response.headers['set-cookie'] && (!self._disableCookies)) {
    if (Array.isArray(response.headers['set-cookie'])) response.headers['set-cookie'].forEach(addCookie)
    else addCookie(response.headers['set-cookie'])
  }

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
    debug('redirect', response.headers.location)

    if (self.followAllRedirects) {
      redirectTo = response.headers.location
    } else if (self.followRedirect) {
      switch (self.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = response.headers.location
          break
      }
    }
  } else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth) {
    var authHeader = response.headers['www-authenticate']
    var authVerb = authHeader && authHeader.split(' ')[0]
    debug('reauth', authVerb)

    switch (authVerb) {
      case 'Basic':
        self.auth(self._user, self._pass, true)
        redirectTo = self.uri
        break

      case 'Digest':
        // TODO: More complete implementation of RFC 2617.  For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var matches = authHeader.match(/([a-z0-9_-]+)="([^"]+)"/gi)
        var challenge = {}

        for (var i = 0; i < matches.length; i++) {
          var eqPos = matches[i].indexOf('=')
          var key = matches[i].substring(0, eqPos)
          var quotedValue = matches[i].substring(eqPos + 1)
          challenge[key] = quotedValue.substring(1, quotedValue.length - 1)
        }

        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass)
        var ha2 = md5(self.method + ':' + self.uri.path)
        var digestResponse = md5(ha1 + ':' + challenge.nonce + ':1::auth:' + ha2)
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: challenge.qop,
          response: digestResponse,
          nc: 1,
          cnonce: ''
        }

        authHeader = []
        for (var k in authValues) {
          authHeader.push(k + '="' + authValues[k] + '"')
        }
        authHeader = 'Digest ' + authHeader.join(', ')
        self.setHeader('authorization', authHeader)
        self._sentAuth = true

        redirectTo = self.uri
        break
    }
  }

  if (redirectTo) {
    debug('redirect to', redirectTo)

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused) response.resume()

    if (self._redirectsFollowed >= self.maxRedirects) {
      self.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop "+self.uri.href))
      return
    }
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(self.uri.href, redirectTo)
    }

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo)

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol) {
      self._updateProtocol()
    }

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
      }
    )
    if (self.followAllRedirects && response.statusCode != 401) self.method = 'GET'
    // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode != 401) {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers) {
        delete self.headers.host
        delete self.headers['content-type']
        delete self.headers['content-length']
      }
    }

    self.emit('redirect');

    self.init()
    return // Ignore the rest of the response
  } else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) self.response.emit('end')
    })

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.")
      } else {
        response.setEncoding(self.encoding)
      }
    }

    self.emit('response', response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    response.on("data", function (chunk) {
      self._destdata = true
      self.emit("data", chunk)
    })
    response.on("end", function (chunk) {
      self._ended = true
      self.emit("end", chunk)
    })
    response.on("close", function () {self.emit("close")})

    if (self.callback) {
      var buffer = []
      var bodyLen = 0
      self.on("data", function (chunk) {
        buffer.push(chunk)
        bodyLen += chunk.length
      })
      self.on("end", function () {
        debug('end event', self.uri.href)
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }

        if (buffer.length && Buffer.isBuffer(buffer[0])) {
          debug('has body', self.uri.href, bodyLen)
          var body = new Buffer(bodyLen)
          var i = 0
          buffer.forEach(function (chunk) {
            chunk.copy(body, i, 0, chunk.length)
            i += chunk.length
          })
          if (self.encoding === null) {
            response.body = body
          } else {
            response.body = body.toString(self.encoding)
          }
        } else if (buffer.length) {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === "\uFEFF") {
            buffer[0] = buffer[0].substring(1)
          }
          response.body = buffer.join('')
        }

        if (self._json) {
          try {
            response.body = JSON.parse(response.body)
          } catch (e) {}
        }
        debug('emitting complete', self.uri.href)
        if(response.body == undefined && !self._json) {
          response.body = "";
        }
        self.emit('complete', response, response.body)
      })
    }
  }
  debug('finish init function', self.uri.href)
}

Request.prototype.abort = function () {
  this._aborted = true

  if (this.req) {
    this.req.abort()
  }
  else if (this.response) {
    this.response.abort()
  }

  this.emit("abort")
}

Request.prototype.pipeDest = function (dest) {
  var response = this.response
  // Called after the response is received
  if (dest.headers) {
    dest.headers['content-type'] = response.headers['content-type']
    if (response.headers['content-length']) {
      dest.headers['content-length'] = response.headers['content-length']
    }
  }
  if (dest.setHeader) {
    for (var i in response.headers) {
      dest.setHeader(i, response.headers[i])
    }
    dest.statusCode = response.statusCode
  }
  if (this.pipefilter) this.pipefilter(response, dest)
}

// Composable API
Request.prototype.setHeader = function (name, value, clobber) {
  if (clobber === undefined) clobber = true
  if (clobber || !this.headers.hasOwnProperty(name)) this.headers[name] = value
  else this.headers[name] += ',' + value
  return this
}
Request.prototype.setHeaders = function (headers) {
  for (var i in headers) {this.setHeader(i, headers[i])}
  return this
}
Request.prototype.qs = function (q, clobber) {
  var base
  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)
  else base = {}

  for (var i in q) {
    base[i] = q[i]
  }

  if (qs.stringify(base) === ''){
    return this
  }

  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))
  this.url = this.uri
  this.path = this.uri.path

  return this
}
Request.prototype.form = function (form) {
  if (form) {
    this.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'
    this.body = qs.stringify(form).toString('utf8')
    return this
  }
  // create form-data object
  this._form = new FormData()
  return this._form
}
Request.prototype.multipart = function (multipart) {
  var self = this
  self.body = []

  if (!self.headers['content-type']) {
    self.headers['content-type'] = 'multipart/related; boundary=' + self.boundary
  } else {
    self.headers['content-type'] = self.headers['content-type'].split(';')[0] + '; boundary=' + self.boundary
  }

  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')

  if (self.preambleCRLF) {
    self.body.push(new Buffer('\r\n'))
  }

  multipart.forEach(function (part) {
    var body = part.body
    if(body == null) throw Error('Body attribute missing in multipart.')
    delete part.body
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function (key) {
      preamble += key + ': ' + part[key] + '\r\n'
    })
    preamble += '\r\n'
    self.body.push(new Buffer(preamble))
    self.body.push(new Buffer(body))
    self.body.push(new Buffer('\r\n'))
  })
  self.body.push(new Buffer('--' + self.boundary + '--'))
  return self
}
Request.prototype.json = function (val) {
  var self = this;
  var setAcceptHeader = function() {
  	if (!self.headers['accept'] && !self.headers['Accept']) {
			  self.setHeader('accept', 'application/json')
		}
	}
  setAcceptHeader();
  this._json = true
  if (typeof val === 'boolean') {
    if (typeof this.body === 'object') {
      setAcceptHeader();
      this.body = safeStringify(this.body)
      self.setHeader('content-type', 'application/json')
    }
  } else {
    setAcceptHeader();
    this.body = safeStringify(val)
    self.setHeader('content-type', 'application/json')
  }
  return this
}
function getHeader(name, headers) {
    var result, re, match
    Object.keys(headers).forEach(function (key) {
        re = new RegExp(name, 'i')
        match = key.match(re)
        if (match) result = headers[key]
    })
    return result
}
Request.prototype.auth = function (user, pass, sendImmediately) {
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    throw new Error('auth() received invalid user or password')
  }
  this._user = user
  this._pass = pass
  this._hasAuth = true
  if (sendImmediately || typeof sendImmediately == 'undefined') {
    this.setHeader('authorization', 'Basic ' + toBase64(user + ':' + pass))
    this._sentAuth = true
  }
  return this
}
Request.prototype.aws = function (opts, now) {
  if (!now) {
    this._aws = opts
    return this
  }
  var date = new Date()
  this.setHeader('date', date.toUTCString())
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: this.method.toUpperCase()
    , date: date
    , contentType: getHeader('content-type', this.headers) || ''
    , md5: getHeader('content-md5', this.headers) || ''
    , amazonHeaders: aws.canonicalizeHeaders(this.headers)
    }
  if (opts.bucket && this.path) {
    auth.resource = '/' + opts.bucket + this.path
  } else if (opts.bucket && !this.path) {
    auth.resource = '/' + opts.bucket
  } else if (!opts.bucket && this.path) {
    auth.resource = this.path
  } else if (!opts.bucket && !this.path) {
    auth.resource = '/'
  }
  auth.resource = aws.canonicalizeResource(auth.resource)
  this.setHeader('authorization', aws.authorization(auth))

  return this
}
Request.prototype.httpSignature = function (opts) {
  var req = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return getHeader(header, req.headers)
    },
    setHeader: function(header, value) {
      req.setHeader(header, value)
    },
    method: this.method,
    path: this.path
  }, opts)
  debug('httpSignature authorization', getHeader('authorization', this.headers))

  return this
}

Request.prototype.hawk = function (opts) {
  this.headers.Authorization = hawk.client.header(this.uri, this.method, opts).field
}

Request.prototype.oauth = function (_oauth) {
  var form
  if (this.headers['content-type'] &&
      this.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===
        'application/x-www-form-urlencoded'
     ) {
    form = qs.parse(this.body)
  }
  if (this.uri.query) {
    form = qs.parse(this.uri.query)
  }
  if (!form) form = {}
  var oa = {}
  for (var i in form) oa[i] = form[i]
  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]
  if (!oa.oauth_version) oa.oauth_version = '1.0'
  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')

  oa.oauth_signature_method = 'HMAC-SHA1'

  var consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret
  var timestamp = oa.oauth_timestamp

  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname
  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)

  // oa.oauth_signature = signature
  for (var i in form) {
    if ( i.slice(0, 'oauth_') in _oauth) {
      // skip
    } else {
      delete oa['oauth_'+i]
      if (i !== 'x_auth_mode') delete oa[i]
    }
  }
  oa.oauth_timestamp = timestamp
  this.headers.Authorization =
    'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'="'+oauth.rfc3986(oa[i])+'"'}).join(',')
  this.headers.Authorization += ',oauth_signature="' + oauth.rfc3986(signature) + '"'
  return this
}
Request.prototype.jar = function (jar) {
  var cookies

  if (this._redirectsFollowed === 0) {
    this.originalCookieHeader = this.headers.cookie
  }

  if (jar === false) {
    // disable cookies
    cookies = false
    this._disableCookies = true
  } else if (jar) {
    // fetch cookie from the user defined cookie jar
    cookies = jar.get({ url: this.uri.href })
  } else {
    // fetch cookie from the global cookie jar
    cookies = cookieJar.get({ url: this.uri.href })
  }

  if (cookies && cookies.length) {
    var cookieString = cookies.map(function (c) {
      return c.name + "=" + c.value
    }).join("; ")

    if (this.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      this.headers.cookie = this.originalCookieHeader + '; ' + cookieString
    } else {
      this.headers.cookie = cookieString
    }
  }
  this._jar = jar
  return this
}


// Stream API
Request.prototype.pipe = function (dest, opts) {
  if (this.response) {
    if (this._destdata) {
      throw new Error("You cannot pipe after data has been emitted from the response.")
    } else if (this._ended) {
      throw new Error("You cannot pipe after the response has been ended.")
    } else {
      stream.Stream.prototype.pipe.call(this, dest, opts)
      this.pipeDest(dest)
      return dest
    }
  } else {
    this.dests.push(dest)
    stream.Stream.prototype.pipe.call(this, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  if (!this._started) this.start()
  return this.req.write.apply(this.req, arguments)
}
Request.prototype.end = function (chunk) {
  if (chunk) this.write(chunk)
  if (!this._started) this.start()
  this.req.end()
}
Request.prototype.pause = function () {
  if (!this.response) this._paused = true
  else this.response.pause.apply(this.response, arguments)
}
Request.prototype.resume = function () {
  if (!this.response) this._paused = false
  else this.response.resume.apply(this.response, arguments)
}
Request.prototype.destroy = function () {
  if (!this._ended) this.end()
  else if (this.response) this.response.destroy()
}

// organize params for patch, post, put, head, del
function initParams(uri, options, callback) {
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
    uri = options.uri
  }
  return { uri: uri, options: options, callback: callback }
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
  }

  options = copy(options)

  if (callback) options.callback = callback
  var r = new Request(options)
  return r
}

module.exports = request

request.Request = Request;

request.debug = process.env.NODE_DEBUG && /request/.test(process.env.NODE_DEBUG)

request.initParams = initParams

request.defaults = function (options, requester) {
  var def = function (method) {
    var d = function (uri, opts, callback) {
      var params = initParams(uri, opts, callback)
      for (var i in options) {
        if (params.options[i] === undefined) params.options[i] = options[i]
      }
      if(typeof requester === 'function') {
        if(method === request) {
          method = requester
        } else {
          params.options._requester = requester
        }
      }
      return method(params.options, params.callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.patch = def(request.patch)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  de.cookie = def(request.cookie)
  de.jar = request.jar
  return de
}

request.forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    for (option in optionsArg) {
      options[option] = optionsArg[option]
    }
  }
  if (agentOptions) options.agentOptions = agentOptions
  options.forever = true
  return request.defaults(options)
}

request.get = request
request.post = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'POST'
  return request(params.uri || null, params.options, params.callback)
}
request.put = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PUT'
  return request(params.uri || null, params.options, params.callback)
}
request.patch = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PATCH'
  return request(params.uri || null, params.options, params.callback)
}
request.head = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'HEAD'
  if (params.options.body ||
      params.options.requestBodyStream ||
      (params.options.json && typeof params.options.json !== 'boolean') ||
      params.options.multipart) {
    throw new Error("HTTP HEAD requests MUST NOT include a request body.")
  }
  return request(params.uri || null, params.options, params.callback)
}
request.del = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'DELETE'
  if(typeof params.options._requester === 'function') {
    request = params.options._requester
  }
  return request(params.uri || null, params.options, params.callback)
}
request.jar = function () {
  return new CookieJar
}
request.cookie = function (str) {
  if (str && str.uri) str = str.uri
  if (typeof str !== 'string') throw new Error("The cookie function only accepts STRING as param")
  return new Cookie(str)
}

// Safe toJSON

function getSafe (self, uuid) {
  if (typeof self === 'object' || typeof self === 'function') var safe = {}
  if (Array.isArray(self)) var safe = []

  var recurse = []

  Object.defineProperty(self, uuid, {})

  var attrs = Object.keys(self).filter(function (i) {
    if (i === uuid) return false
    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true
    return !(Object.getOwnPropertyDescriptor(self[i], uuid))
  })


  for (var i=0;i<attrs.length;i++) {
    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') ||
          self[attrs[i]] === null
        ) {
      safe[attrs[i]] = self[attrs[i]]
    } else {
      recurse.push(attrs[i])
      Object.defineProperty(self[attrs[i]], uuid, {})
    }
  }

  for (var i=0;i<recurse.length;i++) {
    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)
  }

  return safe
}

function toJSON () {
  return getSafe(this, '__' + (((1+Math.random())*0x10000)|0).toString(16))
}

Request.prototype.toJSON = toJSON

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"http":7,"url":1,"util":3,"stream":5,"querystring":2,"crypto":11,"https":6,"tls":8,"oauth-sign":20,"aws-sign":21,"http-signature":22,"node-uuid":23,"mime":24,"tunnel-agent":25,"json-stringify-safe":26,"forever-agent":27,"cookie-jar":28,"qs":29,"hawk":30,"form-data":31,"__browserify_process":9,"__browserify_buffer":19}],13:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],14:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],15:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],32:[function(require,module,exports){
// todo

},{}],17:[function(require,module,exports){

},{}],20:[function(require,module,exports){
var crypto = require('crypto')
  , qs = require('querystring')
  ;

function sha1 (key, body) {
  return crypto.createHmac('sha1', key).update(body).digest('base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
    ;
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  var querystring = Object.keys(params).sort().map(function(key){
    // big WTF here with the escape + encoding but it's what twitter wants
    return escape(rfc3986(key)) + "%3D" + escape(rfc3986(params[key]))
  }).join('%26')

  var base = [
    httpMethod ? httpMethod.toUpperCase() : 'GET',
    rfc3986(base_uri),
    querystring
  ].join('&')

  var key = [
    consumer_secret,
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha1(key, base)
}

exports.hmacsign = hmacsign
exports.rfc3986 = rfc3986

},{"crypto":11,"querystring":2}],21:[function(require,module,exports){

/*!
 * knox - auth
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var crypto = require('crypto')
  , parse = require('url').parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date.toUTCString()
    , headers + options.resource
    ]
  return r.join('\n')
}
module.exports.queryStringToSign = stringToSign

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource

},{"crypto":11,"url":1}],23:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     (c) 2010-2012 Robert Kieffer
//     MIT License
//     https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (_global.define && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}());

})(require("__browserify_buffer").Buffer)
},{"crypto":11,"__browserify_buffer":19}],24:[function(require,module,exports){
(function(process,__dirname){var path = require('path');
var fs = require('fs');

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts]) {
        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/.*[\.\/]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  return this.extensions[mimeType];
};

// Default instance
var mime = new Mime();

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'));

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;

})(require("__browserify_process"),"/node_modules/request/node_modules/mime")
},{"path":33,"fs":34,"__browserify_process":9}],25:[function(require,module,exports){
(function(process,Buffer){'use strict'

var net = require('net')
  , tls = require('tls')
  , http = require('http')
  , https = require('https')
  , events = require('events')
  , assert = require('assert')
  , util = require('util')
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {
  var self = this

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: host, port: port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createSocket({host: host, port: port, request: req}, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    req.onSocket(socket)

    function onFree() {
      self.emit('free', socket, host, port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket()
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions, 
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return
  
  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket)
    })
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
      { servername: options.host
      , socket: socket
      }
    ))
    cb(secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"net":32,"tls":8,"http":7,"https":6,"events":4,"assert":18,"util":3,"__browserify_process":9,"__browserify_buffer":19}],26:[function(require,module,exports){
module.exports = stringify;

function getSerialize (fn, decycle) {
  var seen = [];
  decycle = decycle || function(key, value) {
    return '[Circular]';
  };
  return function(key, value) {
    var ret = value;
    if (typeof value === 'object' && value) {
      if (seen.indexOf(value) !== -1)
        ret = decycle(key, value);
      else
        seen.push(value);
    }
    if (fn) ret = fn(key, ret);
    return ret;
  }
}

function stringify(obj, fn, spaces, decycle) {
  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);
}

stringify.getSerialize = getSerialize;

},{}],27:[function(require,module,exports){
module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = require('util')
  , Agent = require('http').Agent
  , net = require('net')
  , tls = require('tls')
  , AgentSSL = require('https').Agent

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = host + ':' + port
    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket)
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = []
      self.freeSockets[name].push(socket)
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      function onIdleError() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy()
    }
  })

}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5


ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = host + ':' + port
  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else {
    this.addRequestNoreuse(req, host, port)
  }
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s)
    if (index !== -1) {
      this.sockets[name].splice(index, 1)
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name]
    delete this.requests[name]
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s)
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1)
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name]
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free')
  }
}

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}

},{"util":3,"http":7,"net":32,"tls":8,"https":6}],29:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Create a nullary object if possible
 */

function createObject() {
  return Object.create
    ? Object.create(null)
    : {};
}

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = createObject();
  var t = createObject();
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = createObject();
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Restore Object.prototype.
 * see pull-request #58
 */

function restoreProto(obj) {
  if (!Object.create) return obj;
  if (isArray(obj)) return obj;
  if (obj && 'object' != typeof obj) return obj;

  for (var key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      obj[key] = restoreProto(obj[key]);
    }
  }

  obj.__proto__ = Object.prototype;
  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: createObject() }).base;

  return restoreProto(compact(ret));
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],35:[function(require,module,exports){
var Connection = require('./xmpp/connection');
var Client = require('./xmpp/client').Client;
var JID = require('./xmpp/jid');
var ltx = require('ltx');
var Stanza = require('./xmpp/stanza');

exports.Connection = Connection;
exports.Client = Client;
exports.JID = JID;
exports.Element = ltx.Element;
exports.Stanza = Stanza.Stanza;
exports.Message = Stanza.Message;
exports.Presence = Stanza.Presence;
exports.Iq = Stanza.Iq;

window.XMPP = exports;

},{"./xmpp/connection":36,"./xmpp/client":37,"./xmpp/jid":16,"./xmpp/stanza":38,"ltx":39}],40:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],12:[function(require,module,exports){
(function(){var assert = require('assert');
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

})()
},{"assert":18,"./buffer_ieee754":40,"base64-js":41}],33:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":9}],34:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],28:[function(require,module,exports){
/*!
 * Tobi - Cookie
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var url = require('url');

/**
 * Initialize a new `Cookie` with the given cookie `str` and `req`.
 *
 * @param {String} str
 * @param {IncomingRequest} req
 * @api private
 */

var Cookie = exports = module.exports = function Cookie(str, req) {
  this.str = str;

  // Map the key/val pairs
  str.split(/ *; */).reduce(function(obj, pair){
   var p = pair.indexOf('=');
   var key = p > 0 ? pair.substring(0, p).trim() : pair.trim();
   var lowerCasedKey = key.toLowerCase();
   var value = p > 0 ? pair.substring(p + 1).trim() : true;

   if (!obj.name) {
    // First key is the name
    obj.name = key;
    obj.value = value;
   }
   else if (lowerCasedKey === 'httponly') {
    obj.httpOnly = value;
   }
   else {
    obj[lowerCasedKey] = value;
   }
   return obj;
  }, this);

  // Expires
  this.expires = this.expires
    ? new Date(this.expires)
    : Infinity;

  // Default or trim path
  this.path = this.path
    ? this.path.trim(): req 
    ? url.parse(req.url).pathname: '/';
};

/**
 * Return the original cookie string.
 *
 * @return {String}
 * @api public
 */

Cookie.prototype.toString = function(){
  return this.str;
};

module.exports.Jar = require('./jar')
},{"url":1,"./jar":42}],43:[function(require,module,exports){
// Target API:
//
//  var s = require('net').createStream(25, 'smtp.example.com');
//  s.on('connect', function() {
//   require('starttls')(s, creds, false, function() {
//      if (!s.authorized) {
//        s.destroy();
//        return;
//      }
//
//      s.end("hello world\n");
//    });
//  });

var crypto = require('crypto');
var tls = require('tls');

module.exports = function starttls(socket, credentials, isServer, cb) {

  var pair = tls.createSecurePair(credentials, isServer, false, !isServer);

  var cleartext = pipe(pair, socket);

  pair.on('secure', function() {
    var ssl = pair._ssl || pair.ssl;
    var verifyError = ssl.verifyError();

    if (verifyError) {
      cleartext.authorized = false;
      cleartext.authorizationError = verifyError;
    } else {
      cleartext.authorized = true;
    }

    if (cb) cb();
  });

  cleartext._controlReleased = true;
  return cleartext;
};


function pipe(pair, socket) {
  pair.encrypted.pipe(socket);
  socket.pipe(pair.encrypted);

  pair.fd = socket.fd;
  var cleartext = pair.cleartext;
  cleartext.socket = socket;
  cleartext.encrypted = pair.encrypted;
  cleartext.authorized = false;

  function onerror(e) {
    if (cleartext._controlReleased) {
      cleartext.emit('error', e);
    }
  }

  function onclose() {
    socket.removeListener('error', onerror);
    socket.removeListener('close', onclose);
  }

  socket.on('error', onerror);
  socket.on('close', onclose);

  return cleartext;
}

},{"crypto":11,"tls":8}],22:[function(require,module,exports){
// Copyright 2011 Joyent, Inc.  All rights reserved.

var parser = require('./parser');
var signer = require('./signer');
var verify = require('./verify');
var util = require('./util');



///--- API

module.exports = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,

  sshKeyToPEM: util.sshKeyToPEM,
  sshKeyFingerprint: util.fingerprint,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature
};

},{"./parser":44,"./signer":45,"./verify":46,"./util":47}],41:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],48:[function(require,module,exports){
var Stream = require('stream');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

Response.prototype = new Stream;

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":5}],42:[function(require,module,exports){
/*!
* Tobi - CookieJar
* Copyright(c) 2010 LearnBoost <dev@learnboost.com>
* MIT Licensed
*/

/**
* Module dependencies.
*/

var url = require('url');

/**
* Initialize a new `CookieJar`.
*
* @api private
*/

var CookieJar = exports = module.exports = function CookieJar() {
  this.cookies = [];
};

/**
* Add the given `cookie` to the jar.
*
* @param {Cookie} cookie
* @api private
*/

CookieJar.prototype.add = function(cookie){
  this.cookies = this.cookies.filter(function(c){
    // Avoid duplication (same path, same name)
    return !(c.name == cookie.name && c.path == cookie.path);
  });
  this.cookies.push(cookie);
};

/**
* Get cookies for the given `req`.
*
* @param {IncomingRequest} req
* @return {Array}
* @api private
*/

CookieJar.prototype.get = function(req){
  var path = url.parse(req.url).pathname
    , now = new Date
    , specificity = {};
  return this.cookies.filter(function(cookie){
    if (0 == path.indexOf(cookie.path) && now < cookie.expires
      && cookie.path.length > (specificity[cookie.name] || 0))
      return specificity[cookie.name] = cookie.path.length;
  });
};

/**
* Return Cookie string for the given `req`.
*
* @param {IncomingRequest} req
* @return {String}
* @api private
*/

CookieJar.prototype.cookieString = function(req){
  var cookies = this.get(req);
  if (cookies.length) {
    return cookies.map(function(cookie){
      return cookie.name + '=' + cookie.value;
    }).join('; ');
  }
};

},{"url":1}],30:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":49}],39:[function(require,module,exports){
/* Cause browserify to bundle SAX parsers: */
//require('./sax_easysax');
//require('./sax_saxjs');
require('./sax_ltx');

/* SHIM */
module.exports = require('./index');
},{"./sax_ltx":50,"./index":51}],52:[function(require,module,exports){
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var Connection = require('./connection');
var BOSH = require('./bosh');
var WebSockets = require('./websockets');
var JID = require('./jid').JID;
var tls = require('tls');
var crypto = require('crypto');
var SRV = require('./srv');

function Session(opts) {
    var self = this;
    EventEmitter.call(this);

    if (typeof opts.jid == 'string')
        this.jid = new JID(opts.jid);
    else
        this.jid = opts.jid;
    this.password = opts.password;
    this.preferredSaslMechanism = opts.preferredSaslMechanism;
    this.availableSaslMechanisms = [];
    this.api_key = opts.api_key;
    this.access_token = opts.access_token;
    this.oauth2_token = opts.oauth2_token;
    this.oauth2_auth = opts.oauth2_auth;
    this.register = opts.register;
    if (typeof opts.actAs == 'string') 
    	this.actAs = new JID(opts.actAs);
    else
        this.actAs = opts.actAs;
    delete this.did_bind;
    delete this.did_session;

    if (opts.websocketsURL) {
	this.connection = new WebSockets.WSConnection(opts.websocketsURL);
	this.connection.on('connected', function() {
	    if (self.connection.startStream)
		self.connection.startStream();
	});
    } else if (opts.boshURL) {
	this.connection = new BOSH.BOSHConnection({
	    jid: this.jid,
	    boshURL: opts.boshURL
	});
    } else {
	this.connection = new Connection.Connection({
	    xmlns: { '': opts.xmlns },
	    streamAttrs: {
		version: "1.0",
		to: this.jid.domain
	    }
	});
	var connect = function() {
	    if (opts.host) {
    	    self.connection.on('connect', function() {
    	        if (self.connection.startStream)
    		        self.connection.startStream();
    	    });

	        if (opts.legacySSL) {
	            self.connection.allowTLS = false;
	            self.connection.socket = tls.connect(opts.port || 5223, opts.host, opts.credentials || {}, function() {
	                self.connection.setupStream();
	                self.connection.startParser();
            	    self.connection.emit('connect');
	            });
	        } else {
	            if (opts.credentials) {
	                self.connection.credentials = crypto.createCredentials(opts.credentials);
	            }
	            self.connection.socket.on("connect", function() {
                        self.connection.emit('connect')
                    })
                    self.connection.socket.connect(opts.port || 5222, opts.host);
    		}
	    } else if (!SRV) {
		    throw "Cannot load SRV";
	    } else {
	        if (opts.legacySSL) {
	            throw "LegacySSL mode does not support DNS lookups";
	        }

            if (opts.credentials) {
                self.connection.credentials = crypto.createCredentials(opts.credentials);
            }
	        
		    var attempt = SRV.connect(self.connection.socket,
		        ['_xmpp-client._tcp'], self.jid.domain, 5222);
		    attempt.addListener('connect', function() {
		    if (self.connection.startStream)
			    self.connection.startStream();
		});
		attempt.addListener('error', function(e) {
		    self.emit('error', e);
		});
	    }
	};
	if (opts.reconnect)
	    self.reconnect = connect;
	connect();
    }
    this.connection.addListener('stanza', this.onStanza.bind(this));
    this.connection.addListener('drain', this.emit.bind(this, 'drain'));

    this.connection.addListener('end', function() {
        self.emit('end');
    });
    this.connection.addListener('close', function() {
        self.emit('close');
    });
}

util.inherits(Session, EventEmitter);
exports.Session = Session;


Session.prototype.pause = function() {
    if (this.connection && this.connection.pause)
	this.connection.pause();
};

Session.prototype.resume = function() {
    if (this.connection && this.connection.resume)
	this.connection.resume();
};

Session.prototype.send = function(stanza) {
    if (this.connection)
	this.connection.send(stanza.root());
};

Session.prototype.end = function() {
    if (this.connection)
	this.connection.end();
};

Session.prototype.onStanza = function(stanza) {
};

},{"util":3,"events":4,"tls":8,"crypto":11,"./srv":17,"./bosh":53,"./connection":36,"./websockets":54,"./jid":16}],50:[function(require,module,exports){
var util = require('util');
var events = require('events');

const STATE_TEXT = 0,
    STATE_IGNORE_TAG = 1,
    STATE_TAG_NAME = 2,
    STATE_TAG = 3,
    STATE_ATTR_NAME = 4,
    STATE_ATTR_EQ = 5,
    STATE_ATTR_QUOT = 6,
    STATE_ATTR_VALUE = 7;

var RE_TAG_NAME = /^[^\s\/>]+$/,
    RE_ATTR_NAME = /^[^\s=]+$/;

var SaxLtx = module.exports = function SaxLtx() {
    events.EventEmitter.call(this);

    var state = STATE_TEXT, remainder;
    var tagName, attrs, endTag, selfClosing, attrQuote;
    var recordStart = 0;

    this.write = function(data) {
	if (typeof data !== 'string')
	    data = data.toString();
        var pos = 0
        var attrName

	/* Anything from previous write()? */
	if (remainder) {
	    data = remainder + data;
	    pos += remainder.length;
	    delete remainder;
	}

	function endRecording() {
	    if (typeof recordStart === 'number') {
		var recorded = data.slice(recordStart, pos);
		recordStart = undefined;
		return recorded;
	    }
	}

	for(; pos < data.length; pos++) {
	    var c = data.charCodeAt(pos);
	    //console.log("state", state, "c", c, data[pos]);
	    switch(state) {
	    case STATE_TEXT:
		if (c === 60 /* < */) {
		    var text = endRecording();
		    if (text)
			this.emit('text', unescapeXml(text));
		    state = STATE_TAG_NAME;
		    recordStart = pos + 1;
		    attrs = {};
		}
		break;
	    case STATE_TAG_NAME:
		if (c === 47 /* / */ && recordStart === pos) {
		    recordStart = pos + 1;
		    endTag = true;
		} else if (c === 33 /* ! */ || c === 63 /* ? */) {
		    recordStart = undefined;
		    state = STATE_IGNORE_TAG;
		} else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
		    tagName = endRecording();
		    pos--;
		    state = STATE_TAG;
		}
		break;
	    case STATE_IGNORE_TAG:
		if (c === 62 /* > */) {
		    state = STATE_TEXT;
		}
		break;
	    case STATE_TAG:
		if (c === 62 /* > */) {
		    if (!endTag) {
			this.emit('startElement', tagName, attrs);
			if (selfClosing)
			    this.emit('endElement', tagName);
		    } else
			this.emit('endElement', tagName);
		    tagName = undefined;
		    attrs = undefined;
		    endTag = undefined;
		    selfClosing = undefined;
		    state = STATE_TEXT;
		    recordStart = pos + 1;
		} else if (c === 47 /* / */) {
		    selfClosing = true;
		} else if (c > 32) {
		    recordStart = pos;
		    state = STATE_ATTR_NAME;
		}
		break;
	    case STATE_ATTR_NAME:
		if (c <= 32 || c === 61 /* = */) {
		    attrName = endRecording();
		    pos--;
		    state = STATE_ATTR_EQ;
		}
		break;
	    case STATE_ATTR_EQ:
		if (c === 61 /* = */) {
		    state = STATE_ATTR_QUOT;
		}
		break;
	    case STATE_ATTR_QUOT:
		if (c === 34 /* " */ || c === 39 /* ' */) {
		    attrQuote = c;
		    state = STATE_ATTR_VALUE;
		    recordStart = pos + 1;
		}
		break;
	    case STATE_ATTR_VALUE:
		if (c === attrQuote) {
		    var value = unescapeXml(endRecording());
		    attrs[attrName] = value;
		    attrName = undefined;
		    state = STATE_TAG;
		}
		break;
	    }
	}

	if (typeof recordStart === 'number' &&
	    recordStart <= data.length) {

	    remainder = data.slice(recordStart);
	    recordStart = 0;
	}
    };

    /*var origEmit = this.emit;
    this.emit = function() {
	console.log('ltx', arguments);
	origEmit.apply(this, arguments);
    };*/
};
util.inherits(SaxLtx, events.EventEmitter);


SaxLtx.prototype.end = function(data) {
    if (data)
	this.write(data);

    /* Uh, yeah */
    this.write = function() {
    };
};

function unescapeXml(s) {
    return s.
        replace(/\&amp;/g, '&').
        replace(/\&lt;/g, '<').
        replace(/\&gt;/g, '>').
        replace(/\&quot;/g, '"').
        replace(/\&apos;/g, '\'');
}

},{"util":3,"events":4}],10:[function(require,module,exports){
(function(){var Stream = require('stream');
var Response = require('./response');
var concatStream = require('concat-stream')
var Buffer = require('buffer')

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = concatStream()
    
    var uri = params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    xhr.open(
        params.method || 'GET',
        (params.scheme || 'http') + '://' + uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + new Buffer(params.auth).toString('base64'));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

Request.prototype = new Stream;

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.write(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.write(s);
    this.body.end()
    this.xhr.send(this.body.getBody());
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

})()
},{"stream":5,"buffer":12,"./response":48,"concat-stream":55}],36:[function(require,module,exports){
var net = require('net');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var ltx = require('ltx');
var StreamParser = require('./stream_parser');
var starttls = require('../starttls');

var NS_XMPP_TLS = exports.NS_XMPP_TLS = 'urn:ietf:params:xml:ns:xmpp-tls';
var NS_STREAM = exports.NS_STREAM = 'http://etherx.jabber.org/streams';
var NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams';

/**
 Base class for connection-based streams (TCP).

 The socket parameter is optional for incoming connections.
*/

var MAX_RECONNECT_DELAY = 30 * 1000;


function Connection(opts) {
    EventEmitter.call(this);

    this.streamAttrs = (opts && opts.streamAttrs) || {};
    this.xmlns = (opts && opts.xmlns) || {};
    this.xmlns.stream = NS_STREAM;

    this.socket = (opts && opts.socket) || new net.Socket();
    this.reconnectDelay = 0;

    this.setupStream();
    if (this.socket.readable)
	this.startParser();
    else {
	var that = this;
	this.socket.on('connect', function() {
	    that.startParser();
	    that.emit('connect');
	});
    }

    this.mixins = [];
}

util.inherits(Connection, EventEmitter);
exports.Connection = Connection;

// Defaults
Connection.prototype.allowTLS = true;

/**
 Used by both the constructor and by reinitialization in setSecure().
*/
Connection.prototype.setupStream = function() {
    var self = this;

    this.socket.addListener('data', function(data) {
        self.onData(data);
    });
    this.socket.addListener('end', function() {
        self.onEnd();
    });
    this.socket.addListener('error', function() {
	/* unhandled errors may throw up in node, preventing a reconnect */
        self.onEnd();
    });
    this.socket.addListener('close', function() {
	self.onClose();
    });
    var proxyEvent = function(event) {
        self.socket.addListener(event, function() {
	    var args = Array.prototype.slice.call(arguments);
	    args.unshift(event);
	    self.emit.apply(self, args);
        });
    };
    proxyEvent('data');  // let them sniff unparsed XML
    proxyEvent('drain');
    //proxyEvent('close');

    /**
     * This is optimized for continuous TCP streams. If your "socket"
     * actually transports frames (WebSockets) and you can't have
     * stanzas split across those, use:
     *     cb(el.toString());
     */
    if (!this.socket.serializeStanza) {
        this.socket.serializeStanza = function(el, cb) {
            // Continuously write out
            el.write(function(s) {
                cb(s);
            });
        };
    }
};


Connection.prototype.pause = function() {
    if (this.socket.pause)
	this.socket.pause();
};

Connection.prototype.resume = function() {
    if (this.socket.resume)
	this.socket.resume();
};

/** Climbs the stanza up if a child was passed,
    but you can send strings and buffers too.

    Returns whether the socket flushed data.
*/
Connection.prototype.send = function(stanza) {
    var self = this;
    var flushed = true;
    if (!this.socket) {
        return; // Doh!
    }
    if (!this.socket.writable) {
        this.socket.end();
        return;
    }

    if (stanza.root) {
        var el = this.rmXmlns(stanza.root());
        this.socket.serializeStanza(el, function(s) {
            flushed = self.socket.write(s);
        });
    } else {
        flushed = this.socket.write(stanza);
    }
    return flushed;
};

Connection.prototype.startParser = function() {
    var self = this;
    this.parser = new StreamParser.StreamParser(this.maxStanzaSize);

    this.parser.addListener('streamStart', function(attrs) {
        /* We need those xmlns often, store them extra */
        self.streamNsAttrs = {};
        for(var k in attrs) {
        if (k == 'xmlns' ||
            k.substr(0, 6) == 'xmlns:')
                self.streamNsAttrs[k] = attrs[k];
        }

        /* Notify in case we don't wait for <stream:features/>
           (Component or non-1.0 streams)
         */
        self.emit('streamStart', attrs);
    });
    this.parser.addListener('stanza', function(stanza) {
        self.onStanza(self.addStreamNs(stanza));
    });
    this.parser.addListener('error', function(e) {
        self.error(e.condition || 'internal-server-error', e.message);
    });
    this.parser.addListener('end', function() {
        self.stopParser();
        self.end();
    });
};

Connection.prototype.stopParser = function() {
    /* No more events, please (may happen however) */
    if(this.parser) {
        /* Get GC'ed */
        delete this.parser;
    }
};

Connection.prototype.startStream = function() {
    /* reset reconnect delay */
    this.reconnectDelay = 0;
    
    var attrs = {};
    for(var k in this.xmlns) {
        if (this.xmlns.hasOwnProperty(k)) {
            if (!k)
                attrs.xmlns = this.xmlns[k];
            else
                attrs['xmlns:' + k] = this.xmlns[k];
        }
    }
    for(k in this.streamAttrs) {
	if (this.streamAttrs.hasOwnProperty(k))
	    attrs[k] = this.streamAttrs[k];
    }

    if (this.streamTo) { // in case of a component connecting
        attrs.to = this.streamTo;
    }

    var el = new ltx.Element('stream:stream', attrs);
    // make it non-empty to cut the closing tag
    el.t(' ');
    var s = el.toString();
    this.send(s.substr(0, s.indexOf(' </stream:stream>')));

    this.streamOpened = true;
};

Connection.prototype.onData = function(data) {
    if (this.parser)
        this.parser.write(data);
};

Connection.prototype.setSecure = function(credentials, isServer) {
    var self = this;

    // Remove old event listeners
    this.socket.removeAllListeners('data');
    // retain socket 'end' listeners because ssl layer doesn't support it
    this.socket.removeAllListeners('drain');
    this.socket.removeAllListeners('close');
    // remove idle_timeout
    if (this.socket.clearTimer)
	this.socket.clearTimer();

    this.stopParser();
    var ct = starttls(this.socket, credentials || this.credentials, isServer, function() {
	self.isSecure = true;
	self.startParser();
	if (!isServer)
	    // Clients start <stream:stream>, servers reply
	    self.startStream();
    });
    ct.on('close', function() {
	self.onClose();
	self.isSecure = false;
    });

    // The socket is now the cleartext stream
    this.socket = ct;

    // Attach new listeners on the cleartext stream
    this.setupStream();
};

/**
 * This is not an event listener, but takes care of the TLS handshake
 * before 'stanza' events are emitted to the derived classes.
 */
Connection.prototype.onStanza = function(stanza) {
    if (stanza.is('error', NS_STREAM)) {
        /* TODO: extract error text */
        this.emit('error', stanza);
    } else if (stanza.is('features', NS_STREAM) &&
               this.allowTLS &&
	       !this.isSecure &&
               stanza.getChild('starttls', NS_XMPP_TLS)) {
        /* Signal willingness to perform TLS handshake */
        this.send(new ltx.Element('starttls', { xmlns: NS_XMPP_TLS }));
    } else if (this.allowTLS &&
               stanza.is('proceed', NS_XMPP_TLS)) {
        /* Server is waiting for TLS handshake */
        this.setSecure();
    } else {
        this.emit('stanza', stanza);
    }
};

/**
 * Add stream xmlns to a stanza
 *
 * Does not add our default xmlns as it is different for
 * C2S/S2S/Component connections.
 */
Connection.prototype.addStreamNs = function(stanza) {
    for(var attr in this.streamNsAttrs) {
        if (!stanza.attrs[attr] &&
	    !(attr === 'xmlns' &&
	      this.streamNsAttrs[attr] === this.xmlns['']))
            stanza.attrs[attr] = this.streamNsAttrs[attr];
    }
    return stanza;
};

/**
 * Remove superfluous xmlns that were aleady declared in
 * our <stream:stream>
 */
Connection.prototype.rmXmlns = function(stanza) {
    for(var prefix in this.xmlns) {
        var attr = prefix ? 'xmlns:'+prefix : 'xmlns';
        if (stanza.attrs[attr] == this.xmlns[prefix])
            delete stanza.attrs[attr];
    }
    return stanza;
};


/**
 * Connection has been ended by remote, we will not get any incoming
 * 'data' events. Alternatively, used for 'error' event.
 */
Connection.prototype.onEnd = function() {
    this.stopParser();
    if (this.socket)
        this.socket.end();
};

/**
 * XMPP-style end connection for user
 */
Connection.prototype.end = function() {
    if (this.socket.writable) {
        if (this.streamOpened) {
            this.socket.write('</stream:stream>');
            delete this.streamOpened;
	    /* wait for being called again upon 'end' from other side */
        } else {
            this.socket.end();
        }
    }
};

Connection.prototype.onClose = function() {
    if (!this.socket)
	/* A reconnect may have already been scheduled */
	return;

    delete this.socket;
    if (this.reconnect) {
	var self = this;
	setTimeout(function() {
	    self.socket = new net.Stream();
	    self.setupStream();
	    self.reconnect();
	}, this.reconnectDelay);
	console.log("Reconnect in", this.reconnectDelay);
	this.reconnectDelay += Math.ceil(Math.random() * 2000);
	if (this.reconnectDelay > MAX_RECONNECT_DELAY)
	    this.reconnectDelay = MAX_RECONNECT_DELAY;
    } else {
	this.emit('close');
    }
};

/**
 * End connection with stream error.
 * Emits 'error' event too.
 *
 * @param {String} condition XMPP error condition, see RFC3920 4.7.3. Defined Conditions
 * @param {String} text Optional error message
 */
Connection.prototype.error = function(condition, message) {
    this.emit('error', new Error(message));

    if (!this.socket || !this.socket.writable)
        return;

    if(!this.streamOpened)
        this.startStream(); /* RFC 3920, 4.7.1 stream-level errors rules */

    var e = new ltx.Element('stream:error');
    e.c(condition, { xmlns: NS_XMPP_STREAMS });
    if (message)
        e.c('text', { xmlns: NS_XMPP_STREAMS,
                      'xml:lang': 'en' }).
        t(message);

    this.send(e);
    this.end();
};

},{"net":32,"events":4,"util":3,"./stream_parser":56,"../starttls":43,"ltx":39}],37:[function(require,module,exports){
(function(){var EventEmitter = require('events').EventEmitter;
var Session = require('./session').Session;
var Connection = require('./connection');
var JID = require('./jid').JID;
var ltx = require('ltx');
var sasl = require('./sasl');
var util = require('util');
try {
    var SRV = require('./srv');
} catch (e) { }

var NS_CLIENT = 'jabber:client';
var NS_REGISTER = 'jabber:iq:register';
var NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl';
var NS_XMPP_BIND = 'urn:ietf:params:xml:ns:xmpp-bind';
var NS_XMPP_SESSION = 'urn:ietf:params:xml:ns:xmpp-session';

var STATE_PREAUTH = 0,
    STATE_AUTH = 1,
    STATE_AUTHED = 2,
    STATE_BIND = 3,
    STATE_SESSION = 4,
    STATE_ONLINE = 5;
var IQID_SESSION = 'sess',
    IQID_BIND = 'bind';

/**
 * params object:
 *   jid: String (required)
 *   password: String (required)
 *   host: String (optional)
 *   port: Number (optional)
 *   reconnect: Boolean (optional)
 *   register: Boolean (option) - register account before authentication
 *   legacySSL: Boolean (optional) - connect to the legacy SSL port, requires at least the host to be specified
 *   credentials: Dictionary (optional) - TLS or SSL key and certificate credentials
 *   actAs: String (optional) - if admin user act on behalf of another user (just user)
 *
 * Examples:
 *   var cl = new xmpp.Client({
 *       jid: "me@example.com",
 *       password: "secret"
 *   });
 *   var aceboo = new xmpp.Client({
 *       jid: '-' + fbUID + '@chat.facebook.com',
 *       api_key: '54321', // api key of your facebook app
 *       access_token: 'abcdefg', // user access token
 *       host: 'chat.facebook.com'
 *   });
 *   var gtalk = new xmpp.Client({
 *       jid: 'me@gmail.com',
 *       oauth2_token: 'xxxx.xxxxxxxxxxx', // from OAuth2
 *       oauth2_auth: 'http://www.google.com/talk/protocol/auth',
 *       host: 'talk.google.com'
 *   });
 *
 * Example SASL EXTERNAL:
 * 
 * var myCredentials = { 
 *   // These are necessary only if using the client certificate authentication
 *   key: fs.readFileSync('key.pem'),
 *   cert: fs.readFileSync('cert.pem'),
 *   // passphrase: 'optional'
 * };
 * var cl = new xmppClient({jid: "me@example.com", credentials: myCredentials }); 
 
 */
function Client(opts) {
    var self = this;

    opts.xmlns = NS_CLIENT;
    self.state = STATE_PREAUTH;
    delete self.did_bind;
    delete self.did_session;

    Session.call(this, opts);

    if (opts.credentials) {
        this.preferredSaslMechanism = 'EXTERNAL';
        this.availableSaslMechanisms = [ sasl.External ];
    }

    this.state = STATE_PREAUTH;
    this.addListener('end', function() {
        self.state = STATE_PREAUTH;
        self.emit('offline');
    });
    this.on('close', function() {
        self.state = STATE_PREAUTH;
    });
}

util.inherits(Client, Session);
exports.Client = Client;

Client.prototype.onStanza = function(stanza) {
    /* Actually, we shouldn't wait for <stream:features/> if
       this.streamAttrs.version is missing, but who uses pre-XMPP-1.0
       these days anyway? */
    if (this.state != STATE_ONLINE &&
        stanza.is('features', Connection.NS_STREAM)) {
        this.streamFeatures = stanza;
        this.useFeatures();
    } else if (this.state == STATE_AUTH) {
        if (stanza.is('challenge', NS_XMPP_SASL)) {
            var challengeMsg = decode64(stanza.getText());
            var responseMsg = encode64(this.mech.challenge(challengeMsg));
            this.send(new ltx.Element('response',
                                      { xmlns: NS_XMPP_SASL
                                      }).t(responseMsg));
        } else if (stanza.is('success', NS_XMPP_SASL)) {
            this.mech = null;
            this.state = STATE_AUTHED;
	    if (this.connection.startParser)
		this.connection.startParser();
	    if (this.connection.startStream)
		this.connection.startStream();
        } else {
            this.emit('error', 'XMPP authentication failure');
        }
    } else if (this.state == STATE_BIND &&
               stanza.is('iq') &&
               stanza.attrs.id == IQID_BIND) {
        if (stanza.attrs.type == 'result') {
            this.state = STATE_AUTHED;
            this.did_bind = true;

            var bindEl = stanza.getChild('bind', NS_XMPP_BIND);
            if (bindEl && bindEl.getChild('jid')) {
                this.jid = new JID(bindEl.getChild('jid').getText());
            }

            /* no stream restart, but next feature */
            this.useFeatures();
        } else {
            this.emit('error', 'Cannot bind resource');
        }
    } else if (this.state == STATE_SESSION &&
               stanza.is('iq') &&
               stanza.attrs.id == IQID_SESSION) {
        if (stanza.attrs.type == 'result') {
            this.state = STATE_AUTHED;
            this.did_session = true;

            /* no stream restart, but next feature (most probably
               we'll go online next) */
            this.useFeatures();
        } else {
            this.emit('error', 'Cannot bind resource');
        }
    } else if (stanza.name == 'stream:error') {
        this.emit('error', stanza);
    } else if (this.state == STATE_ONLINE) {
        this.emit('stanza', stanza);
    }
};

/**
 * Either we just received <stream:features/>, or we just enabled a
 * feature and are looking for the next.
 */
Client.prototype.useFeatures = function() {
    if (this.state == STATE_PREAUTH &&
        this.register) {
	delete this.register;
	this.doRegister();
    } else if (this.state == STATE_PREAUTH &&
        this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL)) {
        this.state = STATE_AUTH;
	var offeredMechs = this.streamFeatures.
            getChild('mechanisms', NS_XMPP_SASL).
            getChildren('mechanism', NS_XMPP_SASL).
            map(function(el) { return el.getText(); });
        this.mech = sasl.selectMechanism(
            offeredMechs,
            this.preferredSaslMechanism,
            this.availableSaslMechanisms);
        if (this.mech) {
            this.mech.authzid = this.jid.bare().toString();
            this.mech.authcid = this.jid.user;
            this.mech.password = this.password;
            this.mech.api_key = this.api_key;
            this.mech.access_token = this.access_token;
            this.mech.oauth2_token = this.oauth2_token;
            this.mech.oauth2_auth = this.oauth2_auth;
            this.mech.realm = this.jid.domain;  // anything?
            if (this.actAs) this.mech.actAs = this.actAs.user;
            this.mech.digest_uri = "xmpp/" + this.jid.domain;
            var authMsg = encode64(this.mech.auth());
            var attrs = this.mech.authAttrs();
            attrs.xmlns = NS_XMPP_SASL;
            attrs.mechanism = this.mech.name;
            this.send(new ltx.Element('auth', attrs).
		      t(authMsg));
        } else {
            this.emit('error', 'No usable SASL mechanism');
        }
    } else if (this.state == STATE_AUTHED &&
               !this.did_bind &&
               this.streamFeatures.getChild('bind', NS_XMPP_BIND)) {
        this.state = STATE_BIND;
        var bindEl = new ltx.Element('iq',
                                     { type: 'set',
                                       id: IQID_BIND
                                     }).c('bind',
                                          { xmlns: NS_XMPP_BIND
                                          });
        if (this.jid.resource)
            bindEl.c('resource').t(this.jid.resource);
        this.send(bindEl);
    } else if (this.state == STATE_AUTHED &&
               !this.did_session &&
               this.streamFeatures.getChild('session', NS_XMPP_SESSION)) {
        this.state = STATE_SESSION;
        this.send(new ltx.Element('iq',
                                  { type: 'set',
                                    to: this.jid.domain,
                                    id: IQID_SESSION
                                  }).c('session',
                                       { xmlns: NS_XMPP_SESSION
                                       }));
    } else if (this.state == STATE_AUTHED) {
        /* Ok, we're authenticated and all features have been
           processed */
        this.state = STATE_ONLINE;
        this.emit('online');
    }
};

Client.prototype.doRegister = function() {
    var id = "register" + Math.ceil(Math.random() * 99999);
    var iq = new ltx.Element('iq', { type: 'set',
				     id: id,
				     to: this.jid.domain
				   }).
	c('query', { xmlns: NS_REGISTER }).
	c('username').t(this.jid.user).up().
	c('password').t(this.password);
    this.send(iq);

    var that = this;
    var onReply = function(reply) {
	if (reply.is('iq') && reply.attrs.id === id) {
	    that.removeListener('stanza', onReply);

	    if (reply.attrs.type === 'result') {
		/* Registration successful, proceed to auth */
		that.useFeatures();
	    } else {
		that.emit('error', new Error("Registration error"));
	    }
	}
    };
    this.on('stanza', onReply);
};

Client.prototype.registerSaslMechanism = function () {
    var args = arguments.length > 0 ? Array.prototype.slice.call(arguments) : [];
    this.availableSaslMechanisms = this.availableSaslMechanisms.concat(args);
};

var decode64, encode64, Buffer;
if (typeof btoa === 'function') {
    decode64 = function(encoded) {
	return atob(encoded);
    };
} else {
    Buffer = require('buffer').Buffer;
    decode64 = function(encoded) {
	return (new Buffer(encoded, 'base64')).toString('utf8');
    };
}
if (typeof atob === 'function') {
    encode64 = function(decoded) {
	return btoa(decoded);
    };
} else {
    Buffer = require('buffer').Buffer;
    encode64 = function(decoded) {
	return (new Buffer(decoded, 'utf8')).toString('base64');
    };
}

})()
},{"events":4,"util":3,"./srv":17,"buffer":12,"./session":52,"./jid":16,"./connection":36,"./sasl":57,"ltx":39}],38:[function(require,module,exports){
var util = require('util');
var ltx = require('ltx');

function Stanza(name, attrs) {
    ltx.Element.call(this, name, attrs);
}
util.inherits(Stanza, ltx.Element);

/**
 * Common attribute getters/setters for all stanzas
 */

Stanza.prototype.__defineGetter__('from', function() {
    return this.attrs.from;
});
Stanza.prototype.__defineSetter__('from', function(from) {
    this.attrs.from = from;
});

Stanza.prototype.__defineGetter__('to', function() {
    return this.attrs.to;
});
Stanza.prototype.__defineSetter__('to', function(to) {
    this.attrs.to = to;
});

Stanza.prototype.__defineGetter__('id', function() {
    return this.attrs.id;
});
Stanza.prototype.__defineSetter__('id', function(id) {
    this.attrs.id = id;
});

Stanza.prototype.__defineGetter__('type', function() {
    return this.attrs.type;
});
Stanza.prototype.__defineSetter__('type', function(type) {
    this.attrs.type = type;
});


/**
 * Stanza kinds
 */

function Message(attrs) {
    Stanza.call(this, 'message', attrs);
}
util.inherits(Message, Stanza);

function Presence(attrs) {
    Stanza.call(this, 'presence', attrs);
}
util.inherits(Presence, Stanza);

function Iq(attrs) {
    Stanza.call(this, 'iq', attrs);
}
util.inherits(Iq, Stanza);

exports.Stanza = Stanza;
exports.Message = Message;
exports.Presence = Presence;
exports.Iq = Iq;

},{"util":3,"ltx":39}],55:[function(require,module,exports){
(function(Buffer){var stream = require('stream')
var util = require('util')

function ConcatStream(cb) {
  stream.Stream.call(this)
  this.writable = true
  if (cb) this.cb = cb
  this.body = []
  if (this.cb) this.on('error', cb)
}

util.inherits(ConcatStream, stream.Stream)

ConcatStream.prototype.write = function(chunk) {
  this.body.push(chunk)
}

ConcatStream.prototype.arrayConcat = function(arrs) {
  if (arrs.length === 0) return []
  if (arrs.length === 1) return arrs[0]
  return arrs.reduce(function (a, b) { return a.concat(b) })
}

ConcatStream.prototype.isArray = function(arr) {
  var isArray = Array.isArray(arr)
  var isTypedArray = arr.toString().match(/Array/)
  return isArray || isTypedArray
}

ConcatStream.prototype.getBody = function () {
  if (this.body.length === 0) return
  if (typeof(this.body[0]) === "string") return this.body.join('')
  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
    return Buffer.concat(this.body)
  }
  return this.body
}

ConcatStream.prototype.end = function() {
  if (this.cb) this.cb(false, this.getBody())
}

module.exports = function(cb) {
  return new ConcatStream(cb)
}

module.exports.ConcatStream = ConcatStream

})(require("__browserify_buffer").Buffer)
},{"stream":5,"util":3,"__browserify_buffer":19}],51:[function(require,module,exports){
var element = require('./element');
var parse = require('./parse');

/**
 * The only (relevant) data structure
 */
exports.Element = element.Element;
/**
 * Helper
 */
exports.escapeXml = element.escapeXml;

/**
 * DOM parser interface
 */
exports.parse = parse.parse;
exports.Parser = parse.Parser;
/**
 * SAX parser interface
 */
exports.availableSaxParsers = parse.availableSaxParsers;
exports.bestSaxParser = parse.bestSaxParser;

},{"./element":58,"./parse":59}],31:[function(require,module,exports){
(function(process,Buffer){var CombinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
var http = require('http');
var https = require('https');
var parseUrl = require('url').parse;
var fs = require('fs');
var mime = require('mime');
var async = require('async');

module.exports = FormData;
function FormData() {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this);
}
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options) {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') value = ''+value;

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter(field, value, options);

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ trackLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  this._lengthRetrievers.push(function(next) {

    // do we already know the size?
    // 0 additional leaves value from getSyncLength()
    if (options.knownLength != null) {
      next(null, 0);

    // check if it's local file
    } else if (value.hasOwnProperty('fd')) {
      fs.stat(value.path, function(err, stat) {
        if (err) {
          next(err);
          return;
        }

        next(null, stat.size);
      });

    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
      next(null, +value.headers['content-length']);

    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
      // wait till response come back
      value.on('response', function(response) {
        value.pause();
        next(null, +response.headers['content-length']);
      });
      value.resume();

    // something else
    } else {
      next('Unknown stream');
    }
  });
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  var boundary = this.getBoundary();
  var header = '';

  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (options.header != null) {
    header = options.header;
  } else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path) {
      header +=
        '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));

    // http response has not
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
    }

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
  }

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options) {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--';
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (var header in userHeaders) {
    formHeaders[header.toLowerCase()] = userHeaders[header];
  }

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType) {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(),
        'content-length': this.getLengthSync()
    };

    return formHeaders;
}

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;

    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }

    return knownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._lengthRetrievers.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  async.parallel(this._lengthRetrievers, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  this.getLength(function(err, length) {

    var request
      , options
      , defaults = {
          method : 'post',
          port   : 80,
          headers: this.getHeaders({'Content-Length': length})
      };

    // parse provided url if it's string
    // or treat it as options object
    if (typeof params == 'string') {
      params = parseUrl(params);

      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname
      }, defaults);
    }
    else // use custom params
    {
      options = populate(params, defaults);
    }

    // https if specified, fallback to http in any other case
    if (params.protocol == 'https:') {
      // override default port
      if (!params.port) options.port = 443;
      request = https.request(options);
    } else {
      request = http.request(options);
    }

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }

    return request;
  }.bind(this));
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src) {
  for (var prop in src) {
    if (!dst[prop]) dst[prop] = src[prop];
  }
  return dst;
}

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"util":3,"path":33,"http":7,"https":6,"url":1,"fs":34,"combined-stream":60,"async":61,"mime":24,"__browserify_process":9,"__browserify_buffer":19}],61:[function(require,module,exports){
(function(process){/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})(require("__browserify_process"))
},{"__browserify_process":9}],58:[function(require,module,exports){
/**
 * This cheap replica of DOM/Builder puts me to shame :-)
 *
 * Attributes are in the element.attrs object. Children is a list of
 * either other Elements or Strings for text content.
 **/
function Element(name, attrs) {
    this.name = name;
    this.parent = null;
    this.attrs = attrs || {};
    this.children = [];
}

/*** Accessors ***/

/**
 * if (element.is('message', 'jabber:client')) ...
 **/
Element.prototype.is = function(name, xmlns) {
    return this.getName() == name &&
        (!xmlns || this.getNS() == xmlns);
};

/* without prefix */
Element.prototype.getName = function() {
    if (this.name.indexOf(":") >= 0)
        return this.name.substr(this.name.indexOf(":") + 1);
    else
        return this.name;
};

/**
 * retrieves the namespace of the current element, upwards recursively
 **/
Element.prototype.getNS = function() {
    if (this.name.indexOf(":") >= 0) {
        var prefix = this.name.substr(0, this.name.indexOf(":"));
        return this.findNS(prefix);
    } else {
        return this.findNS();
    }
};

/**
 * find the namespace to the given prefix, upwards recursively
 **/
Element.prototype.findNS = function(prefix) {
    if (!prefix) {
        /* default namespace */
        if (this.attrs.xmlns)
            return this.attrs.xmlns;
        else if (this.parent)
            return this.parent.findNS();
    } else {
        /* prefixed namespace */
        var attr = 'xmlns:' + prefix;
        if (this.attrs[attr])
            return this.attrs[attr];
        else if (this.parent)
            return this.parent.findNS(prefix);
    }
};

/**
 * xmlns can be null
 **/
Element.prototype.getChild = function(name, xmlns) {
    return this.getChildren(name, xmlns)[0];
};

/**
 * xmlns can be null
 **/
Element.prototype.getChildren = function(name, xmlns) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
	      var child = this.children[i];
        if (child.getName &&
            child.getName() == name &&
            (!xmlns || child.getNS() == xmlns))
            result.push(child);
    }
    return result;
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildByAttr = function(attr, val, xmlns, recursive) {
    return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildrenByAttr = function(attr, val, xmlns, recursive) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
	      var child = this.children[i];
        if (child.attrs &&
            child.attrs[attr] == val &&
            (!xmlns || child.getNS() == xmlns))
            result.push(child);
        if (recursive && child.getChildrenByAttr)
            result.push(child.getChildrenByAttr(attr, val, xmlns, true));
    }
    if (recursive) result = [].concat.apply([], result);
    return result;
};

Element.prototype.getChildrenByFilter = function(filter, recursive) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (filter(child))
            result.push(child);
        if (recursive && child.getChildrenByFilter){
            result.push(child.getChildrenByFilter(filter, true));
        }
    }
    if (recursive){
      result = [].concat.apply([], result);
    }
    return result;
};

Element.prototype.getText = function() {
    var text = "";
    for(var i = 0; i < this.children.length; i++) {
	var child = this.children[i]
        if (typeof child == 'string' || typeof child == 'number')
            text += child;
    }
    return text;
};

Element.prototype.getChildText = function(name, xmlns) {
    var child = this.getChild(name, xmlns);
    return child ? child.getText() : null;
};

/*** Builder ***/

/** returns uppermost parent */
Element.prototype.root = function() {
    if (this.parent)
        return this.parent.root();
    else
        return this;
};
Element.prototype.tree = Element.prototype.root;

/** just parent or itself */
Element.prototype.up = function() {
    if (this.parent)
        return this.parent;
    else
        return this;
};

/** create child node and return it */
Element.prototype.c = function(name, attrs) {
    return this.cnode(new Element(name, attrs));
};

Element.prototype.cnode = function(child) {
    this.children.push(child);
    child.parent = this;
    return child;
};

/** add text node and return element */
Element.prototype.t = function(text) {
    this.children.push(text);
    return this;
};

/*** Manipulation ***/

/**
 * Either:
 *   el.remove(childEl);
 *   el.remove('author', 'urn:...');
 */
Element.prototype.remove = function(el, xmlns) {
    var filter;
    if (typeof el === 'string') {
	/* 1st parameter is tag name */
	filter = function(child) {
	    return !(child.is &&
		     child.is(el, xmlns));
	};
    } else {
	/* 1st parameter is element */
	filter = function(child) {
	    return child !== el;
	};
    }

    this.children = this.children.filter(filter);

    return this;
};

/**
 * To use in case you want the same XML data for separate uses.
 * Please refrain from this practise unless you know what you are
 * doing. Building XML with ltx is easy!
 */
Element.prototype.clone = function() {
    var clone = new Element(this.name, {});
    for(var k in this.attrs) {
	if (this.attrs.hasOwnProperty(k))
	    clone.attrs[k] = this.attrs[k];
    }
    for(var i = 0; i < this.children.length; i++) {
	var child = this.children[i];
	clone.cnode(child.clone ? child.clone() : child);
    }
    return clone;
};

Element.prototype.text = function(val) {
    if(val && this.children.length == 1){
        this.children[0] = val;
        return this;
    }
    return this.getText();
};

Element.prototype.attr = function(attr, val) {
    if (!(typeof val === 'undefined' || val === null)) {
        if(!this.attrs){
          this.attrs = {};
        }
        this.attrs[attr] = val;
        return this;
    }
    return this.attrs[attr];
};

/*** Serialization ***/

Element.prototype.toString = function() {
    var s = "";
    this.write(function(c) {
        s += c;
    });
    return s;
};

Element.prototype.write = function(writer) {
    writer("<");
    writer(this.name);
    for(var k in this.attrs) {
        var v = this.attrs[k];
	if (v || v === '' || v === 0) {
	    writer(" ");
            writer(k);
            writer("=\"");
            if (typeof v != 'string')
		v = v.toString();
            writer(escapeXml(v));
            writer("\"");
	}
    }
    if (this.children.length == 0) {
        writer("/>");
    } else {
        writer(">");
	for(var i = 0; i < this.children.length; i++) {
	    var child = this.children[i];
	    /* Skip null/undefined */
	    if (child || child === 0) {
		if (child.write)
		    child.write(writer);
		else if (typeof child === 'string')
			writer(escapeXmlText(child));
		else if (child.toString)
			writer(escapeXmlText(child.toString()));
	    }
        }
        writer("</");
        writer(this.name);
        writer(">");
    }
};

function escapeXml(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;').
        replace(/"/g, '&quot;').
        replace(/'/g, '&apos;');
}

function escapeXmlText(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;');
}

exports.Element = Element;
exports.escapeXml = escapeXml;

},{}],44:[function(require,module,exports){
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var util = require('util');



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var State = {
  New: 0,
  Params: 1
};

var ParamsState = {
  Name: 0,
  Quote: 1,
  Value: 2,
  Comma: 3
};



///--- Specific Errors

function HttpSignatureError(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function ExpiredRequestError(message) {
  HttpSignatureError.call(this, message, ExpiredRequestError);
}
util.inherits(ExpiredRequestError, HttpSignatureError);


function InvalidHeaderError(message) {
  HttpSignatureError.call(this, message, InvalidHeaderError);
}
util.inherits(InvalidHeaderError, HttpSignatureError);


function InvalidParamsError(message) {
  HttpSignatureError.call(this, message, InvalidParamsError);
}
util.inherits(InvalidParamsError, HttpSignatureError);


function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);



///--- Exported API

module.exports = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "content-md5"
   *         ],
   *         "signature": "base64"
   *       },
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert.object(request, 'request');
    assert.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert.object(options, 'options');
    assert.arrayOfString(options.headers, 'options.headers');
    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

    if (!request.headers.authorization)
      throw new MissingHeaderError('no authorization header present in ' +
                                   'the request');

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signingString: '',

      get algorithm() {
        return this.params.algorithm.toUpperCase();
      },

      get keyId() {
        return this.params.keyId;
      }

    };

    var authz = request.headers.authorization;
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          var code = c.charCodeAt(0);
          // restricted name of A-Z / a-z
          if ((code >= 0x41 && code <= 0x5a) || // A-Z
              (code >= 0x61 && code <= 0x7a)) { // a-z
            tmpName += c;
          } else if (c === '=') {
            if (tmpName.length === 0)
              throw new InvalidHeaderError('bad param format');
            substate = ParamsState.Quote;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Quote:
          if (c === '"') {
            tmpValue = '';
            substate = ParamsState.Value;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            substate = ParamsState.Comma;
          } else {
            tmpValue += c;
          }
          break;

        case ParamsState.Comma:
          if (c === ',') {
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.params.signature)
      throw new InvalidHeaderError('signature was not specified');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    if (!Algorithms[parsed.params.algorithm])
      throw new InvalidParamsError(parsed.params.algorithm +
                                   ' is not supported');

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      if (h !== 'request-line') {
        var value = request.headers[h];
        if (!value)
          throw new MissingHeaderError(h + ' was not in the request');
        parsed.signingString += h + ': ' + value;
      } else {
        parsed.signingString +=
          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
      }

      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr) < 0)
        throw new MissingHeaderError(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    return parsed;
  }

};

},{"util":3,"assert-plus":62}],45:[function(require,module,exports){
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');
var http = require('http');

var sprintf = require('util').format;



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var Authorization =
  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';



///--- Specific Errors

function MissingHeaderError(message) {
    this.name = 'MissingHeaderError';
    this.message = message;
    this.stack = (new Error()).stack;
}
MissingHeaderError.prototype = new Error();


function InvalidAlgorithmError(message) {
    this.name = 'InvalidAlgorithmError';
    this.message = message;
    this.stack = (new Error()).stack;
}
InvalidAlgorithmError.prototype = new Error();



///--- Internal Functions

function _pad(val) {
  if (parseInt(val, 10) < 10) {
    val = '0' + val;
  }
  return val;
}


function _rfc1123() {
  var date = new Date();

  var months = ['Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'];
  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  return days[date.getUTCDay()] + ', ' +
    _pad(date.getUTCDate()) + ' ' +
    months[date.getUTCMonth()] + ' ' +
    date.getUTCFullYear() + ' ' +
    _pad(date.getUTCHours()) + ':' +
    _pad(date.getUTCMinutes()) + ':' +
    _pad(date.getUTCSeconds()) +
    ' GMT';
}



///--- Exported API

module.exports = {

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
   *                   - {String} httpVersion optional; defaults to '1.1'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, 'request');
    assert.object(options, 'options');
    assert.optionalString(options.algorithm, 'options.algorithm');
    assert.string(options.keyId, 'options.keyId');
    assert.optionalArrayOfString(options.headers, 'options.headers');
    assert.optionalString(options.httpVersion, 'options.httpVersion');

    if (!request.getHeader('Date'))
      request.setHeader('Date', _rfc1123());
    if (!options.headers)
      options.headers = ['date'];
    if (!options.algorithm)
      options.algorithm = 'rsa-sha256';
    if (!options.httpVersion)
      options.httpVersion = '1.1';

    options.algorithm = options.algorithm.toLowerCase();

    if (!Algorithms[options.algorithm])
      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();

      if (h !== 'request-line') {
        var value = request.getHeader(h);
        if (!value) {
          throw new MissingHeaderError(h + ' was not in the request');
        }
        stringToSign += h + ': ' + value;
      } else {
        value =
        stringToSign +=
          request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
      }

      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
    var signature;
    if (alg[1] === 'hmac') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');
    } else {
      var signer = crypto.createSign(options.algorithm.toUpperCase());
      signer.update(stringToSign);
      signature = signer.sign(options.key, 'base64');
    }

    request.setHeader('Authorization', sprintf(Authorization,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};

},{"crypto":11,"http":7,"util":3,"assert-plus":62}],46:[function(require,module,exports){
// Copyright 2011 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');



///--- Exported API

module.exports = {

  /**
   * Simply wraps up the node crypto operations for you, and returns
   * true or false.  You are expected to pass in an object that was
   * returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} key either an RSA private key PEM or HMAC secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   */
  verifySignature: function verifySignature(parsedSignature, key) {
    assert.object(parsedSignature, 'parsedSignature');
    assert.string(key, 'key');

    var alg = parsedSignature.algorithm.match(/(HMAC|RSA|DSA)-(\w+)/);
    if (!alg || alg.length !== 3)
      throw new TypeError('parsedSignature: unsupported algorithm ' +
                          parsedSignature.algorithm);

    if (alg[1] === 'HMAC') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), key);
      hmac.update(parsedSignature.signingString);
      return (hmac.digest('base64') === parsedSignature.params.signature);
    } else {
      var verify = crypto.createVerify(alg[0]);
      verify.update(parsedSignature.signingString);
      return verify.verify(key, parsedSignature.params.signature, 'base64');
    }
  }

};

},{"crypto":11,"assert-plus":62}],47:[function(require,module,exports){
(function(Buffer){// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');

var asn1 = require('asn1');
var ctype = require('ctype');



///--- Helpers

function readNext(buffer, offset) {
  var len = ctype.ruint32(buffer, 'big', offset);
  offset += 4;

  var newOffset = offset + len;

  return {
    data: buffer.slice(offset, newOffset),
    offset: newOffset
  };
}


function writeInt(writer, buffer) {
  writer.writeByte(0x02); // ASN1.Integer
  writer.writeLength(buffer.length);

  for (var i = 0; i < buffer.length; i++)
    writer.writeByte(buffer[i]);

  return writer;
}


function rsaToPEM(key) {
  var buffer;
  var der;
  var exponent;
  var i;
  var modulus;
  var newKey = '';
  var offset = 0;
  var type;
  var tmp;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    if (type !== 'ssh-rsa')
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    exponent = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    modulus = tmp.data;
  } catch (e) {
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.113549.1.1.1');
  der.writeNull();
  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);

  // Actual key
  der.startSequence();
  writeInt(der, modulus);
  writeInt(der, exponent);
  der.endSequence();

  // bit string
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


function dsaToPEM(key) {
  var buffer;
  var offset = 0;
  var tmp;
  var der;
  var newKey = '';

  var type;
  var p;
  var q;
  var g;
  var y;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    /* JSSTYLED */
    if (!/^ssh-ds[as].*/.test(type))
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    p = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    q = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    g = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    y = tmp.data;
  } catch (e) {
    console.log(e.stack);
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.10040.4.1');

  der.startSequence();
  writeInt(der, p);
  writeInt(der, q);
  writeInt(der, g);
  der.endSequence();

  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);
  writeInt(der, y);
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (var i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


///--- API

module.exports = {

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert.string(key, 'ssh_key');

    /* JSSTYLED */
    if (/^ssh-rsa.*/.test(key))
      return rsaToPEM(key);

    /* JSSTYLED */
    if (/^ssh-ds[as].*/.test(key))
      return dsaToPEM(key);

    throw new Error('Only RSA and DSA public keys are allowed');
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert.string(key, 'ssh_key');

    var pieces = key.split(' ');
    if (!pieces || !pieces.length || pieces.length < 2)
      throw new Error('invalid ssh key');

    var data = new Buffer(pieces[1], 'base64');

    var hash = crypto.createHash('md5');
    hash.update(data);
    var digest = hash.digest('hex');

    var fp = '';
    for (var i = 0; i < digest.length; i++) {
      if (i && i % 2 === 0)
        fp += ':';

      fp += digest[i];
    }

    return fp;
  }


};

})(require("__browserify_buffer").Buffer)
},{"crypto":11,"assert-plus":62,"asn1":63,"ctype":64,"__browserify_buffer":19}],56:[function(require,module,exports){
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var ltx = require('ltx');
var Stanza = require('./stanza').Stanza;

/**
 * Recognizes <stream:stream> and collects stanzas; used for ordinary
 * TCP streams and Websockets.
 *
 * API: write(data) & end(data)
 * Events: streamStart, stanza, end, error
 */
function StreamParser(maxStanzaSize) {
    EventEmitter.call(this);

    var self = this;
    this.parser = new ltx.bestSaxParser();

    /* Count traffic for entire life-time */
    this.bytesParsed = 0;
    this.maxStanzaSize = maxStanzaSize;
    /* Will be reset upon first stanza, but enforce maxStanzaSize until it is parsed */
    this.bytesParsedOnStanzaBegin = 0;

    this.parser.addListener('startElement', function(name, attrs) {
        // TODO: refuse anything but <stream:stream>
        if (!self.element && name == 'stream:stream') {
            self.emit('streamStart', attrs);
        } else {
	    var child;
            if (!self.element) {
                /* A new stanza */
		child = new Stanza(name, attrs);
                self.element = child;
		/* For maxStanzaSize enforcement */
                self.bytesParsedOnStanzaBegin = self.bytesParsed;
            } else {
                /* A child element of a stanza */
		child = new ltx.Element(name, attrs);
                self.element = self.element.cnode(child);
            }
        }
    });

    this.parser.addListener('endElement', function(name) {
        if (!self.element && name == 'stream:stream') {
            self.end();
        } else if (self.element && name == self.element.name) {
            if (self.element.parent)
                self.element = self.element.parent;
            else {
                /* Stanza complete */
                self.emit('stanza', self.element);
                delete self.element;
		/* maxStanzaSize doesn't apply until next startElement */
                delete self.bytesParsedOnStanzaBegin;
            }
        } else {
            self.error('xml-not-well-formed', 'XML parse error');
        }
    });
    
    this.parser.addListener('text', function(str) {
        if (self.element)
            self.element.t(str);
    });
    
    this.parser.addListener('entityDecl', function() {
	/* Entity declarations are forbidden in XMPP. We must abort to
	 * avoid a billion laughs.
	 */
	self.error('xml-not-well-formed', 'No entity declarations allowed');
	self.end();
    });

    this.parser.addListener('error', function(error) {
	self.emit('error', error);
    });
}
util.inherits(StreamParser, EventEmitter);
exports.StreamParser = StreamParser;

StreamParser.prototype.write = function(data) {
    /*if (/^<stream:stream [^>]+\/>$/.test(data)) {
	data = data.replace(/\/>$/, ">");
    }*/
    if (this.parser) {
	/* If a maxStanzaSize is configured, the current stanza must consist only of this many bytes */
        if (this.bytesParsedOnStanzaBegin && this.maxStanzaSize &&
            this.bytesParsed > this.bytesParsedOnStanzaBegin + this.maxStanzaSize) {

            this.error('policy-violation', 'Maximum stanza size exceeded');
            return;
        }
        this.bytesParsed += data.length;

        this.parser.write(data);
    }
};

StreamParser.prototype.end = function(data) {
    if (data) {
        this.write(data);
    }

    delete this.parser;
    this.emit('end');
};

StreamParser.prototype.error = function(condition, message) {
    var e = new Error(message);
    e.condition = condition;
    this.emit('error', e);
};

},{"util":3,"events":4,"./stanza":38,"ltx":39}],57:[function(require,module,exports){
(function(process){var querystring = require('querystring');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

/**
 * What's available for client-side authentication (Client)
 *
 * @param {Array} mechs Server-offered SASL mechanism names
 */
function selectMechanism(offeredMechs, preferredMech, availableMech) {
    var mechClasses = [XOAuth2, XFacebookPlatform, DigestMD5,
		       Plain, Anonymous];
    var byName = {};
    var mech;
    if (Array.isArray(availableMech)) {
        mechClasses = mechClasses.concat(availableMech);
    }
    mechClasses.forEach(function(mechClass) {
	byName[mechClass.prototype.name] = mechClass;
    });
    /* Any preferred? */
    if (byName[preferredMech]) {
	mech = byName[preferredMech];
    }
    /* By priority */
    mechClasses.forEach(function(mechClass) {
	if (!mech &&
	    offeredMechs.indexOf(mechClass.prototype.name) >= 0)
	    mech = mechClass;
    });

    return mech ? new mech() : null;
}

exports.selectMechanism = selectMechanism;

/**
 * What's available for server-side authentication (C2S)
 */
function availableMechanisms(availableMech) {
    var mechanisms = [new Plain()];
    if (availableMech) {
        mechanisms = mechanisms.concat(availableMech);
    }
    return mechanisms;
}
exports.availableMechanisms = availableMechanisms;

// Mechanisms
function Mechanism() {
}
util.inherits(Mechanism, EventEmitter);
Mechanism.prototype.authAttrs = function() {
    return {};
};

function Plain() {
}
util.inherits(Plain, Mechanism);
Plain.prototype.name = "PLAIN";
Plain.prototype.auth = function() {
    return this.authzid + "\0" +
        this.authcid + "\0" +
        this.password;
};
Plain.prototype.authServer = function(auth, client) {
    var params = auth.split("\x00");
    this.username = params[1];
    client.authenticate(this.username, params[2]);
};

function XOAuth2() {
}
util.inherits(XOAuth2, Mechanism);
XOAuth2.prototype.name = "X-OAUTH2";
XOAuth2.prototype.auth = function() {
    return "\0" + this.authzid + "\0" + this.oauth2_token;
};
XOAuth2.prototype.authServer = function(auth, client) {
    var params = auth.split("\x00");
    this.username = params[1];
    client.authenticate(this.username, params[2]);
};
XOAuth2.prototype.authAttrs = function() {
    return { "auth:service": "oauth2",
	     "xmlns:auth": this.oauth2_auth
    };
};

function XFacebookPlatform() {
}
util.inherits(XFacebookPlatform, Mechanism);
XFacebookPlatform.prototype.name = "X-FACEBOOK-PLATFORM";
XFacebookPlatform.prototype.auth = function() {
    return "";
};
XFacebookPlatform.prototype.challenge = function(s) {
    var dict = querystring.parse(s);

    var response = {
        api_key: this.api_key,
        call_id: new Date().getTime(),
        method: dict.method,
        nonce: dict.nonce,
        access_token: this.access_token,
        v: "1.0"
    };

    return querystring.stringify(response);
};

function Anonymous() {
}
util.inherits(Anonymous, Mechanism);
Anonymous.prototype.name = "ANONYMOUS";
Anonymous.prototype.auth = function() {
    return this.authzid;
};

function External() {
}
util.inherits(External, Mechanism);
External.prototype.name = "EXTERNAL";
External.prototype.auth = function() {
    return(this.authzid);
};

exports.External = External;

function DigestMD5() {
    this.nonce_count = 0;
    this.cnonce = generateNonce();
}
util.inherits(DigestMD5, Mechanism);
DigestMD5.prototype.name = "DIGEST-MD5";
DigestMD5.prototype.auth = function() {
    return "";
};
DigestMD5.prototype.getNC = function() {
    return rjust(this.nonce_count.toString(), 8, '0');
};
DigestMD5.prototype.responseValue = function(s) {
    var dict = parseDict(s);
    if (dict.realm)
        this.realm = dict.realm;

    var value;
    if (dict.nonce && dict.qop) {
        this.nonce_count++;
        var a1 = md5(this.authcid + ':' +
                     this.realm + ':' +
                     this.password) + ':' +
                     dict.nonce + ':' +
                     this.cnonce;
        if (this.actAs) a1 += ":" + this.actAs

        var a2 = "AUTHENTICATE:" + this.digest_uri;
        if (dict.qop == 'auth-int' || dict.qop == 'auth-conf')
            a2 += ":00000000000000000000000000000000";

        value = md5_hex(md5_hex(a1) + ':' +
                        dict.nonce + ':' +
                        this.getNC() + ':' +
                        this.cnonce + ':' +
                        dict.qop + ':' +
                        md5_hex(a2));
    }
    return value;
};

DigestMD5.prototype.challenge = function(s) {
    var dict = parseDict(s);
    if (dict.realm)
        this.realm = dict.realm;

    var response;
    if (dict.nonce && dict.qop) {
        var responseValue = this.responseValue(s);
        response = {
            username: this.authcid,
            realm: this.realm,
            nonce: dict.nonce,
            cnonce: this.cnonce,
            nc: this.getNC(),
            qop: dict.qop,
            'digest-uri': this.digest_uri,
            response: responseValue,
            charset: 'utf-8'
        };
        if (this.actAs) response['authzid'] = this.actAs
    } else if (dict.rspauth) {
        return "";
    }
    return encodeDict(response);
};
DigestMD5.prototype.serverChallenge = function() {
    var dict = {};
    dict.realm = "";
    this.nonce = dict.nonce = generateNonce();
    dict.qop = "auth";
    this.charset = dict.charset = "utf-8";
    dict.algorithm = "md5-sess";
    return encodeDict(dict);
};

// Used on the server to check for auth!
DigestMD5.prototype.response = function(s) {
    var dict = parseDict(s);
    this.authcid = dict.username;
    if(dict.nonce != this.nonce) {
        return false;
    }
    if(!dict.cnonce) {
        return false;
    }
    this.cnonce = dict.cnonce;
    if(this.charset != dict.charset) {
        return false;
    }
    this.response = dict.response;
    return true;
};

/**
 * Parse SASL serialization
 */
function parseDict(s) {
    var result = {};
    while (s) {
        var m;
        if((m = /^(.+?)=(.*?[^\\]),(.*)/.exec(s))) {
            result[m[1]] = m[2].replace(/\"/g, '');
            s = m[3];
        } else if ((m = /^(.+?)=(.+?),(.*)/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else if ((m = /^(.+?)="(.*?[^\\])"$/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else if ((m = /^(.+?)=(.+?)$/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else {
            s = null;
        }
    }
    return result;
}

/**
 * SASL serialization
 */
function encodeDict(dict) {
    var s = "";
    for(k in dict) {
        var v = dict[k];
        if (v)
            s += ',' + k + '="' + v + '"';
    }
    return s.substr(1);  // without first ','
}

/**
 * Right-justify a string,
 * eg. pad with 0s
 */
function rjust(s, targetLen, padding) {
    while(s.length < targetLen)
        s = padding + s;
    return s;
}

/**
 * Hash a string
 */
var md5, md5_hex;
if (process.title !== 'browser') {
    var crypto = require('crypto');
    md5 = function(s, encoding) {
	var hash = crypto.createHash('md5');
	hash.update(s);
	return hash.digest(encoding || 'binary');
    };
    md5_hex = function(s) {
	return md5(s, 'hex');
    };
} else {
    var md5lib = require('blueimp-md5').md5;
    console.log("md5lib",md5lib);
    md5 = function(s) {
	console.log("md5", s, md5lib(s, null, true));
	return md5lib(s, null, true);
    };
    md5_hex = function(s) {
	console.log("md5_hex", s, md5lib(s));
	return md5lib(s);
    };
}

/**
 * Generate a string of 8 digits
 * (number used once)
 */
function generateNonce() {
    var result = "";
    for(var i = 0; i < 8; i++)
        result += String.fromCharCode(48 +
                                      Math.ceil(Math.random() * 10));
    return result;
}

})(require("__browserify_process"))
},{"querystring":2,"util":3,"events":4,"crypto":11,"blueimp-md5":65,"__browserify_process":9}],66:[function(require,module,exports){
// Load modules

var Crypto = require('crypto');
var Url = require('url');
var Utils = require('./utils');


// Declare internals

var internals = {};


// MAC normalization format version

exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats


// Supported HMAC algorithms

exports.algorithms = ['sha1', 'sha256'];


// Calculate the request MAC

/*
    type: 'header',                                 // 'header', 'bewit', 'response'
    credentials: {
        key: 'aoijedoaijsdlaksjdl',
        algorithm: 'sha256'                         // 'sha1', 'sha256'
    },
    options: {
        method: 'GET',
        resource: '/resource?a=1&b=2',
        host: 'example.com',
        port: 8080,
        ts: 1357718381034,
        nonce: 'd3d345f',
        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
        ext: 'app-specific-data',
        app: 'hf48hd83qwkj',                        // Application id (Oz)
        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
    }
*/

exports.calculateMac = function (type, credentials, options) {

    var normalized = exports.generateNormalizedString(type, options);

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest('base64');
    return digest;
};


exports.generateNormalizedString = function (type, options) {

    var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                     options.ts + '\n' +
                     options.nonce + '\n' +
                     options.method.toUpperCase() + '\n' +
                     options.resource + '\n' +
                     options.host.toLowerCase() + '\n' +
                     options.port + '\n' +
                     (options.hash || '') + '\n';

    if (options.ext) {
        normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }

    normalized += '\n';

    if (options.app) {
        normalized += options.app + '\n' +
                      (options.dlg || '') + '\n';
    }

    return normalized;
};


exports.calculatePayloadHash = function (payload, algorithm, contentType) {

    var hash = exports.initializePayloadHash(algorithm, contentType);
    hash.update(payload || '');
    return exports.finalizePayloadHash(hash);
};


exports.initializePayloadHash = function (algorithm, contentType) {

    var hash = Crypto.createHash(algorithm);
    hash.update('hawk.' + exports.headerVersion + '.payload\n');
    hash.update(Utils.parseContentType(contentType) + '\n');
    return hash;
};


exports.finalizePayloadHash = function (hash) {

    hash.update('\n');
    return hash.digest('base64');
};


exports.calculateTsMac = function (ts, credentials) {

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
    hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
    return hmac.digest('base64');
};


},{"crypto":11,"url":1,"./utils":67}],62:[function(require,module,exports){
(function(process,Buffer){// Copyright (c) 2012, Mark Cavage. All rights reserved.

var assert = require('assert');
var Stream = require('stream').Stream;
var util = require('util');



///--- Globals

var NDEBUG = process.env.NODE_NDEBUG || false;



///--- Messages

var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
var TYPE_REQUIRED = '%s (%s) is required';



///--- Internal

function capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
}

function uncapitalize(str) {
        return (str.charAt(0).toLowerCase() + str.slice(1));
}

function _() {
        return (util.format.apply(util, arguments));
}


function _assert(arg, type, name, stackFunc) {
        if (!NDEBUG) {
                name = name || type;
                stackFunc = stackFunc || _assert.caller;
                var t = typeof (arg);

                if (t !== type) {
                        throw new assert.AssertionError({
                                message: _(TYPE_REQUIRED, name, type),
                                actual: t,
                                expected: type,
                                operator: '===',
                                stackStartFunction: stackFunc
                        });
                }
        }
}



///--- API

function array(arr, type, name) {
        if (!NDEBUG) {
                name = name || type;

                if (!Array.isArray(arr)) {
                        throw new assert.AssertionError({
                                message: _(ARRAY_TYPE_REQUIRED, name, type),
                                actual: typeof (arr),
                                expected: 'array',
                                operator: 'Array.isArray',
                                stackStartFunction: array.caller
                        });
                }

                for (var i = 0; i < arr.length; i++) {
                        _assert(arr[i], type, name, array);
                }
        }
}


function bool(arg, name) {
        _assert(arg, 'boolean', name, bool);
}


function buffer(arg, name) {
        if (!Buffer.isBuffer(arg)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'buffer',
                        operator: 'Buffer.isBuffer',
                        stackStartFunction: buffer
                });
        }
}


function func(arg, name) {
        _assert(arg, 'function', name);
}


function number(arg, name) {
        _assert(arg, 'number', name);
}


function object(arg, name) {
        _assert(arg, 'object', name);
}


function stream(arg, name) {
        if (!(arg instanceof Stream)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'Stream',
                        operator: 'instanceof',
                        stackStartFunction: buffer
                });
        }
}


function string(arg, name) {
        _assert(arg, 'string', name);
}



///--- Exports

module.exports = {
        bool: bool,
        buffer: buffer,
        func: func,
        number: number,
        object: object,
        stream: stream,
        string: string
};


Object.keys(module.exports).forEach(function (k) {
        if (k === 'buffer')
                return;

        var name = 'arrayOf' + capitalize(k);

        if (k === 'bool')
                k = 'boolean';
        if (k === 'func')
                k = 'function';
        module.exports[name] = function (arg, name) {
                array(arg, k, name);
        };
});

Object.keys(module.exports).forEach(function (k) {
        var _name = 'optional' + capitalize(k);
        var s = uncapitalize(k.replace('arrayOf', ''));
        if (s === 'bool')
                s = 'boolean';
        if (s === 'func')
                s = 'function';

        if (k.indexOf('arrayOf') !== -1) {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          array(arg, s, name);
                  }
          };
        } else {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          _assert(arg, s, name);
                  }
          };
        }
});


// Reexport built-in assertions
Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
                module.exports[k] = assert[k];
                return;
        }

        module.exports[k] = function () {
                if (!NDEBUG) {
                        assert[k].apply(assert[k], arguments);
                }
        };
});

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"assert":18,"stream":5,"util":3,"__browserify_process":9,"__browserify_buffer":19}],49:[function(require,module,exports){
// Export sub-modules

exports.error = exports.Error = require('boom');
exports.sntp = require('sntp');
exports.server = require('./server');
exports.client = require('./client');
exports.crypto = require('./crypto');
exports.utils = require('./utils');

exports.uri = {
    authenticate: exports.server.authenticateBewit,
    getBewit: exports.client.getBewit
};



},{"./server":68,"./client":69,"./crypto":66,"./utils":67,"boom":70,"sntp":71}],65:[function(require,module,exports){
(function(){/*
 * JavaScript MD5 1.0.1
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 * 
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jslint bitwise: true */
/*global unescape, define */

(function ($) {
    'use strict';

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    function md5(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }

    if (typeof define === 'function' && define.amd) {
        define(function () {
            return md5;
        });
    } else {
        $.md5 = md5;
    }
}(this));

})()
},{}],59:[function(require,module,exports){
var events = require('events');
var util = require('util');

exports.availableSaxParsers = [];
exports.bestSaxParser = null;
['./sax_expat.js', './sax_ltx.js', /*'./sax_easysax.js', './sax_node-xml.js',*/ './sax_saxjs.js'].forEach(function(modName) {
    var mod;
    try {
	mod = require(modName);
    } catch (e) {
	/* Silently missing libraries drop; for debug:
	console.error(e.stack || e);
	 */
    }
    if (mod) {
	exports.availableSaxParsers.push(mod);
	if (!exports.bestSaxParser)
	    exports.bestSaxParser = mod;
    }
});
var element = require('./element');

exports.Parser = function(saxParser) {
    events.EventEmitter.call(this);
    var that = this;

    var parserMod = saxParser || exports.bestSaxParser;
    if (!parserMod)
	throw new Error("No SAX parser available");
    this.parser = new parserMod();

    var el;
    this.parser.addListener('startElement', function(name, attrs) {
        var child = new element.Element(name, attrs);
        if (!el) {
            el = child;
        } else {
            el = el.cnode(child);
        }
    });
    this.parser.addListener('endElement', function(name) {
        if (!el) {
            /* Err */
        } else if (el && name == el.name) {
            if (el.parent)
                el = el.parent;
            else if (!that.tree) {
                that.tree = el;
                el = undefined;
            }
        }
    });
    this.parser.addListener('text', function(str) {
        if (el)
            el.t(str);
    });
    this.parser.addListener('error', function(e) {
	that.error = e;
	that.emit('error', e);
    });
};
util.inherits(exports.Parser, events.EventEmitter);

exports.Parser.prototype.write = function(data) {
    this.parser.write(data);
};

exports.Parser.prototype.end = function(data) {
    this.parser.end(data);

    if (!this.error) {
	if (this.tree)
	    this.emit('tree', this.tree);
	else
	    this.emit('error', new Error('Incomplete document'));
    }
};

exports.parse = function(data, saxParser) {
    var p = new exports.Parser(saxParser);
    var result = null, error = null;

    p.on('tree', function(tree) {
        result = tree;
    });
    p.on('error', function(e) {
        error = e;
    });

    p.write(data);
    p.end();

    if (error)
        throw error;
    else
        return result;
};

},{"events":4,"util":3,"./element":58}],64:[function(require,module,exports){
(function(Buffer){/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we're writing out data, otherwise it's ignored.
 *
 */

var mod_ctf = require('./ctf.js');
var mod_ctio = require('./ctio.js');
var mod_assert = require('assert');

/*
 * This is the set of basic types that we support.
 *
 *	read		The function to call to read in a value from a buffer
 *
 *	write		The function to call to write a value to a buffer
 *
 */
var deftypes = {
    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
    'float': { read: ctReadFloat, write: ctWriteFloat },
    'double': { read: ctReadDouble, write: ctWriteDouble },
    'char': { read: ctReadChar, write: ctWriteChar },
    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
};

/*
 * The following are wrappers around the CType IO low level API. They encode
 * knowledge about the size and return something in the expected format.
 */
function ctReadUint8(endian, buffer, offset)
{
	var val = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadUint16(endian, buffer, offset)
{
	var val = mod_ctio.ruint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadUint32(endian, buffer, offset)
{
	var val = mod_ctio.ruint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadUint64(endian, buffer, offset)
{
	var val = mod_ctio.ruint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadSint8(endian, buffer, offset)
{
	var val = mod_ctio.rsint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadSint16(endian, buffer, offset)
{
	var val = mod_ctio.rsint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadSint32(endian, buffer, offset)
{
	var val = mod_ctio.rsint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadSint64(endian, buffer, offset)
{
	var val = mod_ctio.rsint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadFloat(endian, buffer, offset)
{
	var val = mod_ctio.rfloat(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadDouble(endian, buffer, offset)
{
	var val = mod_ctio.rdouble(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

/*
 * Reads a single character into a node buffer
 */
function ctReadChar(endian, buffer, offset)
{
	var res = new Buffer(1);
	res[0] = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: res, size: 1 });
}

function ctReadCharArray(length, endian, buffer, offset)
{
	var ii;
	var res = new Buffer(length);

	for (ii = 0; ii < length; ii++)
		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

	return ({ value: res, size: length });
}

function ctWriteUint8(value, endian, buffer, offset)
{
	mod_ctio.wuint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteUint16(value, endian, buffer, offset)
{
	mod_ctio.wuint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteUint32(value, endian, buffer, offset)
{
	mod_ctio.wuint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteUint64(value, endian, buffer, offset)
{
	mod_ctio.wuint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteSint8(value, endian, buffer, offset)
{
	mod_ctio.wsint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteSint16(value, endian, buffer, offset)
{
	mod_ctio.wsint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteSint32(value, endian, buffer, offset)
{
	mod_ctio.wsint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteSint64(value, endian, buffer, offset)
{
	mod_ctio.wsint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteFloat(value, endian, buffer, offset)
{
	mod_ctio.wfloat(value, endian, buffer, offset);
	return (4);
}

function ctWriteDouble(value, endian, buffer, offset)
{
	mod_ctio.wdouble(value, endian, buffer, offset);
	return (8);
}

/*
 * Writes a single character into a node buffer
 */
function ctWriteChar(value, endian, buffer, offset)
{
	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	mod_ctio.ruint8(value[0], endian, buffer, offset);
	return (1);
}

/*
 * We're going to write 0s into the buffer if the string is shorter than the
 * length of the array.
 */
function ctWriteCharArray(value, length, endian, buffer, offset)
{
	var ii;

	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	if (value.length > length)
		throw (new Error('value length greater than array length'));

	for (ii = 0; ii < value.length && ii < length; ii++)
		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

	for (; ii < length; ii++)
		mod_ctio.wuint8(0, endian, offset + ii);


	return (length);
}

/*
 * Each parser has their own set of types. We want to make sure that they each
 * get their own copy as they may need to modify it.
 */
function ctGetBasicTypes()
{
	var ret = {};
	var key;
	for (key in deftypes)
		ret[key] = deftypes[key];

	return (ret);
}

/*
 * Given a string in the form of type[length] we want to split this into an
 * object that extracts that information. We want to note that we could possibly
 * have nested arrays so this should only check the furthest one. It may also be
 * the case that we have no [] pieces, in which case we just return the current
 * type.
 */
function ctParseType(str)
{
	var begInd, endInd;
	var type, len;
	if (typeof (str) != 'string')
		throw (new Error('type must be a Javascript string'));

	endInd = str.lastIndexOf(']');
	if (endInd == -1) {
		if (str.lastIndexOf('[') != -1)
			throw (new Error('found invalid type with \'[\' but ' +
			    'no corresponding \']\''));

		return ({ type: str });
	}

	begInd = str.lastIndexOf('[');
	if (begInd == -1)
		throw (new Error('found invalid type with \']\' but ' +
		    'no corresponding \'[\''));

	if (begInd >= endInd)
		throw (new Error('malformed type, \']\' appears before \'[\''));

	type = str.substring(0, begInd);
	len = str.substring(begInd + 1, endInd);

	return ({ type: type, len: len });
}

/*
 * Given a request validate that all of the fields for it are valid and make
 * sense. This includes verifying the following notions:
 *  - Each type requested is present in types
 *  - Only allow a name for a field to be specified once
 *  - If an array is specified, validate that the requested field exists and
 *    comes before it.
 *  - If fields is defined, check that each entry has the occurrence of field
 */
function ctCheckReq(def, types, fields)
{
	var ii, jj;
	var req, keys, key;
	var found = {};

	if (!(def instanceof Array))
		throw (new Error('definition is not an array'));

	if (def.length === 0)
		throw (new Error('definition must have at least one element'));

	for (ii = 0; ii < def.length; ii++) {
		req = def[ii];
		if (!(req instanceof Object))
			throw (new Error('definition must be an array of' +
			    'objects'));

		keys = Object.keys(req);
		if (keys.length != 1)
			throw (new Error('definition entry must only have ' +
			    'one key'));

		if (keys[0] in found)
			throw (new Error('Specified name already ' +
			    'specified: ' + keys[0]));

		if (!('type' in req[keys[0]]))
			throw (new Error('missing required type definition'));

		key = ctParseType(req[keys[0]]['type']);

		/*
		 * We may have nested arrays, we need to check the validity of
		 * the types until the len field is undefined in key. However,
		 * each time len is defined we need to verify it is either an
		 * integer or corresponds to an already seen key.
		 */
		while (key['len'] !== undefined) {
			if (isNaN(parseInt(key['len'], 10))) {
				if (!(key['len'] in found))
					throw (new Error('Given an array ' +
					    'length without a matching type'));

			}

			key = ctParseType(key['type']);
		}

		/* Now we can validate if the type is valid */
		if (!(key['type'] in types))
			throw (new Error('type not found or typdefed: ' +
			    key['type']));

		/* Check for any required fields */
		if (fields !== undefined) {
			for (jj = 0; jj < fields.length; jj++) {
				if (!(fields[jj] in req[keys[0]]))
					throw (new Error('Missing required ' +
					    'field: ' + fields[jj]));
			}
		}

		found[keys[0]] = true;
	}
}


/*
 * Create a new instance of the parser. Each parser has its own store of
 * typedefs and endianness. Conf is an object with the following required
 * values:
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 * And the following optional values:
 *
 * 	char-type	Valid options here are uint8 and int8. If uint8 is
 * 			specified this changes the default behavior of a single
 * 			char from being a buffer of a single character to being
 * 			a uint8_t. If int8, it becomes an int8_t instead.
 */
function CTypeParser(conf)
{
	if (!conf) throw (new Error('missing required argument'));

	if (!('endian' in conf))
		throw (new Error('missing required endian value'));

	if (conf['endian'] != 'big' && conf['endian'] != 'little')
		throw (new Error('Invalid endian type'));

	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
	    conf['char-type'] != 'int8'))
		throw (new Error('invalid option for char-type: ' +
		    conf['char-type']));

	this.endian = conf['endian'];
	this.types = ctGetBasicTypes();

	/*
	 * There may be a more graceful way to do this, but this will have to
	 * serve.
	 */
	if ('char-type' in conf && conf['char-type'] == 'uint8')
		this.types['char'] = this.types['uint8_t'];

	if ('char-type' in conf && conf['char-type'] == 'int8')
		this.types['char'] = this.types['int8_t'];
}

/*
 * Sets the current endian value for the Parser. If the value is not valid,
 * throws an Error.
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 */
CTypeParser.prototype.setEndian = function (endian)
{
	if (endian != 'big' && endian != 'little')
		throw (new Error('invalid endian type, must be big or ' +
		    'little'));

	this.endian = endian;
};

/*
 * Returns the current value of the endian value for the parser.
 */
CTypeParser.prototype.getEndian = function ()
{
	return (this.endian);
};

/*
 * A user has requested to add a type, let us honor their request. Yet, if their
 * request doth spurn us, send them unto the Hells which Dante describes.
 *
 * 	name		The string for the type definition we're adding
 *
 *	value		Either a string that is a type/array name or an object
 *			that describes a struct.
 */
CTypeParser.prototype.typedef = function (name, value)
{
	var type;

	if (name === undefined)
		throw (new (Error('missing required typedef argument: name')));

	if (value === undefined)
		throw (new (Error('missing required typedef argument: value')));

	if (typeof (name) != 'string')
		throw (new (Error('the name of a type must be a string')));

	type = ctParseType(name);

	if (type['len'] !== undefined)
		throw (new Error('Cannot have an array in the typedef name'));

	if (name in this.types)
		throw (new Error('typedef name already present: ' + name));

	if (typeof (value) != 'string' && !(value instanceof Array))
		throw (new Error('typedef value must either be a string or ' +
		    'struct'));

	if (typeof (value) == 'string') {
		type = ctParseType(value);
		if (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10)))
				throw (new (Error('typedef value must use ' +
				    'fixed size array when outside of a ' +
				    'struct')));
		}

		this.types[name] = value;
	} else {
		/* We have a struct, validate it */
		ctCheckReq(value, this.types);
		this.types[name] = value;
	}
};

/*
 * Include all of the typedefs, but none of the built in types. This should be
 * treated as read-only.
 */
CTypeParser.prototype.lstypes = function ()
{
	var key;
	var ret = {};

	for (key in this.types) {
		if (key in deftypes)
			continue;
		ret[key] = this.types[key];
	}

	return (ret);
};

/*
 * Given a type string that may have array types that aren't numbers, try and
 * fill them in from the values object. The object should be of the format where
 * indexing into it should return a number for that type.
 *
 *	str		The type string
 *
 *	values		An object that can be used to fulfill type information
 */
function ctResolveArray(str, values)
{
	var ret = '';
	var type = ctParseType(str);

	while (type['len'] !== undefined) {
		if (isNaN(parseInt(type['len'], 10))) {
			if (typeof (values[type['len']]) != 'number')
				throw (new Error('cannot sawp in non-number ' +
				    'for array value'));
			ret = '[' + values[type['len']] + ']' + ret;
		} else {
			ret = '[' + type['len'] + ']' + ret;
		}
		type = ctParseType(type['type']);
	}

	ret = type['type'] + ret;

	return (ret);
}

/*
 * [private] Either the typedef resolves to another type string or to a struct.
 * If it resolves to a struct, we just pass it off to read struct. If not, we
 * can just pass it off to read entry.
 */
CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
    offset, value)
{
	var pt;

	mod_assert.ok(type in this.types);
	if (typeof (this.types[type]) == 'string') {
		pt = ctParseType(this.types[type]);
		if (dispatch == 'read')
			return (this.readEntry(pt, buffer, offset));
		else if (dispatch == 'write')
			return (this.writeEntry(value, pt, buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	} else {
		if (dispatch == 'read')
			return (this.readStruct(this.types[type], buffer,
			    offset));
		else if (dispatch == 'write')
			return (this.writeStruct(value, this.types[type],
			    buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	}

};

/*
 * [private] Try and read in the specific entry.
 */
CTypeParser.prototype.readEntry = function (type, buffer, offset)
{
	var parse, len;

	/*
	 * Because we want to special case char[]s this is unfortunately
	 * a bit uglier than it really should be. We want to special
	 * case char[]s so that we return a node buffer, thus they are a
	 * first class type where as all other arrays just call into a
	 * generic array routine which calls their data-specific routine
	 * the specified number of times.
	 *
	 * The valid dispatch options we have are:
	 *  - Array and char => char[] handler
	 *  - Generic array handler
	 *  - Generic typedef handler
	 *  - Basic type handler
	 */
	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			parse = this.types['char[]']['read'](len,
			    this.endian, buffer, offset);
		else
			parse = this.readArray(type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			parse = this.types[type['type']]['read'](this.endian,
			    buffer, offset);
		else
			parse = this.resolveTypedef(type['type'], 'read',
			    buffer, offset);
	}

	return (parse);
};

/*
 * [private] Read an array of data
 */
CTypeParser.prototype.readArray = function (type, length, buffer, offset)
{
	var ii, ent, pt;
	var baseOffset = offset;
	var ret = new Array(length);
	pt = ctParseType(type);

	for (ii = 0; ii < length; ii++) {
		ent = this.readEntry(pt, buffer, offset);
		offset += ent['size'];
		ret[ii] = ent['value'];
	}

	return ({ value: ret, size: offset - baseOffset });
};

/*
 * [private] Read a single struct in.
 */
CTypeParser.prototype.readStruct = function (def, buffer, offset)
{
	var parse, ii, type, entry, key;
	var baseOffset = offset;
	var ret = {};

	/* Walk it and handle doing what's necessary */
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		/* Resolve all array values */
		type = ctParseType(ctResolveArray(entry['type'], ret));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		parse = this.readEntry(type, buffer, offset);

		offset += parse['size'];
		ret[key] = parse['value'];
	}

	return ({ value: ret, size: (offset-baseOffset)});
};

/*
 * This is what we were born to do. We read the data from a buffer and return it
 * in an object whose keys match the values from the object.
 *
 *	def		The array definition of the data to read in
 *
 *	buffer		The buffer to read data from
 *
 *	offset		The offset to start writing to
 *
 * Returns an object where each key corresponds to an entry in def and the value
 * is the read value.
 */
CTypeParser.prototype.readData = function (def, buffer, offset)
{
	/* Sanity check for arguments */
	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	/* Sanity check the object definition */
	ctCheckReq(def, this.types);

	return (this.readStruct(def, buffer, offset)['value']);
};

/*
 * [private] Write out an array of data
 */
CTypeParser.prototype.writeArray = function (value, type, length, buffer,
    offset)
{
	var ii, pt;
	var baseOffset = offset;
	if (!(value instanceof Array))
		throw (new Error('asked to write an array, but value is not ' +
		    'an array'));

	if (value.length != length)
		throw (new Error('asked to write array of length ' + length +
		    ' but that does not match value length: ' + value.length));

	pt = ctParseType(type);
	for (ii = 0; ii < length; ii++)
		offset += this.writeEntry(value[ii], pt, buffer, offset);

	return (offset - baseOffset);
};

/*
 * [private] Write the specific entry
 */
CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
{
	var len, ret;

	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			ret = this.types['char[]']['write'](value, len,
			    this.endian, buffer, offset);
		else
			ret = this.writeArray(value, type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			ret = this.types[type['type']]['write'](value,
			    this.endian, buffer, offset);
		else
			ret = this.resolveTypedef(type['type'], 'write',
			    buffer, offset, value);
	}

	return (ret);
};

/*
 * [private] Write a single struct out.
 */
CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
{
	var ii, entry, type, key;
	var baseOffset = offset;
	var vals = {};

	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		type = ctParseType(ctResolveArray(entry['type'], vals));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		offset += this.writeEntry(value[ii], type, buffer, offset);
		/* Now that we've written it out, we can use it for arrays */
		vals[key] = value[ii];
	}

	return (offset);
};

/*
 * Unfortunately, we're stuck with the sins of an initial poor design. Because
 * of that, we are going to have to support the old way of writing data via
 * writeData. There we insert the values that you want to write into the
 * definition. A little baroque. Internally, we use the new model. So we need to
 * just get those values out of there. But to maintain the principle of least
 * surprise, we're not going to modify the input data.
 */
function getValues(def)
{
	var ii, out, key;
	out = [];
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		mod_assert.ok('value' in def[ii][key]);
		out.push(def[ii][key]['value']);
	}

	return (out);
}

/*
 * This is the second half of what we were born to do, write out the data
 * itself. Historically this function required you to put your values in the
 * definition section. This was not the smartest thing to do and a bit of an
 * oversight to be honest. As such, this function now takes a values argument.
 * If values is non-null and non-undefined, it will be used to determine the
 * values. This means that the old method is still supported, but is no longer
 * acceptable.
 *
 *	def		The array definition of the data to write out with
 *			values
 *
 *	buffer		The buffer to write to
 *
 *	offset		The offset in the buffer to write to
 *
 *	values		An array of values to write.
 */
CTypeParser.prototype.writeData = function (def, buffer, offset, values)
{
	var hv;

	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	hv = (values != null && values != undefined);
	if (hv) {
		if (!Array.isArray(values))
			throw (new Error('missing values for writing'));
		ctCheckReq(def, this.types);
	} else {
		ctCheckReq(def, this.types, [ 'value' ]);
	}

	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
};

/*
 * Functions to go to and from 64 bit numbers in a way that is compatible with
 * Javascript limitations. There are two sets. One where the user is okay with
 * an approximation and one where they are definitely not okay with an
 * approximation.
 */

/*
 * Attempts to convert an array of two integers returned from rsint64 / ruint64
 * into an absolute 64 bit number. If however the value would exceed 2^52 this
 * will instead throw an error. The mantissa in a double is a 52 bit number and
 * rather than potentially give you a value that is an approximation this will
 * error. If you would rather an approximation, please see toApprox64.
 *
 *	val		An array of two 32-bit integers
 */
function toAbs64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	/* We have 20 bits worth of precision in this range */
	if (val[0] >= 0x100000)
		throw (new Error('value would become approximated'));

	return (val[0] * Math.pow(2, 32) + val[1]);
}

/*
 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
 * to a value as close as it can. Note that Javascript stores all numbers as a
 * double and the mantissa only has 52 bits. Thus this version may approximate
 * the value.
 *
 *	val		An array of two 32-bit integers
 */
function toApprox64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	return (Math.pow(2, 32) * val[0] + val[1]);
}

function parseCTF(json, conf)
{
	var ctype = new CTypeParser(conf);
	mod_ctf.ctfParseJson(json, ctype);

	return (ctype);
}

/*
 * Export the few things we actually want to. Currently this is just the CType
 * Parser and ctio.
 */
exports.Parser = CTypeParser;
exports.toAbs64 = toAbs64;
exports.toApprox64 = toApprox64;

exports.parseCTF = parseCTF;

exports.ruint8 = mod_ctio.ruint8;
exports.ruint16 = mod_ctio.ruint16;
exports.ruint32 = mod_ctio.ruint32;
exports.ruint64 = mod_ctio.ruint64;
exports.wuint8 = mod_ctio.wuint8;
exports.wuint16 = mod_ctio.wuint16;
exports.wuint32 = mod_ctio.wuint32;
exports.wuint64 = mod_ctio.wuint64;

exports.rsint8 = mod_ctio.rsint8;
exports.rsint16 = mod_ctio.rsint16;
exports.rsint32 = mod_ctio.rsint32;
exports.rsint64 = mod_ctio.rsint64;
exports.wsint8 = mod_ctio.wsint8;
exports.wsint16 = mod_ctio.wsint16;
exports.wsint32 = mod_ctio.wsint32;
exports.wsint64 = mod_ctio.wsint64;

exports.rfloat = mod_ctio.rfloat;
exports.rdouble = mod_ctio.rdouble;
exports.wfloat = mod_ctio.wfloat;
exports.wdouble = mod_ctio.wdouble;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./ctf.js":72,"./ctio.js":73,"__browserify_buffer":19}],63:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = require('./ber/index');



///--- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};

},{"./ber/index":74}],72:[function(require,module,exports){
/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */
var mod_assert = require('assert');
var ASSERT = mod_assert.ok;

var ctf_versions = [ '1.0' ];
var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
    'uint32_t', 'float', 'double' ];

function ctfParseInteger(entry, ctype)
{
	var name, sign, len, type;

	name = entry['name'];
	if (!('signed' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'signed value'));


	if (!('length' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'length value'));

	sign = entry['integer']['signed'];
	len = entry['integer']['length'];
	type = null;

	if (sign && len == 1)
		type = 'int8_t';
	else if (len == 1)
		type = 'uint8_t';
	else if (sign && len == 2)
		type = 'int16_t';
	else if (len == 2)
		type = 'uint16_t';
	else if (sign && len == 4)
		type = 'int32_t';
	else if (len == 4)
		type = 'uint32_t';
	else if (sign && len == 8)
		type = 'int64_t';
	else if (len == 8)
		type = 'uint64_t';

	if (type === null)
		throw (new Error('Malformed CTF JSON: integer has ' +
		    'unsupported length and sign - ' + len + '/' + sign));

	/*
	 * This means that this is the same as one of our built in types. If
	 * that's the case defining it would be an error. So instead of trying
	 * to typedef it, we'll return here.
	 */
	if (name == type)
		return;

	if (name == 'char') {
		ASSERT(type == 'int8_t');
		return;
	}

	ctype.typedef(name, type);
}

function ctfParseFloat(entry, ctype)
{
	var name, len;

	name = entry['name'];
	if (!('length' in entry['float']))
		throw (new Error('Malformed CTF JSON: float missing ' +
		    'length value'));

	len = entry['float']['length'];
	if (len != 4 && len != 8)
		throw (new Error('Malformed CTF JSON: float has invalid ' +
		    'length value'));

	if (len == 4) {
		if (name == 'float')
			return;
		ctype.typedef(name, 'float');
	} else if (len == 8) {
		if (name == 'double')
			return;
		ctype.typedef(name, 'double');
	}
}

function ctfParseTypedef(entry, ctype)
{
	var name, type, ii;

	name = entry['name'];
	if (typeof (entry['typedef']) != 'string')
		throw (new Error('Malformed CTF JSON: typedef value in not ' +
		    'a string'));

	type = entry['typedef'];

	/*
	 * We need to ensure that we're not looking at type that's one of our
	 * built in types. Traditionally in C a uint32_t would be a typedef to
	 * some kind of integer. However, those size types are built ins.
	 */
	for (ii = 0; ii < ctf_deftypes.length; ii++) {
		if (name == ctf_deftypes[ii])
			return;
	}

	ctype.typedef(name, type);
}

function ctfParseStruct(entry, ctype)
{
	var name, type, ii, val, index, member, push;

	member = [];
	if (!Array.isArray(entry['struct']))
		throw (new Error('Malformed CTF JSON: struct value is not ' +
		    'an array'));

	for (ii = 0; ii < entry['struct'].length; ii++) {
		val = entry['struct'][ii];
		if (!('name' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing name'));

		if (!('type' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing type'));

		if (typeof (val['name']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'name isn\'t a string'));

		if (typeof (val['type']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'type isn\'t a string'));

		/*
		 * CTF version 2 specifies array names as <type> [<num>] where
		 * as node-ctype does this as <type>[<num>].
		 */
		name = val['name'];
		type = val['type'];
		index = type.indexOf(' [');
		if (index != -1) {
			type = type.substring(0, index) +
			    type.substring(index + 1, type.length);
		}
		push = {};
		push[name] = { 'type': type };
		member.push(push);
	}

	name = entry['name'];
	ctype.typedef(name, member);
}

function ctfParseEntry(entry, ctype)
{
	var ii, found;

	if (!('name' in entry))
		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
		    'section'));

	for (ii = 0; ii < ctf_entries.length; ii++) {
		if (ctf_entries[ii] in entry)
			found++;
	}

	if (found === 0)
		throw (new Error('Malformed CTF JSON: found no entries'));

	if (found >= 2)
		throw (new Error('Malformed CTF JSON: found more than one ' +
		    'entry'));

	if ('integer' in entry) {
		ctfParseInteger(entry, ctype);
		return;
	}

	if ('float' in entry) {
		ctfParseFloat(entry, ctype);
		return;
	}

	if ('typedef' in entry) {
		ctfParseTypedef(entry, ctype);
		return;
	}

	if ('struct' in entry) {
		ctfParseStruct(entry, ctype);
		return;
	}

	ASSERT(false, 'shouldn\'t reach here');
}

function ctfParseJson(json, ctype)
{
	var version, ii;

	ASSERT(json);
	ASSERT(ctype);
	if (!('metadata' in json))
		throw (new Error('Invalid CTF JSON: missing metadata section'));

	if (!('ctf2json_version' in json['metadata']))
		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

	version = json['metadata']['ctf2json_version'];
	for (ii = 0; ii < ctf_versions.length; ii++) {
		if (ctf_versions[ii] == version)
			break;
	}

	if (ii == ctf_versions.length)
		throw (new Error('Unsuported ctf2json_version: ' + version));

	if (!('data' in json))
		throw (new Error('Invalid CTF JSON: missing data section'));

	if (!Array.isArray(json['data']))
		throw (new Error('Malformed CTF JSON: data section is not ' +
		    'an array'));

	for (ii = 0; ii < json['data'].length; ii++)
		ctfParseEntry(json['data'][ii], ctype);
}

exports.ctfParseJson = ctfParseJson;

},{"assert":18}],73:[function(require,module,exports){
/*
 * rm - Feb 2011
 * ctio.js:
 *
 * A simple way to read and write simple ctypes. Of course, as you'll find the
 * code isn't as simple as it might appear. The following types are currently
 * supported in big and little endian formats:
 *
 * 	uint8_t			int8_t
 * 	uint16_t		int16_t
 * 	uint32_t		int32_t
 *	float (single precision IEEE 754)
 *	double (double precision IEEE 754)
 *
 * This is designed to work in Node and v8. It may in fact work in other
 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
 * If you find that it does in fact work, that's pretty cool. Try and pass word
 * back to the original author.
 *
 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
 * weird.
 */

/*
 * Numbers in Javascript have a secret: all numbers must be represented with an
 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
 * implicit one. Thus the range of integers that can be represented is limited
 * to the size of the mantissa, this makes reading and writing 64-bit integers
 * difficult, but far from impossible.
 *
 * Another side effect of this representation is what happens when you use the
 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
 * each operand and the result is cast to a signed 32-bit number. However, in
 * the case of >>> the values are cast to an unsigned number.
 */

/*
 * A reminder on endian related issues:
 *
 * Big Endian: MSB -> First byte
 * Little Endian: MSB->Last byte
 */
var mod_assert = require('assert');

/*
 * An 8 bit unsigned integer involves doing no significant work.
 */
function ruint8(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (buffer[offset]);
}

/*
 * For 16 bit unsigned numbers we can do all the casting that we want to do.
 */
function rgint16(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset] << 8;
		val |=  buffer[offset+1];
	} else {
		val = buffer[offset];
		val |= buffer[offset+1] << 8;
	}

	return (val);

}

function ruint16(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint16(buffer, endian, offset));
}

/*
 * Because most bitshifting is done using signed numbers, if we would go into
 * the realm where we use that 32nd bit, we'll end up going into the negative
 * range. i.e.:
 * > 200 << 24
 * -939524096
 *
 * Not the value you'd expect. To work around this, we end up having to do some
 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
 * use that instead to save us some additional math, though it does feel a
 * little weird and it isn't obvious as to why you woul dwant to do this at
 * first.
 */
function rgint32(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset+1] << 16;
		val |= buffer[offset+2] << 8;
		val |= buffer[offset+3];
		val = val + (buffer[offset] << 24 >>> 0);
	} else {
		val = buffer[offset+2] << 16;
		val |= buffer[offset+1] << 8;
		val |= buffer[offset];
		val = val + (buffer[offset + 3] << 24 >>> 0);
	}

	return (val);
}

function ruint32(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint32(buffer, endian, offset));
}

/*
 * Reads a 64-bit unsigned number. The astue observer will note that this
 * doesn't quite work. Javascript has chosen to only have numbers that can be
 * represented by a double. A double only has 52 bits of mantissa with an
 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
 * could you have possibly wanted to represent that was larger than that? Oh,
 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
 * that happen?
 *
 * To get around this egregious language issue, we're going to instead construct
 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
 * give the actual number. However, note that the above code probably won't
 * produce the desired results because of the way Javascript numbers are
 * doubles.
 */
function rgint64(buffer, endian, offset)
{
	var val = new Array(2);

	if (endian == 'big') {
		val[0] = ruint32(buffer, endian, offset);
		val[1] = ruint32(buffer, endian, offset+4);
	} else {
		val[0] = ruint32(buffer, endian, offset+4);
		val[1] = ruint32(buffer, endian, offset);
	}

	return (val);
}

function ruint64(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint64(buffer, endian, offset));
}


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 *
 * Doing it this way ends up allowing us to treat it appropriately in
 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
 * shifts, ~ and &.
 */

/*
 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
 * this case because the more traditional methods work, but for consistency,
 * we'll keep doing this the same way.
 */
function rsint8(buffer, endian, offset)
{
	var neg;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	neg = buffer[offset] & 0x80;
	if (!neg)
		return (buffer[offset]);

	return ((0xff - buffer[offset] + 1) * -1);
}

/*
 * The 16-bit version requires a bit more effort. In this case, we can leverage
 * our unsigned code to generate the value we want to return.
 */
function rsint16(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint16(buffer, endian, offset);
	neg = val & 0x8000;
	if (!neg)
		return (val);

	return ((0xffff - val + 1) * -1);
}

/*
 * We really shouldn't leverage our 32-bit code here and instead utilize the
 * fact that we know that since these are signed numbers, we can do all the
 * shifting and binary anding to generate the 32-bit number. But, for
 * consistency we'll do the same. If we want to do otherwise, we should instead
 * make the 32 bit unsigned code do the optimization. But as long as there
 * aren't floats secretly under the hood for that, we /should/ be okay.
 */
function rsint32(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint32(buffer, endian, offset);
	neg = val & 0x80000000;
	if (!neg)
		return (val);

	return ((0xffffffff - val + 1) * -1);
}

/*
 * The signed version of this code suffers from all of the same problems of the
 * other 64 bit version.
 */
function rsint64(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint64(buffer, endian, offset);
	neg = val[0] & 0x80000000;

	if (!neg)
		return (val);

	val[0] = (0xffffffff - val[0]) * -1;
	val[1] = (0xffffffff - val[1] + 1) * -1;

	/*
	 * If we had the key 0x8000000000000000, that would leave the lower 32
	 * bits as 0xffffffff, however, since we're goint to add one, that would
	 * actually leave the lower 32-bits as 0x100000000, which would break
	 * our ability to write back a value that we received. To work around
	 * this, if we actually get that value, we're going to bump the upper
	 * portion by 1 and set this to zero.
	 */
	mod_assert.ok(val[1] <= 0x100000000);
	if (val[1] == -0x100000000) {
		val[1] = 0;
		val[0]--;
	}

	return (val);
}

/*
 * We now move onto IEEE 754: The traditional form for floating point numbers
 * and what is secretly hiding at the heart of everything in this. I really hope
 * that someone is actually using this, as otherwise, this effort is probably
 * going to be more wasted.
 *
 * One might be tempted to use parseFloat here, but that wouldn't work at all
 * for several reasons. Mostly due to the way floats actually work, and
 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
 * this file.
 *
 * In this case we'll implement the single and double precision versions. The
 * quadruple precision, while probably useful, wouldn't really be accepted by
 * Javascript, so let's not even waste our time.
 *
 * So let's review how this format looks like. A single precision value is 32
 * bits and has three parts:
 *   -  Sign bit
 *   -  Exponent (Using bias notation)
 *   -  Mantissa
 *
 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
 * 31| 30-23  |  22    	-       0       |
 *
 * The exponent is stored in a biased input. The bias in this case 127.
 * Therefore, our exponent is equal to the 8-bit value - 127.
 *
 * By default, a number is normalized in IEEE, that means that the mantissa has
 * an implicit one that we don't see. So really the value stored is 1.m.
 * However, if the exponent is all zeros, then instead we have to shift
 * everything to the right one and there is no more implicit one.
 *
 * Special values:
 *  - Positive Infinity:
 *	Sign:		0
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - Negative Infinity:
 *	Sign:		1
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - NaN:
 *	Sign:		*
 *	Exponent: 	All 1s
 *	Mantissa:	non-zero
 *  - Zero:
 *	Sign:		*
 *	Exponent:	All 0s
 *	Mantissa:	0
 *
 * In the case of zero, the sign bit determines whether we get a positive or
 * negative zero. However, since Javascript cannot determine the difference
 * between the two: i.e. -0 == 0, we just always return 0.
 *
 */
function rfloat(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val;
	var bias = 127;
	var maxexp = 0xff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
	} else {
		bytes[3] = buffer[offset];
		bytes[2] = buffer[offset+1];
		bytes[1] = buffer[offset+2];
		bytes[0] = buffer[offset+3];
	}

	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 1;
	exponent |= (bytes[1] & 0x80) >>> 7;
	mantissa = (bytes[1] & 0x7f) << 16;
	mantissa |= bytes[2] << 8;
	mantissa |= bytes[3];

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Doubles in IEEE 754 are like their brothers except for a few changes and
 * increases in size:
 *   - The exponent is now 11 bits
 *   - The mantissa is now 52 bits
 *   - The bias is now 1023
 *
 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
 * 63| 62 - 52   | 	51		-			0     |
 * 63| 62 - 52   |      51              -                       0     |
 *
 * While the size has increased a fair amount, we're going to end up keeping the
 * same general formula for calculating the final value. As a reminder, this
 * formula is:
 *
 * (-1)^s * (n + m) * 2^(e-b)
 *
 * Where:
 *	s	is the sign bit
 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
 *					     or not
 *	m	is the mantissa
 *	e	is the exponent specified
 *	b	is the bias for the exponent
 *
 */
function rdouble(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val, lowmant;
	var bias = 1023;
	var maxexp = 0x7ff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
		bytes[4] = buffer[offset+4];
		bytes[5] = buffer[offset+5];
		bytes[6] = buffer[offset+6];
		bytes[7] = buffer[offset+7];
	} else {
		bytes[7] = buffer[offset];
		bytes[6] = buffer[offset+1];
		bytes[5] = buffer[offset+2];
		bytes[4] = buffer[offset+3];
		bytes[3] = buffer[offset+4];
		bytes[2] = buffer[offset+5];
		bytes[1] = buffer[offset+6];
		bytes[0] = buffer[offset+7];
	}

	/*
	 * We can construct the exponent and mantissa the same way as we did in
	 * the case of a float, just increase the range of the exponent.
	 */
	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 4;
	exponent |= (bytes[1] & 0xf0) >>> 4;

	/*
	 * This is going to be ugly but then again, we're dealing with IEEE 754.
	 * This could probably be done as a node add on in a few lines of C++,
	 * but oh we'll, we've made it this far so let's be native the rest of
	 * the way...
	 *
	 * What we're going to do is break the mantissa into two parts, the
	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
	 * by the appropriate power and then add in the lower 24-bits. Not
	 * really that great. It's pretty much a giant kludge to deal with
	 * Javascript eccentricities around numbers.
	 */
	lowmant = bytes[7];
	lowmant |= bytes[6] << 8;
	lowmant |= bytes[5] << 16;
	mantissa = bytes[4];
	mantissa |= bytes[3] << 8;
	mantissa |= bytes[2] << 16;
	mantissa |= (bytes[1] & 0x0f) << 24;
	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
	mantissa += lowmant;

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Now that we have gone through the pain of reading the individual types, we're
 * probably going to want some way to write these back. None of this is going to
 * be good. But since we have Javascript numbers this should certainly be more
 * interesting. Though we can constrain this end a little bit more in what is
 * valid. For now, let's go back to our friends the unsigned value.
 */

/*
 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
 * that we are going to take:
 *   -  If the number is negative, throw an Error
 *   -  Truncate any floating point portion
 *   -  Take the modulus of the number in our base
 *   -  Write it out to the buffer in the endian format requested at the offset
 */

/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *	value		The number to check for validity
 *
 *	max		The maximum value
 */
function prepuint(value, max)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value < 0)
		throw (new Error('specified a negative value for writing an ' +
		    'unsigned value'));

	if (value > max)
		throw (new Error('value is larger than maximum value for ' +
		    'type'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * 8-bit version, classy. We can ignore endianness which is good.
 */
function wuint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xff);
	buffer[offset] = val;
}

/*
 * Pretty much the same as the 8-bit version, just this time we need to worry
 * about endian related issues.
 */
function wgint16(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val & 0xff00) >>> 8;
		buffer[offset+1] = val & 0x00ff;
	} else {
		buffer[offset+1] = (val & 0xff00) >>> 8;
		buffer[offset] = val & 0x00ff;
	}
}

function wuint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffff);
	wgint16(val, endian, buffer, offset);
}

/*
 * The 32-bit version is going to have to be a little different unfortunately.
 * We can't quite bitshift to get the largest byte, because that would end up
 * getting us caught by the signed values.
 *
 * And yes, we do want to subtract out the lower part by default. This means
 * that when we do the division, it will be treated as a bit shift and we won't
 * end up generating a floating point value. If we did generate a floating point
 * value we'd have to truncate it intelligently, this saves us that problem and
 * may even be somewhat faster under the hood.
 */
function wgint32(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
		buffer[offset+1] = (val >>> 16) & 0xff;
		buffer[offset+2] = (val >>> 8) & 0xff;
		buffer[offset+3] = val & 0xff;
	} else {
		buffer[offset+3] = (val - (val & 0x00ffffff)) /
		    Math.pow(2, 24);
		buffer[offset+2] = (val >>> 16) & 0xff;
		buffer[offset+1] = (val >>> 8) & 0xff;
		buffer[offset] = val & 0xff;
	}
}

function wuint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffffffff);
	wgint32(val, endian, buffer, offset);
}

/*
 * Unlike the other versions, we expect the value to be in the form of two
 * arrays where value[0] << 32 + value[1] would result in the value that we
 * want.
 */
function wgint64(value, endian, buffer, offset)
{
	if (endian == 'big') {
		wgint32(value[0], endian, buffer, offset);
		wgint32(value[1], endian, buffer, offset+4);
	} else {
		wgint32(value[0], endian, buffer, offset+4);
		wgint32(value[1], endian, buffer, offset);
	}
}

function wuint64(value, endian, buffer, offset)
{
	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	prepuint(value[0], 0xffffffff);
	prepuint(value[1], 0xffffffff);
	wgint64(value, endian, buffer, offset);
}

/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *	we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *	we do the following computation:
 *	mb + val + 1, where
 *	mb	is the maximum unsigned value in that byte size
 *	val	is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 *
 * Thus the overall flow is:
 *   -  Truncate the floating point part of the number
 *   -  We don't have to take the modulus, because the unsigned versions will
 *   	take care of that for us. And we don't have to worry about that
 *   	potentially causing bad things to happen because of sign extension
 *   -  Pass it off to the appropriate unsigned version, potentially modifying
 *	the negative portions as necessary.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function prepsint(value, max, min)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value > max)
		throw (new Error('value larger than maximum allowed value'));

	if (value < min)
		throw (new Error('value smaller than minimum allowed value'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * The 8-bit version of the signed value. Overall, fairly straightforward.
 */
function wsint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7f, -0x80);
	if (val >= 0)
		wuint8(val, endian, buffer, offset);
	else
		wuint8(0xff + val + 1, endian, buffer, offset);
}

/*
 * The 16-bit version of the signed value. Also, fairly straightforward.
 */
function wsint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fff, -0x8000);
	if (val >= 0)
		wgint16(val, endian, buffer, offset);
	else
		wgint16(0xffff + val + 1, endian, buffer, offset);

}

/*
 * We can do this relatively easily by leveraging the code used for 32-bit
 * unsigned code.
 */
function wsint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fffffff, -0x80000000);
	if (val >= 0)
		wgint32(val, endian, buffer, offset);
	else
		wgint32(0xffffffff + val + 1, endian, buffer, offset);
}

/*
 * The signed 64 bit integer should by in the same format as when received.
 * Mainly it should ensure that the value is an array of two integers where
 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
 * need to be equal.
 */
function wsint64(value, endian, buffer, offset)
{
	var vzpos, vopos;
	var vals = new Array(2);

	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/*
	 * We need to make sure that we have the same sign on both values. The
	 * hokiest way to to do this is to multiply the number by +inf. If we do
	 * this, we'll get either +/-inf depending on the sign of the value.
	 * Once we have this, we can compare it to +inf to see if the number is
	 * positive or not.
	 */
	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;
	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;

	/*
	 * If either of these is zero, then we don't actually need this check.
	 */
	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
		throw (new Error('Both entries in the array must have ' +
		    'the same sign'));

	/*
	 * Doing verification for a signed 64-bit integer is actually a big
	 * trickier than it appears. We can't quite use our standard techniques
	 * because we need to compare both sets of values. The first value is
	 * pretty straightforward. If the first value is beond the extremes than
	 * we error out. However, the valid range of the second value varies
	 * based on the first one. If the first value is negative, and *not* the
	 * largest negative value, than it can be any integer within the range [
	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
	 * zero.
	 *
	 * If the first number is positive, than it doesn't matter what the
	 * value is. We just simply have to make sure we have a valid positive
	 * integer.
	 */
	if (vzpos) {
		prepuint(value[0], 0x7fffffff);
		prepuint(value[1], 0xffffffff);
	} else {
		prepsint(value[0], 0, -0x80000000);
		prepsint(value[1], 0, -0xffffffff);
		if (value[0] == -0x80000000 && value[1] != 0)
			throw (new Error('value smaller than minimum ' +
			    'allowed value'));
	}

	/* Fix negative numbers */
	if (value[0] < 0 || value[1] < 0) {
		vals[0] = 0xffffffff - Math.abs(value[0]);
		vals[1] = 0x100000000 - Math.abs(value[1]);
		if (vals[1] == 0x100000000) {
			vals[1] = 0;
			vals[0]++;
		}
	} else {
		vals[0] = value[0];
		vals[1] = value[1];
	}
	wgint64(vals, endian, buffer, offset);
}

/*
 * Now we are moving onto the weirder of these, the float and double. For this
 * we're going to just have to do something that's pretty weird. First off, we
 * have no way to get at the underlying float representation, at least not
 * easily. But that doesn't mean we can't figure it out, we just have to use our
 * heads.
 *
 * One might propose to use Number.toString(2). Of course, this is not really
 * that good, because the ECMAScript 262 v3 Standard says the following Section
 * 15.7.4.2-Number.prototype.toString (radix):
 *
 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
 * choice of which is implementation-dependent.
 *
 * Well that doesn't really help us one bit now does it? We could use the
 * standard base 10 version of the string, but that's just going to create more
 * errors as we end up trying to convert it back to a binary value. So, really
 * this just means we have to be non-lazy and parse the structure intelligently.
 *
 * First off, we can do the basic checks: NaN, positive and negative infinity.
 *
 * Now that those are done we can work backwards to generate the mantissa and
 * exponent.
 *
 * The first thing we need to do is determine the sign bit, easy to do, check
 * whether the value is less than 0. And convert the number to its absolute
 * value representation. Next, we need to determine if the value is less than
 * one or greater than or equal to one and from there determine what power was
 * used to get there. What follows is now specific to floats, though the general
 * ideas behind this will hold for doubles as well, but the exact numbers
 * involved will change.
 *
 * Once we have that power we can determine the exponent and the mantissa. Call
 * the value that has the number of bits to reach the power ebits. In the
 * general case they have the following values:
 *
 *	exponent	127 + ebits
 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
 *
 * In the case where the value of ebits is <= -127 we are now in the case where
 * we no longer have normalized numbers. In this case the values take on the
 * following values:
 *
 * 	exponent	0
 *	mantissa	value * 2^149 & 0x7fffff
 *
 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
 * the four bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits from the exp
 *			sign << 7 | (exponent & 0xfe) >>> 1
 *
 *	byte1		lsb from the exponent and 7 top bits from the mantissa
 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
 *
 *	byte2		bits 8-15 (zero indexing) from mantissa
 *			mantissa & 0xff00 >> 8
 *
 *	byte3		bits 0-7 from mantissa
 *			mantissa & 0xff
 *
 * Once we have this we have to assign them into the buffer in proper endian
 * order.
 */

/*
 * Compute the log base 2 of the value. Now, someone who remembers basic
 * properties of logarithms will point out that we could use the change of base
 * formula for logs, and in fact that would be astute, because that's what we'll
 * do for now. It feels cleaner, albeit it may be less efficient than just
 * iterating and dividing by 2. We may want to come back and revisit that some
 * day.
 */
function log2(value)
{
	return (Math.log(value) / Math.log(2));
}

/*
 * Helper to determine the exponent of the number we're looking at.
 */
function intexp(value)
{
	return (Math.floor(log2(value)));
}

/*
 * Helper to determine the exponent of the fractional part of the value.
 */
function fracexp(value)
{
	return (Math.floor(log2(value)));
}

function wfloat(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0xff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0xff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0xff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/* Time to deal with the issues surrounding normalization */
		if (ebits <= -127) {
			exponent = 0;
			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
		} else {
			exponent = 127 + ebits;
			mantissa = value * Math.pow(2, 23 - ebits);
			mantissa &= 0x7fffff;
		}
	}

	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
	bytes[2] = (mantissa & 0x00ff00) >>> 8;
	bytes[3] = mantissa & 0x0000ff;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
	} else {
		buffer[offset] = bytes[3];
		buffer[offset+1] = bytes[2];
		buffer[offset+2] = bytes[1];
		buffer[offset+3] = bytes[0];
	}
}

/*
 * Now we move onto doubles. Doubles are similar to floats in pretty much all
 * ways except that the processing isn't quite as straightforward because we
 * can't always use shifting, i.e. we have > 32 bit values.
 *
 * We're going to proceed in an identical fashion to floats and utilize the same
 * helper functions. All that really is changing are the specific values that we
 * use to do the calculations. Thus, to review we have to do the following.
 *
 * First get the sign bit and convert the value to its absolute value
 * representation. Next, we determine the number of bits that we used to get to
 * the value, branching whether the value is greater than or less than 1. Once
 * we have that value which we will again call ebits, we have to do the
 * following in the general case:
 *
 *	exponent	1023 + ebits
 *	mantissa	[value * 2^(52 - ebits)] % 2^52
 *
 * In the case where the value of ebits <= -1023 we no longer use normalized
 * numbers, thus like with floats we have to do slightly different processing:
 *
 *	exponent	0
 *	mantissa	[value * 2^1074] % 2^52
 *
 * Once we have determined the sign, exponent and mantissa we can construct the
 * bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits form the exp
 *			sign << 7 | (exponent & 0x7f0) >>> 4
 *
 *	byte1		Remaining 4 bits from the exponent and the four most
 *			significant bits from the mantissa 48-51
 *			(exponent & 0x00f) << 4 | mantissa >>> 48
 *
 *	byte2		Bits 40-47 from the mantissa
 *			(mantissa >>> 40) & 0xff
 *
 *	byte3		Bits 32-39 from the mantissa
 *			(mantissa >>> 32) & 0xff
 *
 *	byte4		Bits 24-31 from the mantissa
 *			(mantissa >>> 24) & 0xff
 *
 *	byte5		Bits 16-23 from the Mantissa
 *			(mantissa >>> 16) & 0xff
 *
 *	byte6		Bits 8-15 from the mantissa
 *			(mantissa >>> 8) & 0xff
 *
 *	byte7		Bits 0-7 from the mantissa
 *			mantissa & 0xff
 *
 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
 * we'll have extended too far and we'll lose those values when we try and do
 * the shift. Instead we have to use an alternate approach. To try and stay out
 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
 * that's ugly, but it seems to avoid using floating point (just based on how v8
 * seems to be optimizing for base 2 arithmetic).
 */
function wdouble(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0x7ff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/*
		 * This is a total hack to determine a denormalized value.
		 * Unfortunately, we sometimes do not get a proper value for
		 * ebits, i.e. we lose the values that would get rounded off.
		 *
		 *
		 * The astute observer may wonder why we would be
		 * multiplying by two Math.pows rather than just summing
		 * them. Well, that's to get around a small bug in the
		 * way v8 seems to implement the function. On occasion
		 * doing:
		 *
		 * foo * Math.pow(2, 1023 + 51)
		 *
		 * Causes us to overflow to infinity, where as doing:
		 *
		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
		 *
		 * Does not cause us to overflow. Go figure.
		 *
		 */
		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
			exponent = 0;
			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
			mantissa %= Math.pow(2, 52);
		} else {
			/*
			 * We might have gotten fucked by our floating point
			 * logarithm magic. This is rather crappy, but that's
			 * our luck. If we just had a log base 2 or access to
			 * the stupid underlying representation this would have
			 * been much easier and we wouldn't have such stupid
			 * kludges or hacks.
			 */
			if (ebits > 1023)
				ebits = 1023;
			exponent = 1023 + ebits;
			mantissa = value * Math.pow(2, -ebits);
			mantissa *= Math.pow(2, 52);
			mantissa %= Math.pow(2, 52);
		}
	}

	/* Fill the bytes in backwards to deal with the size issues */
	bytes[7] = mantissa & 0xff;
	bytes[6] = (mantissa >>> 8) & 0xff;
	bytes[5] = (mantissa >>> 16) & 0xff;
	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
	bytes[4] = mantissa & 0xff;
	bytes[3] = (mantissa >>> 8) & 0xff;
	bytes[2] = (mantissa >>> 16) & 0xff;
	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
		buffer[offset+4] = bytes[4];
		buffer[offset+5] = bytes[5];
		buffer[offset+6] = bytes[6];
		buffer[offset+7] = bytes[7];
	} else {
		buffer[offset+7] = bytes[0];
		buffer[offset+6] = bytes[1];
		buffer[offset+5] = bytes[2];
		buffer[offset+4] = bytes[3];
		buffer[offset+3] = bytes[4];
		buffer[offset+2] = bytes[5];
		buffer[offset+1] = bytes[6];
		buffer[offset] = bytes[7];
	}
}

/*
 * Actually export our work above. One might argue that we shouldn't expose
 * these interfaces and just force people to use the higher level abstractions
 * around this work. However, unlike say other libraries we've come across, this
 * interface has several properties: it makes sense, it's simple, and it's
 * useful.
 */
exports.ruint8 = ruint8;
exports.ruint16 = ruint16;
exports.ruint32 = ruint32;
exports.ruint64 = ruint64;
exports.wuint8 = wuint8;
exports.wuint16 = wuint16;
exports.wuint32 = wuint32;
exports.wuint64 = wuint64;

exports.rsint8 = rsint8;
exports.rsint16 = rsint16;
exports.rsint32 = rsint32;
exports.rsint64 = rsint64;
exports.wsint8 = wsint8;
exports.wsint16 = wsint16;
exports.wsint32 = wsint32;
exports.wsint64 = wsint64;

exports.rfloat = rfloat;
exports.rdouble = rdouble;
exports.wfloat = wfloat;
exports.wdouble = wdouble;

},{"assert":18}],54:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var ltx = require('ltx');
var StreamParser = require('./stream_parser');
var WebSocket = require('faye-websocket') ?
                require('faye-websocket').Client :
                window.WebSocket;


var NS_STREAM = exports.NS_STREAM = 'http://etherx.jabber.org/streams';
var NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams';

function WSConnection(url) {
    EventEmitter.call(this);

    this.url = url;
    this.xmlns = {};
    this.websocket = new WebSocket(this.url, ['xmpp']);
    this.websocket.onopen = this.onopen.bind(this);
    this.websocket.onmessage = this.onmessage.bind(this);
    this.websocket.onclose = this.onclose.bind(this);
    this.websocket.onerror = this.onerror.bind(this);
}
util.inherits(WSConnection, EventEmitter);
exports.WSConnection = WSConnection;

WSConnection.prototype.maxStanzaSize = 65535;

WSConnection.prototype.onopen = function() {
    this.emit('connected');
    this.startParser();
};

WSConnection.prototype.startParser = function() {
    var self = this;
    this.parser = new StreamParser.StreamParser(this.maxStanzaSize);

    this.parser.addListener('start', function(attrs) {
        self.streamAttrs = attrs;
        /* We need those xmlns often, store them extra */
        self.streamNsAttrs = {};
        for(var k in attrs) {
        if (k == 'xmlns' ||
            k.substr(0, 6) == 'xmlns:')
                self.streamNsAttrs[k] = attrs[k];
        }

        /* Notify in case we don't wait for <stream:features/>
           (Component or non-1.0 streams)
         */
        self.emit('streamStart', attrs);
    });
    this.parser.addListener('stanza', function(stanza) {
        //self.onStanza(self.addStreamNs(stanza));
        self.onStanza(stanza);
    });
    this.parser.addListener('error', this.onerror.bind(this));
    this.parser.addListener('end', function() {
        self.stopParser();
        self.end();
    });
};

WSConnection.prototype.stopParser = function() {
    /* No more events, please (may happen however) */
    if(this.parser) {
        /* Get GC'ed */
        delete this.parser;
    }
};

WSConnection.prototype.onmessage = function(msg) {
    console.log("ws msg", msg.data);
    if (msg && msg.data && this.parser)
	this.parser.write(msg.data);
};

WSConnection.prototype.onStanza = function(stanza) {
    if (stanza.is('error', NS_STREAM)) {
        /* TODO: extract error text */
        this.emit('error', stanza);
    } else {
        this.emit('stanza', stanza);
    }
};

WSConnection.prototype.startStream = function() {
    var attrs = {};
    for(var k in this.xmlns) {
        if (this.xmlns.hasOwnProperty(k)) {
            if (!k)
                attrs.xmlns = this.xmlns[k];
            else
                attrs['xmlns:' + k] = this.xmlns[k];
        }
    }
    if (this.xmppVersion)
        attrs.version = this.xmppVersion;
    if (this.streamTo)
        attrs.to = this.streamTo;
    if (this.streamId)
        attrs.id = this.streamId;

    var el = new ltx.Element('stream:stream', attrs);
    // make it non-empty to cut the closing tag
    el.t(' ');
    var s = el.toString();
    this.send(s.substr(0, s.indexOf(' </stream:stream>')));

    this.streamOpened = true;
};

WSConnection.prototype.send = function(stanza) {
    if (stanza.root)
	stanza = stanza.root();
    stanza = stanza.toString();
    console.log("ws send", stanza);
    this.websocket.send(stanza);
};

WSConnection.prototype.onclose = function() {
};

WSConnection.prototype.end = function() {
    this.send("</stream:stream>");
    if (this.websocket)
	this.websocket.close();
};

WSConnection.prototype.onerror = function(e) {
    this.emit('error', e);
};

},{"events":4,"util":3,"faye-websocket":17,"./stream_parser":56,"ltx":39}],53:[function(require,module,exports){
(function(process){var EventEmitter = require('events').EventEmitter;
var util = require('util');
var request = require('request');
var ltx = require('ltx');


function BOSHConnection(opts) {
    var that = this;
    EventEmitter.call(this);

    this.boshURL = opts.boshURL;
    this.jid = opts.jid;
    this.xmlnsAttrs = {
	xmlns: "http://jabber.org/protocol/httpbind",
	'xmlns:xmpp': "urn:xmpp:xbosh",
	'xmlns:stream': "http://etherx.jabber.org/streams"
    };
    if (opts.xmlns)
	for(var prefix in opts.xmlns)
	    if (prefix)
		this.xmlnsAttrs["xmlns:" + prefix] = opts.xmlns[prefix];
	    else
		this.xmlnsAttrs["xmlns"] = opts.xmlns[prefix];
    this.currentRequests = 0;
    this.queue = [];
    this.rid = Math.ceil(Math.random() * 9999999999);

    this.request({
	to: this.jid.domain,
	ver: "1.6",
	wait: "10",
	hold: "1",
	content: this.contentType
    }, [], function(err, bodyEl) {
	if (err) {
	    that.emit('error', err);
	} else if (bodyEl && bodyEl.attrs) {
	    that.sid = bodyEl.attrs.sid;
	    that.maxRequests = parseInt(bodyEl.attrs.requests, 10) || 2;
	    if (that.sid && that.maxRequests > 0) {
		that.emit('connect');
		that.processResponse(bodyEl);
		process.nextTick(that.mayRequest.bind(that));
	    } else
		that.emit('error', "Invalid parameters");
	}
    });
}
util.inherits(BOSHConnection, EventEmitter);
exports.BOSHConnection = BOSHConnection;

BOSHConnection.prototype.contentType = "text/xml; charset=utf-8";

BOSHConnection.prototype.send = function(stanza) {
    this.queue.push(stanza.root());
    process.nextTick(this.mayRequest.bind(this));
};

BOSHConnection.prototype.processResponse = function(bodyEl) {
    if (bodyEl && bodyEl.children) {
	for(var i = 0; i < bodyEl.children.length; i++) {
	    var child = bodyEl.children[i];
	    if (child.name && child.attrs && child.children)
		this.emit('stanza', child);
	}
    }
    if (bodyEl && bodyEl.attrs.type === 'terminate') {
	this.emit('error', new Error(bodyEl.attrs.condition || "Session terminated"));
	this.emit('close');
    }
};

BOSHConnection.prototype.mayRequest = function() {
    var that = this;
    var canRequest =
	/* Must have a session already */
	this.sid &&
	/* We can only receive when one request is in flight */
	(this.currentRequests === 0 ||
	 /* Is there something to send, and are we allowed? */
	 ((this.queue.length > 0 && this.currentRequests < this.maxRequests))
	);
    if (!canRequest)
	return;

    var stanzas = this.queue;
    this.queue = [];
    this.rid++;
    this.request({}, stanzas, function(err, bodyEl) {
	if (err) {
	    that.emit('error', err);
	    that.emit('close');
	    delete that.sid;
	} else {
	    if (bodyEl)
		that.processResponse(bodyEl);

	    process.nextTick(that.mayRequest.bind(that));
	}
    });
};

BOSHConnection.prototype.end = function(stanzas) {
    var that = this;

    stanzas = stanzas || [];
    if (typeof stanzas !== 'array')
	stanzas = [stanzas];

    stanzas = this.queue.concat(stanzas);
    this.queue = [];
    this.rid++;
    this.request({ type: 'terminate' }, stanzas, function(err, bodyEl) {
	if (bodyEl)
	    that.processResponse(bodyEl);

	that.emit('end');
	that.emit('close');
	delete that.sid;
    });
};

BOSHConnection.prototype.maxHTTPRetries = 5;

BOSHConnection.prototype.request = function(attrs, children, cb, retry) {
    var that = this;
    retry = retry || 0;

    attrs.rid = this.rid.toString();
    if (this.sid)
	attrs.sid = this.sid;

    for(var k in this.xmlnsAttrs)
	attrs[k] = this.xmlnsAttrs[k];
    var boshEl = new ltx.Element('body', attrs);
    for(var i = 0; i < children.length; i++)
	boshEl.cnode(children[i]);

    request({
	uri: this.boshURL,
	method: 'POST',
	headers: {
	    "Content-Type": this.contentType
	},
	body: boshEl.toString()
    }, function(err, res, body) {
	that.currentRequests--;

	if (err) {
	    if (retry < that.maxHTTPRetries)
		return that.request(attrs, children, cb, retry + 1);
	    else
		return cb(err);
	}
	if (res.statusCode < 200 || res.statusCode >= 400)
	    return cb(new Error("HTTP status " + res.statusCode));

	var bodyEl;
	try {
	    bodyEl = ltx.parse(body);
	} catch(e) {
	    return cb(e);
	}

	if (bodyEl && bodyEl.attrs.type === 'terminate')
	    cb(new Error(bodyEl.attrs.condition));
	else if (bodyEl)
	    cb(null, bodyEl);
	else
	    cb(new Error('no <body/>'));
    });
    this.currentRequests++;
};

})(require("__browserify_process"))
},{"events":4,"util":3,"request":"RLCzBz","ltx":39,"__browserify_process":9}],60:[function(require,module,exports){
(function(Buffer){var util = require('util');
var Stream = require('stream').Stream;
var DelayedStream = require('delayed-stream');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')    
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      stream.on('data', this._checkDataSize.bind(this));

      stream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this))
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

})(require("__browserify_buffer").Buffer)
},{"util":3,"stream":5,"delayed-stream":75,"__browserify_buffer":19}],68:[function(require,module,exports){
// Load modules

var Boom = require('boom');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Hawk authentication

/*
   req:                 node's HTTP request object or an object as follows:
  
                        var request = {
                            method: 'GET',
                            url: '/resource/4?a=1&b=2',
                            host: 'example.com',
                            port: 8080,
                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                        };
  
   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                        needed by the application. This function is the equivalent of verifying the username and
                        password in Basic authentication.
  
                        var credentialsFunc = function (id, callback) {
    
                            // Lookup credentials in database
                            db.lookup(id, function (err, item) {
    
                                if (err || !item) {
                                    return callback(err);
                                }
    
                                var credentials = {
                                    // Required
                                    key: item.key,
                                    algorithm: item.algorithm,
                                    // Application specific
                                    user: item.user
                                };
    
                                return callback(null, credentials);
                            });
                        };
  
   options: {

        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                               Only used when passed a node Http.ServerRequest object.
  
        nonceFunc:             optional nonce validation function. The function signature is function(nonce, ts, callback)
                               where 'callback' must be called using the signature function(err).
  
        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                               Provides a +/- skew which means actual allowed window is double the number of seconds.
  
        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                               Defaults to 0.
  
        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                               header attribute. The server always ensures the value provided has been included in the request
                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                               a hash value over the entire payload (assuming it has already be normalized to the same format and
                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
                               attributes.hash returned in the authenticate callback.
    }

    callback: function (err, credentials, artifacts) { }
 */

exports.authenticate = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);
    
    // Default options

    options.nonceFunc = options.nonceFunc || function (nonce, ts, nonceCallback) { return nonceCallback(); };   // No validation
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Parse HTTP Authorization header

    var attributes = Utils.parseAuthorizationHeader(request.authorization);
    if (attributes instanceof Error) {
        return callback(attributes);
    }

    // Construct artifacts container

    var artifacts = {
        method: request.method,
        host: request.host,
        port: request.port,
        resource: request.url,
        ts: attributes.ts,
        nonce: attributes.nonce,
        hash: attributes.hash,
        ext: attributes.ext,
        app: attributes.app,
        dlg: attributes.dlg,
        mac: attributes.mac,
        id: attributes.id
    };

    // Verify required header attributes

    if (!attributes.id ||
        !attributes.ts ||
        !attributes.nonce ||
        !attributes.mac) {

        return callback(Boom.badRequest('Missing attributes'), null, artifacts);
    }

    // Fetch Hawk credentials

    credentialsFunc(attributes.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, artifacts);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('header', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
        }

        // Check payload hash

        if (options.payload !== null &&
            options.payload !== undefined) {       // '' is valid

            if (!attributes.hash) {
                return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
            }

            var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
            if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
            }
        }

        // Check nonce

        options.nonceFunc(attributes.nonce, attributes.ts, function (err) {

            if (err) {
                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
            }

            // Check timestamp staleness

            if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                var fresh = Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);            // Get fresh now
                var tsm = Crypto.calculateTsMac(fresh, credentials);
                return callback(Boom.unauthorized('Stale timestamp', 'Hawk', { ts: fresh, tsm: tsm }), credentials, artifacts);
            }

            // Successful authentication

            return callback(null, credentials, artifacts);
        });
    });
};


// Authenticate payload hash - used when payload cannot be provided during authenticate()

/*
    payload:        raw request payload
    credentials:    from authenticate callback
    artifacts:      from authenticate callback
    contentType:    req.headers['content-type']
*/

exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {

    var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
};


// Generate a Server-Authorization header for a given response

/*
    credentials: {},                                        // Object received from authenticate()
    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
    options: {
        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
    }
*/

exports.header = function (credentials, artifacts, options) {

    // Prepare inputs

    options = options || {};

    if (!artifacts ||
        typeof artifacts !== 'object' ||
        typeof options !== 'object') {

        return '';
    }

    artifacts = Hoek.clone(artifacts);
    delete artifacts.mac;
    artifacts.hash = options.hash;
    artifacts.ext = options.ext;

    // Validate credentials

    if (!credentials ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('response', credentials, artifacts);

    // Construct header

    var header = 'Hawk mac="' + mac + '"' +
                 (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');

    if (artifacts.ext !== null &&
        artifacts.ext !== undefined &&
        artifacts.ext !== '') {                       // Other falsey values allowed

        header += ', ext="' + Utils.escapeHeaderAttribute(artifacts.ext) + '"';
    }

    return header;
};


/*
 * Arguments and options are the same as index.js with the exception that the only supported options are:
 * 'hostHeaderName', 'localtimeOffsetMsec'
 */

exports.authenticateBewit = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Extract bewit

    //                                 1     2             3           4     
    var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
    if (!resource) {
        return callback(Boom.unauthorized(null, 'Hawk'));
    }

    // Bewit not empty

    if (!resource[3]) {
        return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
    }

    // Verify method is GET

    if (request.method !== 'GET' &&
        request.method !== 'HEAD') {

        return callback(Boom.unauthorized('Invalid method', 'Hawk'));
    }

    // No other authentication

    if (request.authorization) {
        return callback(Boom.badRequest('Multiple authentications', 'Hawk'));
    }

    // Parse bewit

    var bewitString = Utils.base64urlDecode(resource[3]);
    if (bewitString instanceof Error) {
        return callback(Boom.badRequest('Invalid bewit encoding'));
    }

    // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)

    var bewitParts = bewitString.split('\\');
    if (!bewitParts ||
        bewitParts.length !== 4) {

        return callback(Boom.badRequest('Invalid bewit structure'));
    }

    var bewit = {
        id: bewitParts[0],
        exp: parseInt(bewitParts[1], 10),
        mac: bewitParts[2],
        ext: bewitParts[3] || ''
    };

    if (!bewit.id ||
        !bewit.exp ||
        !bewit.mac) {

        return callback(Boom.badRequest('Missing bewit attributes'));
    }

    // Construct URL without bewit

    var url = resource[1];
    if (resource[4]) {
        url += resource[2] + resource[4];
    }

    // Check expiration

    if (bewit.exp * 1000 <= now) {
        return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
    }

    // Fetch Hawk credentials

    credentialsFunc(bewit.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, bewit.ext);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: bewit.exp,
            nonce: '',
            method: 'GET',
            resource: url,
            host: request.host,
            port: request.port,
            ext: bewit.ext
        });

        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
        }

        // Successful authentication

        return callback(null, credentials, bewit);
    });
};

},{"./crypto":66,"./utils":67,"boom":70,"hoek":76,"cryptiles":77}],69:[function(require,module,exports){
// Load modules

var Url = require('url');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    method: HTTP verb (e.g. 'GET', 'POST')
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
        },

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now(),                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
    }
*/

exports.header = function (uri, method, options) {

    var result = {
        field: '',
        artifacts: {}
    };

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object') {

        return result;
    }

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000)

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return result;
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return result;
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        method: method,
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
    };

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('header', credentials, artifacts);

    // Construct header

    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    var header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                 (hasExt ? '", ext="' + Utils.escapeHeaderAttribute(artifacts.ext) : '') +
                 '", mac="' + mac + '"';

    if (artifacts.app) {
        header += ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
    }

    result.field = header;

    return result;
};


// Validate server response

/*
    res:        node's response object
    artifacts:  object recieved from header().artifacts
    options: {
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
    }
*/

exports.authenticate = function (res, credentials, artifacts, options) {

    artifacts = Hoek.clone(artifacts);
    options = options || {};

    if (res.headers['www-authenticate']) {

        // Parse HTTP WWW-Authenticate header

        var attributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
        if (attributes instanceof Error) {
            return false;
        }

        if (attributes.ts) {
            var tsm = Crypto.calculateTsMac(attributes.ts, credentials);
            if (tsm !== attributes.tsm) {
                return false;
            }
        }
    }

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required) {

        return true;
    }

    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (attributes instanceof Error) {
        return false;
    }

    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;

    var mac = Crypto.calculateMac('response', credentials, artifacts);
    if (mac !== attributes.mac) {
        return false;
    }

    if (!options.hasOwnProperty('payload')) {
        return true;
    }

    if (!attributes.hash) {
        return false;
    }

    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
    return (calculatedHash === attributes.hash);
};


// Generate a bewit value for a given URI

/*
 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
 * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
 */
/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        },
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
    };
*/

exports.getBewit = function (uri, options) {

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object') ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec) {

        return '';
    }

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var exp = Math.floor(now / 1000) + options.ttlSec;
    var mac = Crypto.calculateMac('bewit', credentials, {
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        ext: options.ext
    });

    // Construct bewit: id\exp\mac\ext

    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Utils.base64urlEncode(bewit);
};


},{"url":1,"./crypto":66,"./utils":67,"hoek":76,"cryptiles":77}],67:[function(require,module,exports){
(function(__dirname){// Load modules

var Hoek = require('hoek');
var Sntp = require('sntp');
var Boom = require('boom');


// Declare internals

var internals = {};


// Import Hoek Utilities

internals.import = function () {

    for (var i in Hoek) {
        if (Hoek.hasOwnProperty(i)) {
            exports[i] = Hoek[i];
        }
    }
};

internals.import();


// Hawk version

exports.version = function () {

    return exports.loadPackage(__dirname + '/..').version;
};


// Extract host and port from request

exports.parseHost = function (req, hostHeaderName) {

    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
    var hostHeader = req.headers[hostHeaderName];
    if (!hostHeader) {
        return null;
    }

    var hostHeaderRegex = /^(?:(?:\r\n)?[\t ])*([^:]+)(?::(\d+))?(?:(?:\r\n)?[\t ])*$/;     // Does not support IPv6
    var hostParts = hostHeader.match(hostHeaderRegex);

    if (!hostParts ||
        hostParts.length !== 3 ||
        !hostParts[1]) {

        return null;
    }

    return {
        name: hostParts[1],
        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
    };
};


// Parse Content-Type header content

exports.parseContentType = function (header) {

    if (!header) {
        return '';
    }

    return header.split(';')[0].trim().toLowerCase();
};


// Convert node's  to request configuration object

exports.parseRequest = function (req, options) {

    if (!req.headers) {
        return req;
    }

    // Obtain host and port information

    var host = exports.parseHost(req, options.hostHeaderName);
    if (!host) {
        return new Error('Invalid Host header');
    }

    var request = {
        method: req.method,
        url: req.url,
        host: host.name,
        port: host.port,
        authorization: req.headers.authorization,
        contentType: req.headers['content-type'] || ''
    };

    return request;
};


exports.now = function () {

    return Sntp.now();
};


// Parse Hawk HTTP Authorization header

exports.parseAuthorizationHeader = function (header, keys) {

    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];

    if (!header) {
        return Boom.unauthorized(null, 'Hawk');
    }

    var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
    if (!headerParts) {
        return Boom.badRequest('Invalid header syntax');
    }

    var scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') {
        return Boom.unauthorized(null, 'Hawk');
    }

    var attributesString = headerParts[2];
    if (!attributesString) {
        return Boom.badRequest('Invalid header syntax');
    }

    var attributes = {};
    var errorMessage = '';
    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

        // Check valid attribute names

        if (keys.indexOf($1) === -1) {
            errorMessage = 'Unknown attribute: ' + $1;
            return;
        }

        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

        if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
            errorMessage = 'Bad attribute value: ' + $1;
            return;
        }

        // Check for duplicates

        if (attributes.hasOwnProperty($1)) {
            errorMessage = 'Duplicate attribute: ' + $1;
            return;
        }

        attributes[$1] = $2;
        return '';
    });

    if (verify !== '') {
        return Boom.badRequest(errorMessage || 'Bad header format');
    }

    return attributes;
};


exports.unauthorized = function (message) {

    return Boom.unauthorized(message, 'Hawk');
};


})("/node_modules/request/node_modules/hawk/lib")
},{"sntp":71,"hoek":76,"boom":70}],70:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":78}],71:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":79}],75:[function(require,module,exports){
var Stream = require('stream').Stream;
var util = require('util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

DelayedStream.prototype.__defineGetter__('readable', function() {
  return this.source.readable;
});

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};

},{"stream":5,"util":3}],74:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = require('./errors');
var types = require('./types');

var Reader = require('./reader');
var Writer = require('./writer');


///--- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}

},{"./errors":80,"./writer":81,"./types":82,"./reader":83}],84:[function(require,module,exports){

},{}],80:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};

},{}],82:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};

},{}],76:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":85}],77:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":86}],81:[function(require,module,exports){
(function(Buffer){// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert');
var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


///--- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof(from), 'object');
  assert.ok(to);
  assert.equal(typeof(to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



///--- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = new Buffer(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];

  var self = this;
  this.__defineGetter__('buffer', function() {
    if (self._seq.length)
      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

    return self._buf.slice(0, self._offset);
  });
}


Writer.prototype.writeByte = function(b) {
  if (typeof(b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
         (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof(b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof(tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
  if (typeof(tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof(tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function(strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof(tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function(len) {
  if (typeof(len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function(tag) {
  if (typeof(tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function() {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw new InvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function(start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function(len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = new Buffer(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



///--- Exported API

module.exports = Writer;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./types":82,"./errors":80,"__browserify_buffer":19}],83:[function(require,module,exports){
(function(Buffer){// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert');

var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



///--- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;

  var self = this;
  this.__defineGetter__('length', function() { return self._len; });
  this.__defineGetter__('offset', function() { return self._offset; });
  this.__defineGetter__('remain', function() {
    return self._size - self._offset;
  });
  this.__defineGetter__('buffer', function() {
    return self._buf.slice(self._offset);
  });
}


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function() {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function(offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) == 0x80) {
    lenB &= 0x7f;

    if (lenB == 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function() {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function() {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function(tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function(tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  var values = [];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    var byte = this._buf[this._offset++] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) == 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function(tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset++];
  var value = 0;

  value = fb & 0x7F;
  for (var i = 1; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) == 0x80)
    value = -value;

  return value;
};



///--- Exported API

module.exports = Reader;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./types":82,"./errors":80,"__browserify_buffer":19}],85:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        source.forEach(function (item) {

            target.push(item);
        });

        return target;
    }

    Object.keys(source).forEach(function (key) {

        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    });

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return common;
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    path.forEach(function (level) {

        if (ref) {
            ref = ref[level];
        }
    });

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    stack.forEach(function (item) {

        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    });

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];
    trace.forEach(function (row) {

        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    });

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    Fs.readdirSync(path).forEach(function (filename) {

        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    });
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":87,"__browserify_process":9,"__browserify_buffer":19}],79:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Dgram = require('dgram');
var Dns = require('dns');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports.time = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var settings = Hoek.clone(options);
    settings.host = settings.host || 'pool.ntp.org';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    var timeoutId = 0;
    var sent = 0;

    // Ensure callback is only called once

    var isFinished = false;
    var finish = function (err, result) {

        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = 0;
        }

        if (!isFinished) {
            isFinished = true;
            socket.removeAllListeners();
            socket.close();
            return callback(err, result);
        }
    };

    // Create UDP socket

    var socket = Dgram.createSocket('udp4');

    socket.once('error', function (err) {

        return finish(err);
    });

    // Listen to incoming messages

    socket.on('message', function (buffer, rinfo) {

        var received = Date.now();

        var message = new internals.NtpMessage(buffer);
        if (!message.isValid) {
            return finish(new Error('Invalid server response'), message);
        }

        if (message.originateTimestamp !== sent) {
            return finish(new Error('Wrong originate timestamp'), message);
        }

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2

        var T1 = message.originateTimestamp;
        var T2 = message.receiveTimestamp;
        var T3 = message.transmitTimestamp;
        var T4 = received;

        message.d = (T4 - T1) - (T3 - T2);
        message.t = ((T2 - T1) + (T3 - T4)) / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary') {

            return finish(null, message);
        }

        // Resolve reference IP address

        Dns.reverse(message.referenceId, function (err, domains) {

            if (!err) {
                message.referenceHost = domains[0];
            }

            return finish(null, message);
        });
    });

    // Set timeout

    if (settings.timeout) {
        timeoutId = setTimeout(function () {

            timeoutId = 0;
            return finish(new Error('Timeout'));
        }, settings.timeout);
    }

    // Construct NTP message

    var message = new Buffer(48);
    for (var i = 0; i < 48; i++) {                      // Zero message
        message[i] = 0;
    }

    message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
    sent = Date.now();
    internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {

        if (err ||
            bytes !== 48) {

            return finish(err || new Error('Could not send entire message'));
        }
    });
};


internals.NtpMessage = function (buffer) {

    this.isValid = false;

    // Validate

    if (buffer.length !== 48) {
        return;
    }

    // Leap indicator

    var li = (buffer[0] >> 6);
    switch (li) {
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
    }

    // Version

    var vn = ((buffer[0] & 0x38) >> 3);
    this.version = vn;

    // Mode

    var mode = (buffer[0] & 0x7);
    switch (mode) {
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
    }

    // Stratum

    var stratum = buffer[1];
    if (stratum === 0) {
        this.stratum = 'death';
    }
    else if (stratum === 1) {
        this.stratum = 'primary';
    }
    else if (stratum <= 15) {
        this.stratum = 'secondary';
    }
    else {
        this.stratum = 'reserved';
    }

    // Poll interval (msec)

    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;

    // Precision (msecs)

    this.precision = Math.pow(2, buffer[3]) * 1000;

    // Root delay (msecs)

    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000);

    // Root dispersion (msecs)

    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum) {
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
    }

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16);

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24);

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32);

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40);

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp) {

        this.isValid = true;
    }

    return this;
};


internals.toMsecs = function (buffer, offset) {

    var seconds = 0;
    var fraction = 0;

    for (var i = 0; i < 4; ++i) {
        seconds = (seconds * 256) + buffer[offset + i];
    }

    for (i = 4; i < 8; ++i) {
        fraction = (fraction * 256) + buffer[offset + i];
    }

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
};


internals.fromMsecs = function (ts, buffer, offset) {

    var seconds = Math.floor(ts / 1000) + 2208988800;
    var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));

    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF);

    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF);
};


// Offset singleton

internals.last = {
    offset: 0,
    expires: 0,
    host: '',
    port: 0
};


exports.offset = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var now = Date.now();
    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires) {

        process.nextTick(function () {
                
            callback(null, internals.last.offset);
        });

        return;
    }

    exports.time(options, function (err, time) {

        if (err) {
            return callback(err, 0);
        }

        internals.last = {
            offset: Math.round(time.t),
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
        };

        return callback(null, internals.last.offset);
    });
};


// Now singleton

internals.now = {
    intervalId: 0
};


exports.start = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    if (internals.now.intervalId) {
        process.nextTick(function () {
            
            callback();
        });
        
        return;
    }

    exports.offset(options, function (err, offset) {

        internals.now.intervalId = setInterval(function () {

            exports.offset(options, function () { });
        }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily

        return callback();
    });
};


exports.stop = function () {

    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};


exports.isLive = function () {

    return !!internals.now.intervalId;
};


exports.now = function () {

    var now = Date.now();
    if (!exports.isLive() ||
        now >= internals.last.expires) {

        return now;
    }

    return now + internals.last.offset;
};


})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"dgram":84,"dns":17,"hoek":88,"__browserify_process":9,"__browserify_buffer":19}],78:[function(require,module,exports){
// Load modules

var Http = require('http');
var NodeUtil = require('util');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports = module.exports = internals.Boom = function (/* (new Error) or (code, message) */) {

    var self = this;

    Hoek.assert(this.constructor === internals.Boom, 'Error must be instantiated using new');

    Error.call(this);
    this.isBoom = true;

    this.response = {
        code: 0,
        payload: {},
        headers: {}
        // type: 'content-type'
    };

    if (arguments[0] instanceof Error) {

        // Error

        var error = arguments[0];

        this.data = error;
        this.response.code = error.code || 500;
        if (error.message) {
            this.message = error.message;
        }
    }
    else {

        // code, message

        var code = arguments[0];
        var message = arguments[1];

        Hoek.assert(!isNaN(parseFloat(code)) && isFinite(code) && code >= 400, 'First argument must be a number (400+)');

        this.response.code = code;
        if (message) {
            this.message = message;
        }
    }

    // Response format

    this.reformat();

    return this;
};

NodeUtil.inherits(internals.Boom, Error);


internals.Boom.prototype.reformat = function () {

    this.response.payload.code = this.response.code;
    this.response.payload.error = Http.STATUS_CODES[this.response.code] || 'Unknown';
    if (this.message) {
        this.response.payload.message = Hoek.escapeHtml(this.message);         // Prevent XSS from error message
    }
};


// Utilities

internals.Boom.badRequest = function (message) {

    return new internals.Boom(400, message);
};


internals.Boom.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])

    var err = new internals.Boom(401, message);

    if (!scheme) {
        return err;
    }

    var wwwAuthenticate = '';

    if (typeof scheme === 'string') {

        // function (message, scheme, attributes)

        wwwAuthenticate = scheme;
        if (attributes) {
            var names = Object.keys(attributes);
            for (var i = 0, il = names.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ',';
                }

                var value = attributes[names[i]];
                if (value === null ||
                    value === undefined) {              // Value can be zero

                    value = '';
                }
                wwwAuthenticate += ' ' + names[i] + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ',';
            }
            wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
        }
        else {
            err.isMissing = true;
        }
    }
    else {

        // function (message, wwwAuthenticate[])

        var wwwArray = scheme;
        for (var i = 0, il = wwwArray.length; i < il; ++i) {
            if (i) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += wwwArray[i];
        }
    }

    err.response.headers['WWW-Authenticate'] = wwwAuthenticate;

    return err;
};


internals.Boom.clientTimeout = function (message) {

    return new internals.Boom(408, message);
};


internals.Boom.serverTimeout = function (message) {

    return new internals.Boom(503, message);
};


internals.Boom.forbidden = function (message) {

    return new internals.Boom(403, message);
};


internals.Boom.notFound = function (message) {

    return new internals.Boom(404, message);
};


internals.Boom.internal = function (message, data) {

    var err = new internals.Boom(500, message);

    if (data && data.stack) {
        err.trace = data.stack.split('\n');
        err.outterTrace = Hoek.displayStack(1);
    }
    else {
        err.trace = Hoek.displayStack(1);
    }

    err.data = data;
    err.response.payload.message = 'An internal server error occurred';                     // Hide actual error from user

    return err;
};


internals.Boom.passThrough = function (code, payload, contentType, headers) {

    var err = new internals.Boom(500, 'Pass-through');                                      // 500 code is only used to initialize

    err.data = {
        code: code,
        payload: payload,
        type: contentType
    };

    err.response.code = code;
    err.response.type = contentType;
    err.response.headers = headers;
    err.response.payload = payload;

    return err;
};



},{"http":7,"util":3,"hoek":89}],87:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}],88:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":90}],89:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":91}],86:[function(require,module,exports){
// Load modules

var Crypto = require('crypto');
var Boom = require('boom');


// Declare internals

var internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    var buffer = exports.randomBits((size + 1) * 6);
    if (buffer instanceof Error) {
        return buffer;
    }

    var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        return Boom.internal('Invalid random bits count');
    }

    var bytes = Math.ceil(bits / 8);
    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        return Boom.internal('Failed generating random bits: ' + err.message);
    }
};


// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)

exports.fixedTimeComparison = function (a, b) {

    if (typeof a !== 'string' ||
        typeof b !== 'string') {

        return false;
    }

    var mismatch = (a.length === b.length ? 0 : 1);
    if (mismatch) {
        b = a;
    }

    for (var i = 0, il = a.length; i < il; ++i) {
        var ac = a.charCodeAt(i);
        var bc = b.charCodeAt(i);
        mismatch += (ac === bc ? 0 : 1);
    }

    return (mismatch === 0);
};



},{"crypto":11,"boom":70}],90:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":92,"__browserify_process":9,"__browserify_buffer":19}],91:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":93,"__browserify_process":9,"__browserify_buffer":19}],92:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}],93:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}]},{},[35])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3VybC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vdXRpbC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vc3RyZWFtLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9xdWVyeXN0cmluZy5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vaHR0cHMuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3Rscy5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vZXZlbnRzLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL2ppZC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vYXNzZXJ0LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vbmV0LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvX2VtcHR5LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL29hdXRoLXNpZ24vaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvYXdzLXNpZ24vaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvbWltZS9taW1lLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3R1bm5lbC1hZ2VudC9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9qc29uLXN0cmluZ2lmeS1zYWZlL3N0cmluZ2lmeS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JldmVyLWFnZW50L2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL25vZGUteG1wcC1icm93c2VyaWZ5LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L2J1ZmZlcl9pZWVlNzU0LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9wYXRoLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9mcy5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9jb29raWUtamFyL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL3N0YXJ0dGxzLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9idWZmZXItYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXNwb25zZS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9jb29raWUtamFyL2phci5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2x0eC9saWIvaW5kZXgtYnJvd3NlcmlmeS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL3Nlc3Npb24uanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvbHR4L2xpYi9zYXhfbHR4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL2Nvbm5lY3Rpb24uanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9jbGllbnQuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9zdGFuemEuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jb25jYXQtc3RyZWFtL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2x0eC9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvbHR4L2xpYi9lbGVtZW50LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9wYXJzZXIuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdmVyaWZ5LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi91dGlsLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL3htcHAvc3RyZWFtX3BhcnNlci5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL3Nhc2wuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9saWIvY3J5cHRvLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc3NlcnQtcGx1cy9hc3NlcnQuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYmx1ZWltcC1tZDUvanMvbWQ1LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2x0eC9saWIvcGFyc2UuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2N0eXBlL2N0eXBlLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvY3R5cGUvY3RmLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9jdHlwZS9jdGlvLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL3htcHAvd2Vic29ja2V0cy5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL2Jvc2guanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL25vZGVfbW9kdWxlcy9jb21iaW5lZC1zdHJlYW0vbGliL2NvbWJpbmVkX3N0cmVhbS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2xpYi9zZXJ2ZXIuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9saWIvY2xpZW50LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbGliL3V0aWxzLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2Jvb20vaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvc250cC9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbm9kZV9tb2R1bGVzL2NvbWJpbmVkLXN0cmVhbS9ub2RlX21vZHVsZXMvZGVsYXllZC1zdHJlYW0vbGliL2RlbGF5ZWRfc3RyZWFtLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL2RncmFtLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvZXJyb3JzLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvdHlwZXMuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvaG9lay9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9jcnlwdGlsZXMvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci93cml0ZXIuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9yZWFkZXIuanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvaG9lay9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvc250cC9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvYm9vbS9saWIvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvaG9lay9saWIvZXNjYXBlLmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvbm9kZV9tb2R1bGVzL2hvZWsvaW5kZXguanMiLCIvVXNlcnMvZGF5cmV5L1dlYnN0b3JtUHJvamVjdHMvVHV0b3JpYWxzL2NoYXRib3Qvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvYm9vbS9ub2RlX21vZHVsZXMvaG9lay9pbmRleC5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9jcnlwdGlsZXMvbGliL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvbm9kZV9tb2R1bGVzL2hvZWsvbGliL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2Jvb20vbm9kZV9tb2R1bGVzL2hvZWsvbGliL2luZGV4LmpzIiwiL1VzZXJzL2RheXJleS9XZWJzdG9ybVByb2plY3RzL1R1dG9yaWFscy9jaGF0Ym90L25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvbm9kZV9tb2R1bGVzL2hvZWsvbGliL2VzY2FwZS5qcyIsIi9Vc2Vycy9kYXlyZXkvV2Vic3Rvcm1Qcm9qZWN0cy9UdXRvcmlhbHMvY2hhdGJvdC9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9ib29tL25vZGVfbW9kdWxlcy9ob2VrL2xpYi9lc2NhcGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnhIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTs7QUNEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1bnljb2RlID0geyBlbmNvZGUgOiBmdW5jdGlvbiAocykgeyByZXR1cm4gcyB9IH07XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgc3ViamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmKGFycmF5W2ldID09IHN1YmplY3QpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0rJC8sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ34nLCAnWycsICddJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10sXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIGN1dCBvZmYgYW55IGRlbGltaXRlcnMuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiPGh0dHA6Ly9mb28uY29tPlwiXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXJyYXlJbmRleE9mKGRlbGltcywgcmVzdC5jaGFyQXQoaSkpID09PSAtMSkgYnJlYWs7XG4gIH1cbiAgaWYgKGkgIT09IDApIHJlc3QgPSByZXN0LnN1YnN0cihpKTtcblxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSBhcnJheUluZGV4T2YocmVzdCwgJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgLy8gdGhlcmUgKm1heSBiZSogYW4gYXV0aFxuICAgICAgdmFyIGhhc0F1dGggPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25BdXRoQ2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihyZXN0LCBub25BdXRoQ2hhcnNbaV0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4IDwgYXRTaWduKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQXV0aCkge1xuICAgICAgICAvLyBwbHVjayBvZmYgdGhlIGF1dGggcG9ydGlvbi5cbiAgICAgICAgb3V0LmF1dGggPSByZXN0LnN1YnN0cigwLCBhdFNpZ24pO1xuICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoYXRTaWduICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Tm9uSG9zdCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uSG9zdENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXlJbmRleE9mKHJlc3QsIG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmXG4gICAgICAgICAgKGZpcnN0Tm9uSG9zdCA8IDAgfHwgaW5kZXggPCBmaXJzdE5vbkhvc3QpKSBmaXJzdE5vbkhvc3QgPSBpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3ROb25Ib3N0ICE9PSAtMSkge1xuICAgICAgb3V0Lmhvc3QgPSByZXN0LnN1YnN0cigwLCBmaXJzdE5vbkhvc3QpO1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGZpcnN0Tm9uSG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdDtcbiAgICAgIHJlc3QgPSAnJztcbiAgICB9XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHZhciBwID0gcGFyc2VIb3N0KG91dC5ob3N0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBvdXRba2V5XSA9IHBba2V5XTtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgb3V0Lmhvc3RuYW1lID0gb3V0Lmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKG91dC5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgb3V0Lmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgfVxuICAgIG91dC5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cblxuICAgIC8vIE5vdyBtYWtlIHN1cmUgdGhhdCBkZWxpbXMgbmV2ZXIgYXBwZWFyIGluIGEgdXJsLlxuICAgIHZhciBjaG9wID0gcmVzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZWxpbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGFycmF5SW5kZXhPZihyZXN0LCBkZWxpbXNbaV0pO1xuICAgICAgaWYgKGMgIT09IC0xKSB7XG4gICAgICAgIGNob3AgPSBNYXRoLm1pbihjLCBjaG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKDAsIGNob3ApO1xuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IGFycmF5SW5kZXhPZihyZXN0LCAnIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSBhcnJheUluZGV4T2YocmVzdCwgJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGF1dGguc3BsaXQoJ0AnKS5qb2luKCclNDAnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkF1dGhDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuQUMgPSBub25BdXRoQ2hhcnNbaV07XG4gICAgICBhdXRoID0gYXV0aC5zcGxpdChuQUMpLmpvaW4oZW5jb2RlVVJJQ29tcG9uZW50KG5BQykpO1xuICAgIH1cbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIGhvc3QgPSAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkgPyBhdXRoICsgb2JqLmhvc3QgOlxuICAgICAgICAgIG9iai5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkID8gKFxuICAgICAgICAgICAgICBhdXRoICsgb2JqLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgKG9iai5wb3J0ID8gJzonICsgb2JqLnBvcnQgOiAnJylcbiAgICAgICAgICApIDpcbiAgICAgICAgICBmYWxzZSxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgcXVlcnkgPSBvYmoucXVlcnkgJiZcbiAgICAgICAgICAgICAgKCh0eXBlb2Ygb2JqLnF1ZXJ5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIG9iamVjdEtleXMob2JqLnF1ZXJ5KS5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9iai5xdWVyeSkgOlxuICAgICAgICAgICAgICAgICAnJykgfHwgJycsXG4gICAgICBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJyxcbiAgICAgIGhhc2ggPSBvYmouaGFzaCB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIGFycmF5SW5kZXhPZihzb3VyY2UuaG9zdCwgJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBhcnJheUluZGV4T2Yoc291cmNlLmhvc3QsICdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgb3V0Lmhvc3RuYW1lID0gaG9zdDtcbiAgcmV0dXJuIG91dDtcbn1cbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJ307XG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nfTtcblxuXG5leHBvcnRzLnByaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnB1dHMgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmluc3BlY3QgPSBmdW5jdGlvbihvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIHNlZW4gPSBbXTtcblxuICB2YXIgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gICAgdmFyIHN0eWxlcyA9XG4gICAgICAgIHsgJ2JvbGQnIDogWzEsIDIyXSxcbiAgICAgICAgICAnaXRhbGljJyA6IFszLCAyM10sXG4gICAgICAgICAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAgICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICAgJ3doaXRlJyA6IFszNywgMzldLFxuICAgICAgICAgICdncmV5JyA6IFs5MCwgMzldLFxuICAgICAgICAgICdibGFjaycgOiBbMzAsIDM5XSxcbiAgICAgICAgICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgICAgICAgICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgICAgICAgICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICAgICAgICAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICAgICAgICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAgICAgICAneWVsbG93JyA6IFszMywgMzldIH07XG5cbiAgICB2YXIgc3R5bGUgPVxuICAgICAgICB7ICdzcGVjaWFsJzogJ2N5YW4nLFxuICAgICAgICAgICdudW1iZXInOiAnYmx1ZScsXG4gICAgICAgICAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgICAgICAgICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAgICAgICAgICdudWxsJzogJ2JvbGQnLFxuICAgICAgICAgICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAgICAgICAgICdkYXRlJzogJ21hZ2VudGEnLFxuICAgICAgICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgICAgICAgJ3JlZ2V4cCc6ICdyZWQnIH1bc3R5bGVUeXBlXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICAgJ1xcMDMzWycgKyBzdHlsZXNbc3R5bGVdWzFdICsgJ20nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEgY29sb3JzKSB7XG4gICAgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7IHJldHVybiBzdHI7IH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlICE9PSBleHBvcnRzICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciB2aXNpYmxlX2tleXMgPSBPYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSBzaG93SGlkZGVuID8gT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXModmFsdWUpIDogdmlzaWJsZV9rZXlzO1xuXG4gICAgLy8gRnVuY3Rpb25zIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGF0ZXMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZFxuICAgIGlmIChpc0RhdGUodmFsdWUpICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSh2YWx1ZS50b1VUQ1N0cmluZygpLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCB0eXBlLCBicmFjZXM7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdBcnJheSc7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ09iamVjdCc7XG4gICAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gKGlzUmVnRXhwKHZhbHVlKSkgPyAnICcgKyB2YWx1ZSA6ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIHZhbHVlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICB2YXIgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbmFtZSwgc3RyO1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVfa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gICAgfSk7XG5cbiAgICBzZWVuLnBvcCgpO1xuXG4gICAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgIG51bUxpbmVzRXN0Kys7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGxlbmd0aCA+IDUwKSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBicmFjZXNbMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAoYXIgJiYgYXIgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgaXNBcnJheShhci5fX3Byb3RvX18pKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gcmUgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAodHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmUpID09PSAnW29iamVjdCBSZWdFeHBdJyk7XG59XG5cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBkICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvcGVydGllcyA9IERhdGUucHJvdG90eXBlICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKERhdGUucHJvdG90eXBlKTtcbiAgdmFyIHByb3RvID0gZC5fX3Byb3RvX18gJiYgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMoZC5fX3Byb3RvX18pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvdG8pID09PSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge307XG5cbmV4cG9ydHMucHVtcCA9IG51bGw7XG5cbnZhciBPYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgT2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIC8vIGZyb20gZXM1LXNoaW1cbiAgICB2YXIgb2JqZWN0O1xuICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0ID0geyAnX19wcm90b19fJyA6IG51bGwgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAndHlwZW9mIHByb3RvdHlwZVsnICsgKHR5cGVvZiBwcm90b3R5cGUpICsgJ10gIT0gXFwnb2JqZWN0XFwnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3RfY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goZXhwb3J0cy5pbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzogcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKXtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgZXhwb3J0cy5pbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyZWFtLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UsIGFuZFxuICAvLyBvbmx5IHdoZW4gYWxsIHNvdXJjZXMgaGF2ZSBlbmRlZC5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgZGVzdC5fcGlwZUNvdW50ID0gZGVzdC5fcGlwZUNvdW50IHx8IDA7XG4gICAgZGVzdC5fcGlwZUNvdW50Kys7XG5cbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5fcGlwZUNvdW50LS07XG5cbiAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyc1xuICAgIGNsZWFudXAoKTtcblxuICAgIGlmIChkZXN0Ll9waXBlQ291bnQgPiAwKSB7XG4gICAgICAvLyB3YWl0aW5nIGZvciBvdGhlciBpbmNvbWluZyBzdHJlYW1zIHRvIGVuZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuX3BpcGVDb3VudC0tO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnNcbiAgICBjbGVhbnVwKCk7XG5cbiAgICBpZiAoZGVzdC5fcGlwZUNvdW50ID4gMCkge1xuICAgICAgLy8gd2FpdGluZyBmb3Igb3RoZXIgaW5jb21pbmcgc3RyZWFtcyB0byBlbmQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIlxuLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcoKSByZWYgZm9yIHN0cmluZ2lmeSgpLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQXJyYXkjaW5kZXhPZiBzaGltLlxuICovXG5cbnZhciBpbmRleE9mID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBlbCkgeyByZXR1cm4gYXJyLmluZGV4T2YoZWwpOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gZWwpIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkuaXNBcnJheSBzaGltLlxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBzaGltLlxuICovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgcmV0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXJyYXkjZm9yRWFjaCBzaGltLlxuICovXG5cbnZhciBmb3JFYWNoID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBmbikgeyByZXR1cm4gYXJyLmZvckVhY2goZm4pOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBmbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSk7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheSNyZWR1Y2Ugc2hpbS5cbiAqL1xuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCkge1xuICBpZiAodHlwZW9mIGFyci5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsKTtcbiAgdmFyIHJlcyA9IGluaXRpYWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSByZXMgPSBmbihyZXMsIGFycltpXSk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBpc2ludCA9IC9eWzAtOV0rJC87XG5cbmZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgaWYgKHBhcmVudFtrZXldLmxlbmd0aCA9PSAwKSByZXR1cm4gcGFyZW50W2tleV0gPSB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICBwYXJlbnRba2V5XSA9IHQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBwYXJzZShwYXJ0cywgcGFyZW50LCBrZXksIHZhbCkge1xuICB2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gIC8vIGVuZFxuICBpZiAoIXBhcnQpIHtcbiAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgIHBhcmVudFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgLy8gYXJyYXlcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2JqID0gcGFyZW50W2tleV0gPSBwYXJlbnRba2V5XSB8fCBbXTtcbiAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKCcnICE9IHZhbCkgb2JqLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICBvYmpbb2JqZWN0S2V5cyhvYmopLmxlbmd0aF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3BcbiAgICB9IGVsc2UgaWYgKH5pbmRleE9mKHBhcnQsICddJykpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnN1YnN0cigwLCBwYXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgICAgLy8ga2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBwYXJlbnQga2V5L3ZhbCBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHBhcmVudCwga2V5LCB2YWwpe1xuICBpZiAofmluZGV4T2Yoa2V5LCAnXScpKSB7XG4gICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICwgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAsIGxhc3QgPSBsZW4gLSAxO1xuICAgIHBhcnNlKHBhcnRzLCBwYXJlbnQsICdiYXNlJywgdmFsKTtcbiAgICAvLyBvcHRpbWl6ZVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiBwYXJlbnQuYmFzZSkgdFtrXSA9IHBhcmVudC5iYXNlW2tdO1xuICAgICAgcGFyZW50LmJhc2UgPSB0O1xuICAgIH1cbiAgICBzZXQocGFyZW50LmJhc2UsIGtleSwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuICBmb3JFYWNoKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgbWVyZ2UocmV0LCBuYW1lLCBvYmpbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHJldC5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBzdHIuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKXtcbiAgcmV0dXJuIHJlZHVjZShTdHJpbmcoc3RyKS5zcGxpdCgnJicpLCBmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgIHZhciBlcWwgPSBpbmRleE9mKHBhaXIsICc9JylcbiAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgLCBrZXkgPSBwYWlyLnN1YnN0cigwLCBicmFjZSB8fCBlcWwpXG4gICAgICAsIHZhbCA9IHBhaXIuc3Vic3RyKGJyYWNlIHx8IGVxbCwgcGFpci5sZW5ndGgpXG4gICAgICAsIHZhbCA9IHZhbC5zdWJzdHIoaW5kZXhPZih2YWwsICc9JykgKyAxLCB2YWwubGVuZ3RoKTtcblxuICAgIC8vID9mb29cbiAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcbiAgICBpZiAoJycgPT0ga2V5KSByZXR1cm4gcmV0O1xuXG4gICAgcmV0dXJuIG1lcmdlKHJldCwgZGVjb2RlKGtleSksIGRlY29kZSh2YWwpKTtcbiAgfSwgeyBiYXNlOiB7fSB9KS5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0cztcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldO1xufTtcblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcy5zY2hlbWUgPSAnaHR0cHMnO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKTtcbn0iLCIvLyB0b2RvXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCJ2YXIgaHR0cCA9IG1vZHVsZS5leHBvcnRzO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpO1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBpZiAoIXBhcmFtcy5ob3N0KSBwYXJhbXMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSB3aW5kb3cubG9jYXRpb24ucG9ydDtcbiAgICBpZiAoIXBhcmFtcy5zY2hlbWUpIHBhcmFtcy5zY2hlbWUgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7dmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMToge1xuICAgIGhleDogc2hhLmhleF9zaGExLFxuICAgIGJpbmFyeTogc2hhLmI2NF9zaGExLFxuICAgIGFzY2lpOiBzaGEuc3RyX3NoYTFcbiAgfSxcbiAgbWQ1OiB7XG4gICAgaGV4OiBtZDUuaGV4X21kNSxcbiAgICBiaW5hcnk6IG1kNS5iNjRfbWQ1LFxuICAgIGFzY2lpOiBtZDUuYW55X21kNVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgaWYoIWFsZ29yaXRobXNbYWxnXSlcbiAgICBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgdmFyIHMgPSAnJ1xuICB2YXIgX2FsZyA9IGFsZ29yaXRobXNbYWxnXVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHMgKz0gZGF0YVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gICAgICB2YXIgZm5cbiAgICAgIGlmKCEoZm4gPSBfYWxnW2VuY10pKVxuICAgICAgICBlcnJvcignZW5jb2Rpbmc6JywgZW5jICwgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBhbGdvcml0aG0nLCBhbGcpXG4gICAgICB2YXIgciA9IGZuKHMpXG4gICAgICBzID0gbnVsbCAvL25vdCBtZWFudCB0byB1c2UgdGhlIGhhc2ggYWZ0ZXIgeW91J3ZlIGNhbGxlZCBkaWdlc3QuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycik7IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlSG1hYydcbiwgJ2NyZWF0ZUN5cGhlcidcbiwgJ2NyZWF0ZUN5cGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURlZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuXG59KSgpIiwidHJ5IHtcbiAgICB2YXIgU3RyaW5nUHJlcCA9IHJlcXVpcmUoJ25vZGUtc3RyaW5ncHJlcCcpLlN0cmluZ1ByZXA7XG4gICAgdmFyIHRvVW5pY29kZSA9IHJlcXVpcmUoJ25vZGUtc3RyaW5ncHJlcCcpLnRvVW5pY29kZTtcbiAgICB2YXIgYyA9IGZ1bmN0aW9uKG4pIHtcblx0dmFyIHAgPSBuZXcgU3RyaW5nUHJlcChuKTtcblx0cmV0dXJuIGZ1bmN0aW9uKHMpIHtcblx0ICAgIHJldHVybiBwLnByZXBhcmUocyk7XG5cdH07XG4gICAgfTtcbiAgICB2YXIgbmFtZXByZXAgPSBjKCduYW1lcHJlcCcpO1xuICAgIHZhciBub2RlcHJlcCA9IGMoJ25vZGVwcmVwJyk7XG4gICAgdmFyIHJlc291cmNlcHJlcCA9IGMoJ3Jlc291cmNlcHJlcCcpO1xufSBjYXRjaChleCkge1xuICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBsb2FkIFN0cmluZ1ByZXAtMC4xLjAgYmluZGluZ3MuIFlvdSBtYXkgbmVlZCB0byBgbnBtIGluc3RhbGwgbm9kZS1zdHJpbmdwcmVwJ1wiKTtcbiAgICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbihhKSB7IHJldHVybiBhOyB9O1xuICAgIHZhciB0b0xvd2VyID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpOyB9O1xuICAgIHZhciB0b1VuaWNvZGUgPSBpZGVudGl0eTtcbiAgICB2YXIgbmFtZXByZXAgPSB0b0xvd2VyO1xuICAgIHZhciBub2RlcHJlcCA9IHRvTG93ZXI7XG4gICAgdmFyIHJlc291cmNlcHJlcCA9IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBKSUQoYSwgYiwgYykge1xuICAgIGlmIChhICYmIGIgPT0gbnVsbCAmJiBjID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZUpJRChhKTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgdGhpcy5zZXRVc2VyKGEpO1xuICAgICAgICB0aGlzLnNldERvbWFpbihiKTtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShjKTtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvcicpO1xufVxuXG5KSUQucHJvdG90eXBlLnBhcnNlSklEID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChzLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0VXNlcihzLnN1YnN0cigwLCBzLmluZGV4T2YoJ0AnKSkpO1xuICAgICAgICBzID0gcy5zdWJzdHIocy5pbmRleE9mKCdAJykgKyAxKTtcbiAgICB9XG4gICAgaWYgKHMuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShzLnN1YnN0cihzLmluZGV4T2YoJy8nKSArIDEpKTtcbiAgICAgICAgcyA9IHMuc3Vic3RyKDAsIHMuaW5kZXhPZignLycpKTtcbiAgICB9XG4gICAgdGhpcy5zZXREb21haW4ocyk7XG59O1xuXG5KSUQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSB0aGlzLmRvbWFpbjtcbiAgICBpZiAodGhpcy51c2VyKVxuICAgICAgICBzID0gdGhpcy51c2VyICsgJ0AnICsgcztcbiAgICBpZiAodGhpcy5yZXNvdXJjZSlcbiAgICAgICAgcyA9IHMgKyAnLycgKyB0aGlzLnJlc291cmNlO1xuICAgIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gZGlzdGluZ3Vpc2ggdXNlcnNcbiAqKi9cbkpJRC5wcm90b3R5cGUuYmFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlc291cmNlKVxuICAgICAgICByZXR1cm4gbmV3IEpJRCh0aGlzLnVzZXIsIHRoaXMuZG9tYWluLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wYXJpc29uIGZ1bmN0aW9uXG4gKiovXG5KSUQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlciA9PSBvdGhlci51c2VyICYmXG4gICAgICAgIHRoaXMuZG9tYWluID09IG90aGVyLmRvbWFpbiAmJlxuICAgICAgICB0aGlzLnJlc291cmNlID09IG90aGVyLnJlc291cmNlO1xufTtcblxuLyoqXG4gKiBTZXR0ZXJzIHRoYXQgZG8gc3RyaW5ncHJlcCBub3JtYWxpemF0aW9uLlxuICoqL1xuSklELnByb3RvdHlwZS5zZXRVc2VyID0gZnVuY3Rpb24odXNlcikge1xuICAgIHRoaXMudXNlciA9IHVzZXIgJiYgbm9kZXByZXAodXNlcik7XG59O1xuLyoqXG4gKiBodHRwOi8veG1wcC5vcmcvcmZjcy9yZmM2MTIyLmh0bWwjYWRkcmVzc2luZy1kb21haW5cbiAqL1xuSklELnByb3RvdHlwZS5zZXREb21haW4gPSBmdW5jdGlvbihkb21haW4pIHtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbiAmJlxuICAgICAgICBuYW1lcHJlcChkb21haW4uc3BsaXQoXCIuXCIpLlxuICAgICAgICAgICAgICAgICBtYXAodG9Vbmljb2RlKS5cbiAgICAgICAgICAgICAgICAgam9pbihcIi5cIikpO1xufTtcbkpJRC5wcm90b3R5cGUuc2V0UmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZSAmJiByZXNvdXJjZXByZXAocmVzb3VyY2UpO1xufTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIGV4cG9ydHMgIT09IG51bGwpIHtcbiAgZXhwb3J0cy5KSUQgPSBKSUQ7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gIHdpbmRvdy5KSUQgPSBKSUQ7XG59XG4iLCIoZnVuY3Rpb24oKXsvLyBVVElMSVRZXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG59O1xudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gW3RoaXMubmFtZSArICc6JywgdGhpcy5tZXNzYWdlXS5qb2luKCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMubmFtZSArICc6JyxcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuYWN0dWFsLCByZXBsYWNlciksIDEyOCksXG4gICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkodGhpcy5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvci5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCBndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCEhIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICYmIEJ1ZmZlci5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKCdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKCdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG59KSgpIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gQ29weXJpZ2h0IDIwMTAtMjAxMiBNaWtlYWwgUm9nZXJzXG4vL1xuLy8gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuICAsIGh0dHBzID0gZmFsc2VcbiAgLCB0bHMgPSBmYWxzZVxuICAsIHVybCA9IHJlcXVpcmUoJ3VybCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG4gICwgcXMgPSByZXF1aXJlKCdxcycpXG4gICwgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG4gICwgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuICAsIG9hdXRoID0gcmVxdWlyZSgnb2F1dGgtc2lnbicpXG4gICwgaGF3ayA9IHJlcXVpcmUoJ2hhd2snKVxuICAsIGF3cyA9IHJlcXVpcmUoJ2F3cy1zaWduJylcbiAgLCBodHRwU2lnbmF0dXJlID0gcmVxdWlyZSgnaHR0cC1zaWduYXR1cmUnKVxuICAsIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKVxuICAsIG1pbWUgPSByZXF1aXJlKCdtaW1lJylcbiAgLCB0dW5uZWwgPSByZXF1aXJlKCd0dW5uZWwtYWdlbnQnKVxuICAsIHNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0cmluZ2lmeS1zYWZlJylcblxuICAsIEZvcmV2ZXJBZ2VudCA9IHJlcXVpcmUoJ2ZvcmV2ZXItYWdlbnQnKVxuICAsIEZvcm1EYXRhID0gcmVxdWlyZSgnZm9ybS1kYXRhJylcblxuICAsIENvb2tpZSA9IHJlcXVpcmUoJ2Nvb2tpZS1qYXInKVxuICAsIENvb2tpZUphciA9IENvb2tpZS5KYXJcbiAgLCBjb29raWVKYXIgPSBuZXcgQ29va2llSmFyXG4gIDtcblxudHJ5IHtcbiAgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG59IGNhdGNoIChlKSB7fVxuXG50cnkge1xuICB0bHMgPSByZXF1aXJlKCd0bHMnKVxufSBjYXRjaCAoZSkge31cblxudmFyIGRlYnVnXG5pZiAoL1xcYnJlcXVlc3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSRVFVRVNUICVzJywgdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9XG59XG5cbmZ1bmN0aW9uIHRvQmFzZTY0IChzdHIpIHtcbiAgcmV0dXJuIChuZXcgQnVmZmVyKHN0ciB8fCBcIlwiLCBcImFzY2lpXCIpKS50b1N0cmluZyhcImJhc2U2NFwiKVxufVxuXG5mdW5jdGlvbiBtZDUgKHN0cikge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnaGV4Jylcbn1cblxuLy8gSGFja3kgZml4IGZvciBwcmUtMC40LjQgaHR0cHNcbmlmIChodHRwcyAmJiAhaHR0cHMuQWdlbnQpIHtcbiAgaHR0cHMuQWdlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGh0dHAuQWdlbnQuY2FsbCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIHV0aWwuaW5oZXJpdHMoaHR0cHMuQWdlbnQsIGh0dHAuQWdlbnQpXG4gIGh0dHBzLkFnZW50LnByb3RvdHlwZS5fZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChob3N0LCBwb3J0LCBjYikge1xuICAgIHZhciBzID0gdGxzLmNvbm5lY3QocG9ydCwgaG9zdCwgdGhpcy5vcHRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkbyBvdGhlciBjaGVja3MgaGVyZT9cbiAgICAgIGlmIChjYikgY2IoKVxuICAgIH0pXG4gICAgcmV0dXJuIHNcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW0gKHJzKSB7XG4gIGlmIChycy5yZWFkYWJsZSAmJiBycy5wYXRoICYmIHJzLm1vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkgKG9iaikge1xuICB2YXIgbyA9IHt9XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIG9baV0gPSBvYmpbaV1cbiAgfSlcbiAgcmV0dXJuIG9cbn1cblxudmFyIGlzVXJsID0gL15odHRwcz86L1xuXG52YXIgZ2xvYmFsUG9vbCA9IHt9XG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgc3RyZWFtLlN0cmVhbS5jYWxsKHRoaXMpXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7dXJpOm9wdGlvbnN9XG4gIH1cblxuICB2YXIgcmVzZXJ2ZWQgPSBPYmplY3Qua2V5cyhSZXF1ZXN0LnByb3RvdHlwZSlcbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKHJlc2VydmVkLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICB0aGlzW2ldID0gb3B0aW9uc1tpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5tZXRob2QpIHtcbiAgICB0aGlzLmV4cGxpY2l0TWV0aG9kID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy5pbml0KG9wdGlvbnMpXG59XG51dGlsLmluaGVyaXRzKFJlcXVlc3QsIHN0cmVhbS5TdHJlYW0pXG5SZXF1ZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gaW5pdCgpIGNvbnRhaW5zIGFsbCB0aGUgY29kZSB0byBzZXR1cCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gIC8vIHRoZSBhY3R1YWwgb3V0Z29pbmcgcmVxdWVzdCBpcyBub3Qgc3RhcnRlZCB1bnRpbCBzdGFydCgpIGlzIGNhbGxlZFxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBvbiByZWRpcmVjdC5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKCFzZWxmLm1ldGhvZCkgc2VsZi5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJ1xuICBzZWxmLmxvY2FsQWRkcmVzcyA9IG9wdGlvbnMubG9jYWxBZGRyZXNzXG5cbiAgZGVidWcob3B0aW9ucylcbiAgaWYgKCFzZWxmLnBvb2wgJiYgc2VsZi5wb29sICE9PSBmYWxzZSkgc2VsZi5wb29sID0gZ2xvYmFsUG9vbFxuICBzZWxmLmRlc3RzID0gc2VsZi5kZXN0cyB8fCBbXVxuICBzZWxmLl9faXNSZXF1ZXN0UmVxdWVzdCA9IHRydWVcblxuICAvLyBQcm90ZWN0IGFnYWluc3QgZG91YmxlIGNhbGxiYWNrXG4gIGlmICghc2VsZi5fY2FsbGJhY2sgJiYgc2VsZi5jYWxsYmFjaykge1xuICAgIHNlbGYuX2NhbGxiYWNrID0gc2VsZi5jYWxsYmFja1xuICAgIHNlbGYuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fY2FsbGJhY2tDYWxsZWQpIHJldHVybiAvLyBQcmludCBhIHdhcm5pbmcgbWF5YmU/XG4gICAgICBzZWxmLl9jYWxsYmFja0NhbGxlZCA9IHRydWVcbiAgICAgIHNlbGYuX2NhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gICAgc2VsZi5vbignZXJyb3InLCBzZWxmLmNhbGxiYWNrLmJpbmQoKSlcbiAgICBzZWxmLm9uKCdjb21wbGV0ZScsIHNlbGYuY2FsbGJhY2suYmluZChzZWxmLCBudWxsKSlcbiAgfVxuXG4gIGlmIChzZWxmLnVybCAmJiAhc2VsZi51cmkpIHtcbiAgICAvLyBQZW9wbGUgdXNlIHRoaXMgcHJvcGVydHkgaW5zdGVhZCBhbGwgdGhlIHRpbWUgc28gd2h5IG5vdCBqdXN0IHN1cHBvcnQgaXQuXG4gICAgc2VsZi51cmkgPSBzZWxmLnVybFxuICAgIGRlbGV0ZSBzZWxmLnVybFxuICB9XG5cbiAgaWYgKCFzZWxmLnVyaSkge1xuICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBpZiB1bmhhbmRsZWQgYnV0IGlzIGhhbmRsZWFibGUgd2hlbiBpbiBhIHJlZGlyZWN0XG4gICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJvcHRpb25zLnVyaSBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50XCIpKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygc2VsZi51cmkgPT0gXCJzdHJpbmdcIikgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkpXG4gIH1cblxuICBpZiAoc2VsZi5zdHJpY3RTU0wgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKHNlbGYucHJveHkpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYucHJveHkgPT0gJ3N0cmluZycpIHNlbGYucHJveHkgPSB1cmwucGFyc2Uoc2VsZi5wcm94eSlcblxuICAgIC8vIGRvIHRoZSBIVFRQIENPTk5FQ1QgZGFuY2UgdXNpbmcga29pY2hpay9ub2RlLXR1bm5lbFxuICAgIGlmIChodHRwLmdsb2JhbEFnZW50ICYmIHNlbGYudXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICB2YXIgdHVubmVsRm4gPSBzZWxmLnByb3h5LnByb3RvY29sID09PSBcImh0dHA6XCJcbiAgICAgICAgICAgICAgICAgICA/IHR1bm5lbC5odHRwc092ZXJIdHRwIDogdHVubmVsLmh0dHBzT3Zlckh0dHBzXG5cbiAgICAgIHZhciB0dW5uZWxPcHRpb25zID0geyBwcm94eTogeyBob3N0OiBzZWxmLnByb3h5Lmhvc3RuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcG9ydDogK3NlbGYucHJveHkucG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHByb3h5QXV0aDogc2VsZi5wcm94eS5hdXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgaGVhZGVyczogeyBIb3N0OiBzZWxmLnVyaS5ob3N0bmFtZSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYudXJpLnBvcnQgfHwgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVqZWN0VW5hdXRob3JpemVkOiBzZWxmLnJlamVjdFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIGNhOiB0aGlzLmNhIH1cblxuICAgICAgc2VsZi5hZ2VudCA9IHR1bm5lbEZuKHR1bm5lbE9wdGlvbnMpXG4gICAgICBzZWxmLnR1bm5lbCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoIXNlbGYudXJpLmhvc3QgfHwgIXNlbGYudXJpLnBhdGhuYW1lKSB7XG4gICAgLy8gSW52YWxpZCBVUkk6IGl0IG1heSBnZW5lcmF0ZSBsb3Qgb2YgYmFkIGVycm9ycywgbGlrZSBcIlR5cGVFcnJvcjogQ2Fubm90IGNhbGwgbWV0aG9kICdpbmRleE9mJyBvZiB1bmRlZmluZWRcIiBpbiBDb29raWVKYXJcbiAgICAvLyBEZXRlY3QgYW5kIHJlamVjdCBpdCBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgdmFyIGZhdWx0eVVyaSA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gICAgdmFyIG1lc3NhZ2UgPSAnSW52YWxpZCBVUkkgXCInICsgZmF1bHR5VXJpICsgJ1wiJ1xuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG9wdGlvbiA/IFRoaXMgY2FuIGJlIHRoZSBzaWduIG9mIGEgcmVkaXJlY3RcbiAgICAgIC8vIEFzIHRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSB1c2VyIGNhbm5vdCBkbyBhbnl0aGluZyAoaGUgZGlkbid0IGNhbGwgcmVxdWVzdCBkaXJlY3RseSB3aXRoIHRoaXMgVVJMKVxuICAgICAgLy8gaGUgc2hvdWxkIGJlIHdhcm5lZCB0aGF0IGl0IGNhbiBiZSBjYXVzZWQgYnkgYSByZWRpcmVjdGlvbiAoY2FuIHNhdmUgc29tZSBoYWlyKVxuICAgICAgbWVzc2FnZSArPSAnLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSBjcmFwcHkgcmVkaXJlY3Rpb24uJ1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKVxuICAgIHJldHVybiAvLyBUaGlzIGVycm9yIHdhcyBmYXRhbFxuICB9XG5cbiAgc2VsZi5fcmVkaXJlY3RzRm9sbG93ZWQgPSBzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCB8fCAwXG4gIHNlbGYubWF4UmVkaXJlY3RzID0gKHNlbGYubWF4UmVkaXJlY3RzICE9PSB1bmRlZmluZWQpID8gc2VsZi5tYXhSZWRpcmVjdHMgOiAxMFxuICBzZWxmLmZvbGxvd1JlZGlyZWN0ID0gKHNlbGYuZm9sbG93UmVkaXJlY3QgIT09IHVuZGVmaW5lZCkgPyBzZWxmLmZvbGxvd1JlZGlyZWN0IDogdHJ1ZVxuICBzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cyA9IChzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSA/IHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzIDogZmFsc2VcbiAgaWYgKHNlbGYuZm9sbG93UmVkaXJlY3QgfHwgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpXG4gICAgc2VsZi5yZWRpcmVjdHMgPSBzZWxmLnJlZGlyZWN0cyB8fCBbXVxuXG4gIHNlbGYuaGVhZGVycyA9IHNlbGYuaGVhZGVycyA/IGNvcHkoc2VsZi5oZWFkZXJzKSA6IHt9XG5cbiAgc2VsZi5zZXRIb3N0ID0gZmFsc2VcbiAgaWYgKCEoc2VsZi5oZWFkZXJzLmhvc3QgfHwgc2VsZi5oZWFkZXJzLkhvc3QpKSB7XG4gICAgc2VsZi5oZWFkZXJzLmhvc3QgPSBzZWxmLnVyaS5ob3N0bmFtZVxuICAgIGlmIChzZWxmLnVyaS5wb3J0KSB7XG4gICAgICBpZiAoICEoc2VsZi51cmkucG9ydCA9PT0gODAgJiYgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwOicpICYmXG4gICAgICAgICAgICEoc2VsZi51cmkucG9ydCA9PT0gNDQzICYmIHNlbGYudXJpLnByb3RvY29sID09PSAnaHR0cHM6JykgKVxuICAgICAgc2VsZi5oZWFkZXJzLmhvc3QgKz0gKCc6JytzZWxmLnVyaS5wb3J0KVxuICAgIH1cbiAgICBzZWxmLnNldEhvc3QgPSB0cnVlXG4gIH1cblxuICBzZWxmLmphcihzZWxmLl9qYXIgfHwgb3B0aW9ucy5qYXIpXG5cbiAgaWYgKCFzZWxmLnVyaS5wYXRobmFtZSkge3NlbGYudXJpLnBhdGhuYW1lID0gJy8nfVxuICBpZiAoIXNlbGYudXJpLnBvcnQpIHtcbiAgICBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT0gJ2h0dHA6Jykge3NlbGYudXJpLnBvcnQgPSA4MH1cbiAgICBlbHNlIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PSAnaHR0cHM6Jykge3NlbGYudXJpLnBvcnQgPSA0NDN9XG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBvcnQgPSBzZWxmLnByb3h5LnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnByb3h5Lmhvc3RuYW1lXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi51cmkucG9ydFxuICAgIHNlbGYuaG9zdCA9IHNlbGYudXJpLmhvc3RuYW1lXG4gIH1cblxuICBzZWxmLmNsaWVudEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGlmIChzZWxmLl9hYm9ydGVkKSByZXR1cm5cblxuICAgIGlmIChzZWxmLnJlcSAmJiBzZWxmLnJlcS5fcmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJ1xuICAgICAgICAmJiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlKSB7XG4gICAgICBzZWxmLmFnZW50ID0geyBhZGRSZXF1ZXN0OiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlLmJpbmQoc2VsZi5hZ2VudCkgfVxuICAgICAgc2VsZi5zdGFydCgpXG4gICAgICBzZWxmLnJlcS5lbmQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChzZWxmLnRpbWVvdXQgJiYgc2VsZi50aW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXRUaW1lcilcbiAgICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gIH1cblxuICBzZWxmLl9wYXJzZXJFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5yZXMpIHtcbiAgICAgIGlmICh0aGlzLnJlcy5yZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMucmVzLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2h0dHBNZXNzYWdlLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgIHNlbGYuZm9ybShvcHRpb25zLmZvcm0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5xcykgc2VsZi5xcyhvcHRpb25zLnFzKVxuXG4gIGlmIChzZWxmLnVyaS5wYXRoKSB7XG4gICAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aFxuICB9IGVsc2Uge1xuICAgIHNlbGYucGF0aCA9IHNlbGYudXJpLnBhdGhuYW1lICsgKHNlbGYudXJpLnNlYXJjaCB8fCBcIlwiKVxuICB9XG5cbiAgaWYgKHNlbGYucGF0aC5sZW5ndGggPT09IDApIHNlbGYucGF0aCA9ICcvJ1xuXG5cbiAgLy8gQXV0aCBtdXN0IGhhcHBlbiBsYXN0IGluIGNhc2Ugc2lnbmluZyBpcyBkZXBlbmRlbnQgb24gb3RoZXIgaGVhZGVyc1xuICBpZiAob3B0aW9ucy5vYXV0aCkge1xuICAgIHNlbGYub2F1dGgob3B0aW9ucy5vYXV0aClcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF3cykge1xuICAgIHNlbGYuYXdzKG9wdGlvbnMuYXdzKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGF3aykge1xuICAgIHNlbGYuaGF3ayhvcHRpb25zLmhhd2spXG4gIH1cblxuICBpZiAob3B0aW9ucy5odHRwU2lnbmF0dXJlKSB7XG4gICAgc2VsZi5odHRwU2lnbmF0dXJlKG9wdGlvbnMuaHR0cFNpZ25hdHVyZSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dGgpIHtcbiAgICBzZWxmLmF1dGgoXG4gICAgICAob3B0aW9ucy5hdXRoLnVzZXI9PT1cIlwiKSA/IG9wdGlvbnMuYXV0aC51c2VyIDogKG9wdGlvbnMuYXV0aC51c2VyIHx8IG9wdGlvbnMuYXV0aC51c2VybmFtZSApLFxuICAgICAgb3B0aW9ucy5hdXRoLnBhc3MgfHwgb3B0aW9ucy5hdXRoLnBhc3N3b3JkLFxuICAgICAgb3B0aW9ucy5hdXRoLnNlbmRJbW1lZGlhdGVseSlcbiAgfVxuXG4gIGlmIChzZWxmLnVyaS5hdXRoICYmICFzZWxmLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgIHZhciBhdXRoUGllY2VzID0gc2VsZi51cmkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihpdGVtKXsgcmV0dXJuIHF1ZXJ5c3RyaW5nLnVuZXNjYXBlKGl0ZW0pIH0pXG4gICAgc2VsZi5hdXRoKGF1dGhQaWVjZXNbMF0sIGF1dGhQaWVjZXMuc2xpY2UoMSkuam9pbignOicpLCB0cnVlKVxuICB9XG4gIGlmIChzZWxmLnByb3h5ICYmIHNlbGYucHJveHkuYXV0aCAmJiAhc2VsZi5oZWFkZXJzWydwcm94eS1hdXRob3JpemF0aW9uJ10gJiYgIXNlbGYudHVubmVsKSB7XG4gICAgc2VsZi5oZWFkZXJzWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBcIkJhc2ljIFwiICsgdG9CYXNlNjQoc2VsZi5wcm94eS5hdXRoLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gcXVlcnlzdHJpbmcudW5lc2NhcGUoaXRlbSl9KS5qb2luKCc6JykpXG4gIH1cblxuXG4gIGlmIChzZWxmLnByb3h5ICYmICFzZWxmLnR1bm5lbCkgc2VsZi5wYXRoID0gKHNlbGYudXJpLnByb3RvY29sICsgJy8vJyArIHNlbGYudXJpLmhvc3QgKyBzZWxmLnBhdGgpXG5cbiAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgIHNlbGYuanNvbihvcHRpb25zLmpzb24pXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tdWx0aXBhcnQpIHtcbiAgICBzZWxmLmJvdW5kYXJ5ID0gdXVpZCgpXG4gICAgc2VsZi5tdWx0aXBhcnQob3B0aW9ucy5tdWx0aXBhcnQpXG4gIH1cblxuICBpZiAoc2VsZi5ib2R5KSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzZWxmLmJvZHkpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLmJvZHkpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IHNlbGYuYm9keVtpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5ib2R5ID0gbmV3IEJ1ZmZlcihzZWxmLmJvZHkpXG4gICAgICAgIGxlbmd0aCA9IHNlbGYuYm9keS5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gc2VsZi5ib2R5Lmxlbmd0aFxuICAgIH1cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBpZighc2VsZi5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddICYmICFzZWxmLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10pXG4gICAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBsZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvciwgb3B0aW9ucy5ib2R5LicpXG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvY29sID0gc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwgPyBzZWxmLnByb3h5LnByb3RvY29sIDogc2VsZi51cmkucHJvdG9jb2xcbiAgICAsIGRlZmF1bHRNb2R1bGVzID0geydodHRwOic6aHR0cCwgJ2h0dHBzOic6aHR0cHN9XG4gICAgLCBodHRwTW9kdWxlcyA9IHNlbGYuaHR0cE1vZHVsZXMgfHwge31cbiAgICA7XG4gIHNlbGYuaHR0cE1vZHVsZSA9IGh0dHBNb2R1bGVzW3Byb3RvY29sXSB8fCBkZWZhdWx0TW9kdWxlc1twcm90b2NvbF1cblxuICBpZiAoIXNlbGYuaHR0cE1vZHVsZSkgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3RvY29sXCIpKVxuXG4gIGlmIChvcHRpb25zLmNhKSBzZWxmLmNhID0gb3B0aW9ucy5jYVxuXG4gIGlmICghc2VsZi5hZ2VudCkge1xuICAgIGlmIChvcHRpb25zLmFnZW50T3B0aW9ucykgc2VsZi5hZ2VudE9wdGlvbnMgPSBvcHRpb25zLmFnZW50T3B0aW9uc1xuXG4gICAgaWYgKG9wdGlvbnMuYWdlbnRDbGFzcykge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHByb3RvY29sID09PSAnaHR0cDonID8gRm9yZXZlckFnZW50IDogRm9yZXZlckFnZW50LlNTTFxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFnZW50Q2xhc3MgPSBzZWxmLmh0dHBNb2R1bGUuQWdlbnRcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5wb29sID09PSBmYWxzZSkge1xuICAgIHNlbGYuYWdlbnQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYWdlbnQgPSBzZWxmLmFnZW50IHx8IHNlbGYuZ2V0QWdlbnQoKVxuICAgIGlmIChzZWxmLm1heFNvY2tldHMpIHtcbiAgICAgIC8vIERvbid0IHVzZSBvdXIgcG9vbGluZyBpZiBub2RlIGhhcyB0aGUgcmVmYWN0b3JlZCBjbGllbnRcbiAgICAgIHNlbGYuYWdlbnQubWF4U29ja2V0cyA9IHNlbGYubWF4U29ja2V0c1xuICAgIH1cbiAgICBpZiAoc2VsZi5wb29sLm1heFNvY2tldHMpIHtcbiAgICAgIC8vIERvbid0IHVzZSBvdXIgcG9vbGluZyBpZiBub2RlIGhhcyB0aGUgcmVmYWN0b3JlZCBjbGllbnRcbiAgICAgIHNlbGYuYWdlbnQubWF4U29ja2V0cyA9IHNlbGYucG9vbC5tYXhTb2NrZXRzXG4gICAgfVxuICB9XG5cbiAgc2VsZi5vbigncGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAoc2VsZi5udGljayAmJiBzZWxmLl9zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHBpcGUgdG8gdGhpcyBzdHJlYW0gYWZ0ZXIgdGhlIG91dGJvdW5kIHJlcXVlc3QgaGFzIHN0YXJ0ZWQuXCIpXG4gICAgc2VsZi5zcmMgPSBzcmNcbiAgICBpZiAoaXNSZWFkU3RyZWFtKHNyYykpIHtcbiAgICAgIGlmICghc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSAmJiAhc2VsZi5oZWFkZXJzWydDb250ZW50LVR5cGUnXSlcbiAgICAgICAgc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG1pbWUubG9va3VwKHNyYy5wYXRoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzcmMuaGVhZGVycykge1xuICAgICAgICAgIGlmICghc2VsZi5oZWFkZXJzW2ldKSB7XG4gICAgICAgICAgICBzZWxmLmhlYWRlcnNbaV0gPSBzcmMuaGVhZGVyc1tpXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuX2pzb24gJiYgIXNlbGYuaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgIXNlbGYuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pXG4gICAgICAgIHNlbGYuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIGlmIChzcmMubWV0aG9kICYmICFzZWxmLmV4cGxpY2l0TWV0aG9kKSB7XG4gICAgICAgIHNlbGYubWV0aG9kID0gc3JjLm1ldGhvZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlbGYub24oJ3BpcGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gICBjb25zb2xlLmVycm9yKFwiWW91IGhhdmUgYWxyZWFkeSBwaXBlZCB0byB0aGlzIHN0cmVhbS4gUGlwZWluZyB0d2ljZSBpcyBsaWtlbHkgdG8gYnJlYWsgdGhlIHJlcXVlc3QuXCIpXG4gICAgLy8gfSlcbiAgfSlcblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fYWJvcnRlZCkgcmV0dXJuXG5cbiAgICBpZiAoc2VsZi5fZm9ybSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXJzKHNlbGYuX2Zvcm0uZ2V0SGVhZGVycygpKVxuICAgICAgc2VsZi5fZm9ybS5waXBlKHNlbGYpXG4gICAgfVxuICAgIGlmIChzZWxmLmJvZHkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHtcbiAgICAgICAgc2VsZi5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICBzZWxmLndyaXRlKHBhcnQpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLndyaXRlKHNlbGYuYm9keSlcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5kKClcbiAgICB9IGVsc2UgaWYgKHNlbGYucmVxdWVzdEJvZHlTdHJlYW0pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIm9wdGlvbnMucmVxdWVzdEJvZHlTdHJlYW0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHBhc3MgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHN0cmVhbS5waXBlLlwiKVxuICAgICAgc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbS5waXBlKHNlbGYpXG4gICAgfSBlbHNlIGlmICghc2VsZi5zcmMpIHtcbiAgICAgIGlmIChzZWxmLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdHlwZW9mIHNlbGYubWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSAwXG4gICAgICB9XG4gICAgICBzZWxmLmVuZCgpXG4gICAgfVxuICAgIHNlbGYubnRpY2sgPSB0cnVlXG4gIH0pXG59XG5cbi8vIE11c3QgY2FsbCB0aGlzIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgZnJvbSBodHRwcyB0byBodHRwIG9yIHZpY2UgdmVyc2Fcbi8vIEF0dGVtcHRzIHRvIGtlZXAgZXZlcnl0aGluZyBhcyBpZGVudGljYWwgYXMgcG9zc2libGUsIGJ1dCB1cGRhdGUgdGhlXG4vLyBodHRwTW9kdWxlLCBUdW5uZWxpbmcgYWdlbnQsIGFuZC9vciBGb3JldmVyIEFnZW50IGluIHVzZS5cblJlcXVlc3QucHJvdG90eXBlLl91cGRhdGVQcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm90b2NvbCA9IHNlbGYudXJpLnByb3RvY29sXG5cbiAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIC8vIHByZXZpb3VzbHkgd2FzIGRvaW5nIGh0dHAsIG5vdyBkb2luZyBodHRwc1xuICAgIC8vIGlmIGl0J3MgaHR0cHMsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0dW5uZWwgbm93LlxuICAgIGlmIChzZWxmLnByb3h5KSB7XG4gICAgICBzZWxmLnR1bm5lbCA9IHRydWVcbiAgICAgIHZhciB0dW5uZWxGbiA9IHNlbGYucHJveHkucHJvdG9jb2wgPT09ICdodHRwOidcbiAgICAgICAgICAgICAgICAgICA/IHR1bm5lbC5odHRwc092ZXJIdHRwIDogdHVubmVsLmh0dHBzT3Zlckh0dHBzXG4gICAgICB2YXIgdHVubmVsT3B0aW9ucyA9IHsgcHJveHk6IHsgaG9zdDogc2VsZi5wcm94eS5ob3N0bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHBvcnQ6ICtzZWxmLnByb3h5LnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBwcm94eUF1dGg6IHNlbGYucHJveHkuYXV0aCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVqZWN0VW5hdXRob3JpemVkOiBzZWxmLnJlamVjdFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIGNhOiBzZWxmLmNhIH1cbiAgICAgIHNlbGYuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2VsZi5odHRwTW9kdWxlID0gaHR0cHNcbiAgICBzd2l0Y2ggKHNlbGYuYWdlbnRDbGFzcykge1xuICAgICAgY2FzZSBGb3JldmVyQWdlbnQ6XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IEZvcmV2ZXJBZ2VudC5TU0xcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgaHR0cC5BZ2VudDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gaHR0cHMuQWdlbnRcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG5vdGhpbmcgd2UgY2FuIGRvLiAgSnVzdCBob3BlIGZvciB0aGUgYmVzdC5cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhbiBhZ2VudCwgd2UgbmVlZCB0byBnZXQgYSBuZXcgb25lLlxuICAgIGlmIChzZWxmLmFnZW50KSBzZWxmLmFnZW50ID0gc2VsZi5nZXRBZ2VudCgpXG5cbiAgfSBlbHNlIHtcbiAgICAvLyBwcmV2aW91c2x5IHdhcyBkb2luZyBodHRwcywgbm93IGRvaW5nIGh0dHBcbiAgICAvLyBzdG9wIGFueSB0dW5uZWxpbmcuXG4gICAgaWYgKHNlbGYudHVubmVsKSBzZWxmLnR1bm5lbCA9IGZhbHNlXG4gICAgc2VsZi5odHRwTW9kdWxlID0gaHR0cFxuICAgIHN3aXRjaCAoc2VsZi5hZ2VudENsYXNzKSB7XG4gICAgICBjYXNlIEZvcmV2ZXJBZ2VudC5TU0w6XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IEZvcmV2ZXJBZ2VudFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBodHRwcy5BZ2VudDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gaHR0cC5BZ2VudFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8uICBqdXN0IGhvcGUgZm9yIHRoZSBiZXN0XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlJ3MgYW4gYWdlbnQsIHRoZW4gZ2V0IGEgbmV3IG9uZS5cbiAgICBpZiAoc2VsZi5hZ2VudCkge1xuICAgICAgc2VsZi5hZ2VudCA9IG51bGxcbiAgICAgIHNlbGYuYWdlbnQgPSBzZWxmLmdldEFnZW50KClcbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBBZ2VudCA9IHRoaXMuYWdlbnRDbGFzc1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmICh0aGlzLmFnZW50T3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5hZ2VudE9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnNbaV0gPSB0aGlzLmFnZW50T3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5jYSkgb3B0aW9ucy5jYSA9IHRoaXMuY2FcbiAgaWYgKHR5cGVvZiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWRcblxuICBpZiAodGhpcy5jZXJ0ICYmIHRoaXMua2V5KSB7XG4gICAgb3B0aW9ucy5rZXkgPSB0aGlzLmtleVxuICAgIG9wdGlvbnMuY2VydCA9IHRoaXMuY2VydFxuICB9XG5cbiAgdmFyIHBvb2xLZXkgPSAnJ1xuXG4gIC8vIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMgYXJlIGluIGRpZmZlcmVudCBwb29sc1xuICBpZiAoQWdlbnQgIT09IHRoaXMuaHR0cE1vZHVsZS5BZ2VudCkge1xuICAgIHBvb2xLZXkgKz0gQWdlbnQubmFtZVxuICB9XG5cbiAgaWYgKCF0aGlzLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnQpIHtcbiAgICAvLyBub2RlIDAuNC54XG4gICAgb3B0aW9ucy5ob3N0ID0gdGhpcy5ob3N0XG4gICAgb3B0aW9ucy5wb3J0ID0gdGhpcy5wb3J0XG4gICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgcG9vbEtleSArPSB0aGlzLmhvc3QgKyAnOicgKyB0aGlzLnBvcnRcbiAgfVxuXG4gIC8vIGNhIG9wdGlvbiBpcyBvbmx5IHJlbGV2YW50IGlmIHByb3h5IG9yIGRlc3RpbmF0aW9uIGFyZSBodHRwc1xuICB2YXIgcHJveHkgPSB0aGlzLnByb3h5XG4gIGlmICh0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnKSBwcm94eSA9IHVybC5wYXJzZShwcm94eSlcbiAgdmFyIGlzSHR0cHMgPSAocHJveHkgJiYgcHJveHkucHJvdG9jb2wgPT09ICdodHRwczonKSB8fCB0aGlzLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcbiAgaWYgKGlzSHR0cHMpIHtcbiAgICBpZiAob3B0aW9ucy5jYSkge1xuICAgICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2FcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2VydClcbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jZXJ0LnRvU3RyaW5nKCdhc2NpaScpICsgb3B0aW9ucy5rZXkudG9TdHJpbmcoJ2FzY2lpJylcblxuICAgIGlmIChvcHRpb25zLmNpcGhlcnMpIHtcbiAgICAgIGlmIChwb29sS2V5KSBwb29sS2V5ICs9ICc6J1xuICAgICAgcG9vbEtleSArPSBvcHRpb25zLmNpcGhlcnNcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVPcHRpb25zKSB7XG4gICAgICBpZiAocG9vbEtleSkgcG9vbEtleSArPSAnOidcbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5zZWN1cmVPcHRpb25zXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwb29sS2V5ICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnQpIHtcbiAgICAvLyBub3QgZG9pbmcgYW55dGhpbmcgc3BlY2lhbC4gIFVzZSB0aGUgZ2xvYmFsQWdlbnRcbiAgICByZXR1cm4gdGhpcy5odHRwTW9kdWxlLmdsb2JhbEFnZW50XG4gIH1cblxuICAvLyB3ZSdyZSB1c2luZyBhIHN0b3JlZCBhZ2VudC4gIE1ha2Ugc3VyZSBpdCdzIHByb3RvY29sLXNwZWNpZmljXG4gIHBvb2xLZXkgPSB0aGlzLnVyaS5wcm90b2NvbCArIHBvb2xLZXlcblxuICAvLyBhbHJlYWR5IGdlbmVyYXRlZCBhbiBhZ2VudCBmb3IgdGhpcyBzZXR0aW5nXG4gIGlmICh0aGlzLnBvb2xbcG9vbEtleV0pIHJldHVybiB0aGlzLnBvb2xbcG9vbEtleV1cblxuICByZXR1cm4gdGhpcy5wb29sW3Bvb2xLZXldID0gbmV3IEFnZW50KG9wdGlvbnMpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFydCgpIGlzIGNhbGxlZCBvbmNlIHdlIGFyZSByZWFkeSB0byBzZW5kIHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3QuXG4gIC8vIHRoaXMgaXMgdXN1YWxseSBjYWxsZWQgb24gdGhlIGZpcnN0IHdyaXRlKCksIGVuZCgpIG9yIG9uIG5leHRUaWNrKClcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHJldHVyblxuXG4gIHNlbGYuX3N0YXJ0ZWQgPSB0cnVlXG4gIHNlbGYubWV0aG9kID0gc2VsZi5tZXRob2QgfHwgJ0dFVCdcbiAgc2VsZi5ocmVmID0gc2VsZi51cmkuaHJlZlxuXG4gIGlmIChzZWxmLnNyYyAmJiBzZWxmLnNyYy5zdGF0ICYmIHNlbGYuc3JjLnN0YXQuc2l6ZSAmJiAhc2VsZi5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddICYmICFzZWxmLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10pIHtcbiAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBzZWxmLnNyYy5zdGF0LnNpemVcbiAgfVxuICBpZiAoc2VsZi5fYXdzKSB7XG4gICAgc2VsZi5hd3Moc2VsZi5fYXdzLCB0cnVlKVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIG1ldGhvZCBuYW1lZCBhdXRoLCB3aGljaCBpcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmcm9tIHRoZSBodHRwLnJlcXVlc3RcbiAgLy8gYXV0aCBvcHRpb24uICBJZiB3ZSBkb24ndCByZW1vdmUgaXQsIHdlJ3JlIGdvbm5hIGhhdmUgYSBiYWQgdGltZS5cbiAgdmFyIHJlcU9wdGlvbnMgPSBjb3B5KHNlbGYpXG4gIGRlbGV0ZSByZXFPcHRpb25zLmF1dGhcblxuICBkZWJ1ZygnbWFrZSByZXF1ZXN0Jywgc2VsZi51cmkuaHJlZilcbiAgc2VsZi5yZXEgPSBzZWxmLmh0dHBNb2R1bGUucmVxdWVzdChyZXFPcHRpb25zLCBzZWxmLm9uUmVzcG9uc2UuYmluZChzZWxmKSlcblxuICBpZiAoc2VsZi50aW1lb3V0ICYmICFzZWxmLnRpbWVvdXRUaW1lcikge1xuICAgIHNlbGYudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnJlcS5hYm9ydCgpXG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIkVUSU1FRE9VVFwiKVxuICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZSlcbiAgICB9LCBzZWxmLnRpbWVvdXQpXG5cbiAgICAvLyBTZXQgYWRkaXRpb25hbCB0aW1lb3V0IG9uIHNvY2tldCAtIGluIGNhc2UgaWYgcmVtb3RlXG4gICAgLy8gc2VydmVyIGZyZWV6ZSBhZnRlciBzZW5kaW5nIGhlYWRlcnNcbiAgICBpZiAoc2VsZi5yZXEuc2V0VGltZW91dCkgeyAvLyBvbmx5IHdvcmtzIG9uIG5vZGUgMC42K1xuICAgICAgc2VsZi5yZXEuc2V0VGltZW91dChzZWxmLnRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYucmVxKSB7XG4gICAgICAgICAgc2VsZi5yZXEuYWJvcnQoKVxuICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiRVNPQ0tFVFRJTUVET1VUXCIpXG4gICAgICAgICAgZS5jb2RlID0gXCJFU09DS0VUVElNRURPVVRcIlxuICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc2VsZi5yZXEub24oJ2Vycm9yJywgc2VsZi5jbGllbnRFcnJvckhhbmRsZXIpXG4gIHNlbGYucmVxLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKVxuICB9KVxuICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIHNlbGYucmVxLmNvbm5lY3Rpb24gKSBzZWxmLnJlcS5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNlbGYuX3BhcnNlckVycm9ySGFuZGxlcilcbiAgfSlcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0Jywgc2VsZi5yZXEpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnb25SZXNwb25zZScsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncmVzcG9uc2UgZW5kJywgc2VsZi51cmkuaHJlZiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcbiAgfSk7XG5cbiAgaWYgKHJlc3BvbnNlLmNvbm5lY3Rpb24ubGlzdGVuZXJzKCdlcnJvcicpLmluZGV4T2Yoc2VsZi5fcGFyc2VyRXJyb3JIYW5kbGVyKSA9PT0gLTEpIHtcbiAgICByZXNwb25zZS5jb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgc2VsZi5fcGFyc2VyRXJyb3JIYW5kbGVyKVxuICB9XG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBzZWxmLnVyaS5ocmVmKVxuICAgIHJlc3BvbnNlLnJlc3VtZSgpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHNlbGYuX3BhdXNlZCkgcmVzcG9uc2UucGF1c2UoKVxuICBlbHNlIHJlc3BvbnNlLnJlc3VtZSgpXG5cbiAgc2VsZi5yZXNwb25zZSA9IHJlc3BvbnNlXG4gIHJlc3BvbnNlLnJlcXVlc3QgPSBzZWxmXG4gIHJlc3BvbnNlLnRvSlNPTiA9IHRvSlNPTlxuXG4gIC8vIFhYWCBUaGlzIGlzIGRpZmZlcmVudCBvbiAwLjEwLCBiZWNhdXNlIFNTTCBpcyBzdHJpY3QgYnkgZGVmYXVsdFxuICBpZiAoc2VsZi5odHRwTW9kdWxlID09PSBodHRwcyAmJlxuICAgICAgc2VsZi5zdHJpY3RTU0wgJiZcbiAgICAgICFyZXNwb25zZS5jbGllbnQuYXV0aG9yaXplZCkge1xuICAgIGRlYnVnKCdzdHJpY3Qgc3NsIGVycm9yJywgc2VsZi51cmkuaHJlZilcbiAgICB2YXIgc3NsRXJyID0gcmVzcG9uc2UuY2xpZW50LmF1dGhvcml6YXRpb25FcnJvclxuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NTTCBFcnJvcjogJysgc3NsRXJyKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzZWxmLnNldEhvc3QpIGRlbGV0ZSBzZWxmLmhlYWRlcnMuaG9zdFxuICBpZiAoc2VsZi50aW1lb3V0ICYmIHNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgdmFyIGFkZENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICBpZiAoc2VsZi5famFyKSBzZWxmLl9qYXIuYWRkKG5ldyBDb29raWUoY29va2llKSlcbiAgICBlbHNlIGNvb2tpZUphci5hZGQobmV3IENvb2tpZShjb29raWUpKVxuICB9XG5cbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSAmJiAoIXNlbGYuX2Rpc2FibGVDb29raWVzKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSkpIHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXS5mb3JFYWNoKGFkZENvb2tpZSlcbiAgICBlbHNlIGFkZENvb2tpZShyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10pXG4gIH1cblxuICB2YXIgcmVkaXJlY3RUbyA9IG51bGxcbiAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbikge1xuICAgIGRlYnVnKCdyZWRpcmVjdCcsIHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24pXG5cbiAgICBpZiAoc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICAgIHJlZGlyZWN0VG8gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG4gICAgfSBlbHNlIGlmIChzZWxmLmZvbGxvd1JlZGlyZWN0KSB7XG4gICAgICBzd2l0Y2ggKHNlbGYubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ1BBVENIJzpcbiAgICAgICAgY2FzZSAnUFVUJzpcbiAgICAgICAgY2FzZSAnUE9TVCc6XG4gICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgICAgLy8gRG8gbm90IGZvbGxvdyByZWRpcmVjdHNcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZGlyZWN0VG8gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PSA0MDEgJiYgc2VsZi5faGFzQXV0aCAmJiAhc2VsZi5fc2VudEF1dGgpIHtcbiAgICB2YXIgYXV0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXVxuICAgIHZhciBhdXRoVmVyYiA9IGF1dGhIZWFkZXIgJiYgYXV0aEhlYWRlci5zcGxpdCgnICcpWzBdXG4gICAgZGVidWcoJ3JlYXV0aCcsIGF1dGhWZXJiKVxuXG4gICAgc3dpdGNoIChhdXRoVmVyYikge1xuICAgICAgY2FzZSAnQmFzaWMnOlxuICAgICAgICBzZWxmLmF1dGgoc2VsZi5fdXNlciwgc2VsZi5fcGFzcywgdHJ1ZSlcbiAgICAgICAgcmVkaXJlY3RUbyA9IHNlbGYudXJpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ0RpZ2VzdCc6XG4gICAgICAgIC8vIFRPRE86IE1vcmUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgUkZDIDI2MTcuICBGb3IgcmVmZXJlbmNlOlxuICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE3I3NlY3Rpb24tM1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFnZGVyL2N1cmwvYmxvYi9tYXN0ZXIvbGliL2h0dHBfZGlnZXN0LmNcblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGF1dGhIZWFkZXIubWF0Y2goLyhbYS16MC05Xy1dKyk9XCIoW15cIl0rKVwiL2dpKVxuICAgICAgICB2YXIgY2hhbGxlbmdlID0ge31cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXFQb3MgPSBtYXRjaGVzW2ldLmluZGV4T2YoJz0nKVxuICAgICAgICAgIHZhciBrZXkgPSBtYXRjaGVzW2ldLnN1YnN0cmluZygwLCBlcVBvcylcbiAgICAgICAgICB2YXIgcXVvdGVkVmFsdWUgPSBtYXRjaGVzW2ldLnN1YnN0cmluZyhlcVBvcyArIDEpXG4gICAgICAgICAgY2hhbGxlbmdlW2tleV0gPSBxdW90ZWRWYWx1ZS5zdWJzdHJpbmcoMSwgcXVvdGVkVmFsdWUubGVuZ3RoIC0gMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYTEgPSBtZDUoc2VsZi5fdXNlciArICc6JyArIGNoYWxsZW5nZS5yZWFsbSArICc6JyArIHNlbGYuX3Bhc3MpXG4gICAgICAgIHZhciBoYTIgPSBtZDUoc2VsZi5tZXRob2QgKyAnOicgKyBzZWxmLnVyaS5wYXRoKVxuICAgICAgICB2YXIgZGlnZXN0UmVzcG9uc2UgPSBtZDUoaGExICsgJzonICsgY2hhbGxlbmdlLm5vbmNlICsgJzoxOjphdXRoOicgKyBoYTIpXG4gICAgICAgIHZhciBhdXRoVmFsdWVzID0ge1xuICAgICAgICAgIHVzZXJuYW1lOiBzZWxmLl91c2VyLFxuICAgICAgICAgIHJlYWxtOiBjaGFsbGVuZ2UucmVhbG0sXG4gICAgICAgICAgbm9uY2U6IGNoYWxsZW5nZS5ub25jZSxcbiAgICAgICAgICB1cmk6IHNlbGYudXJpLnBhdGgsXG4gICAgICAgICAgcW9wOiBjaGFsbGVuZ2UucW9wLFxuICAgICAgICAgIHJlc3BvbnNlOiBkaWdlc3RSZXNwb25zZSxcbiAgICAgICAgICBuYzogMSxcbiAgICAgICAgICBjbm9uY2U6ICcnXG4gICAgICAgIH1cblxuICAgICAgICBhdXRoSGVhZGVyID0gW11cbiAgICAgICAgZm9yICh2YXIgayBpbiBhdXRoVmFsdWVzKSB7XG4gICAgICAgICAgYXV0aEhlYWRlci5wdXNoKGsgKyAnPVwiJyArIGF1dGhWYWx1ZXNba10gKyAnXCInKVxuICAgICAgICB9XG4gICAgICAgIGF1dGhIZWFkZXIgPSAnRGlnZXN0ICcgKyBhdXRoSGVhZGVyLmpvaW4oJywgJylcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyKVxuICAgICAgICBzZWxmLl9zZW50QXV0aCA9IHRydWVcblxuICAgICAgICByZWRpcmVjdFRvID0gc2VsZi51cmlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAocmVkaXJlY3RUbykge1xuICAgIGRlYnVnKCdyZWRpcmVjdCB0bycsIHJlZGlyZWN0VG8pXG5cbiAgICAvLyBpZ25vcmUgYW55IHBvdGVudGlhbCByZXNwb25zZSBib2R5LiAgaXQgY2Fubm90IHBvc3NpYmx5IGJlIHVzZWZ1bFxuICAgIC8vIHRvIHVzIGF0IHRoaXMgcG9pbnQuXG4gICAgaWYgKHNlbGYuX3BhdXNlZCkgcmVzcG9uc2UucmVzdW1lKClcblxuICAgIGlmIChzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCA+PSBzZWxmLm1heFJlZGlyZWN0cykge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heFJlZGlyZWN0cy4gUHJvYmFibHkgc3R1Y2sgaW4gYSByZWRpcmVjdCBsb29wIFwiK3NlbGYudXJpLmhyZWYpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlbGYuX3JlZGlyZWN0c0ZvbGxvd2VkICs9IDFcblxuICAgIGlmICghaXNVcmwudGVzdChyZWRpcmVjdFRvKSkge1xuICAgICAgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHNlbGYudXJpLmhyZWYsIHJlZGlyZWN0VG8pXG4gICAgfVxuXG4gICAgdmFyIHVyaVByZXYgPSBzZWxmLnVyaVxuICAgIHNlbGYudXJpID0gdXJsLnBhcnNlKHJlZGlyZWN0VG8pXG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgY2hhbmdlIHByb3RvY29sIGZyb20gaHR0cHMgdG8gaHR0cCBvciB2aWNlIHZlcnNhXG4gICAgaWYgKHNlbGYudXJpLnByb3RvY29sICE9PSB1cmlQcmV2LnByb3RvY29sKSB7XG4gICAgICBzZWxmLl91cGRhdGVQcm90b2NvbCgpXG4gICAgfVxuXG4gICAgc2VsZi5yZWRpcmVjdHMucHVzaChcbiAgICAgIHsgc3RhdHVzQ29kZSA6IHJlc3BvbnNlLnN0YXR1c0NvZGVcbiAgICAgICwgcmVkaXJlY3RVcmk6IHJlZGlyZWN0VG9cbiAgICAgIH1cbiAgICApXG4gICAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gNDAxKSBzZWxmLm1ldGhvZCA9ICdHRVQnXG4gICAgLy8gc2VsZi5tZXRob2QgPSAnR0VUJyAvLyBGb3JjZSBhbGwgcmVkaXJlY3RzIHRvIHVzZSBHRVQgfHwgY29tbWVudGVkIG91dCBmaXhlcyAjMjE1XG4gICAgZGVsZXRlIHNlbGYuc3JjXG4gICAgZGVsZXRlIHNlbGYucmVxXG4gICAgZGVsZXRlIHNlbGYuYWdlbnRcbiAgICBkZWxldGUgc2VsZi5fc3RhcnRlZFxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9IDQwMSkge1xuICAgICAgLy8gUmVtb3ZlIHBhcmFtZXRlcnMgZnJvbSB0aGUgcHJldmlvdXMgcmVzcG9uc2UsIHVubGVzcyB0aGlzIGlzIHRoZSBzZWNvbmQgcmVxdWVzdFxuICAgICAgLy8gZm9yIGEgc2VydmVyIHRoYXQgcmVxdWlyZXMgZGlnZXN0IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgZGVsZXRlIHNlbGYuYm9keVxuICAgICAgZGVsZXRlIHNlbGYuX2Zvcm1cbiAgICAgIGlmIChzZWxmLmhlYWRlcnMpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuaGVhZGVycy5ob3N0XG4gICAgICAgIGRlbGV0ZSBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICAgIGRlbGV0ZSBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3JlZGlyZWN0Jyk7XG5cbiAgICBzZWxmLmluaXQoKVxuICAgIHJldHVybiAvLyBJZ25vcmUgdGhlIHJlc3Qgb2YgdGhlIHJlc3BvbnNlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fcmVkaXJlY3RzRm9sbG93ZWQgPSBzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCB8fCAwXG4gICAgLy8gQmUgYSBnb29kIHN0cmVhbSBhbmQgZW1pdCBlbmQgd2hlbiB0aGUgcmVzcG9uc2UgaXMgZmluaXNoZWQuXG4gICAgLy8gSGFjayB0byBlbWl0IGVuZCBvbiBjbG9zZSBiZWNhdXNlIG9mIGEgY29yZSBidWcgdGhhdCBuZXZlciBmaXJlcyBlbmRcbiAgICByZXNwb25zZS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuX2VuZGVkKSBzZWxmLnJlc3BvbnNlLmVtaXQoJ2VuZCcpXG4gICAgfSlcblxuICAgIGlmIChzZWxmLmVuY29kaW5nKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIklnbm9yaW5nIGVuY29kaW5nIHBhcmFtZXRlciBhcyB0aGlzIHN0cmVhbSBpcyBiZWluZyBwaXBlZCB0byBhbm90aGVyIHN0cmVhbSB3aGljaCBtYWtlcyB0aGUgZW5jb2Rpbmcgb3B0aW9uIGludmFsaWQuXCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSlcblxuICAgIHNlbGYuZGVzdHMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgc2VsZi5waXBlRGVzdChkZXN0KVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzZWxmLl9kZXN0ZGF0YSA9IHRydWVcbiAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgY2h1bmspXG4gICAgfSlcbiAgICByZXNwb25zZS5vbihcImVuZFwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KFwiZW5kXCIsIGNodW5rKVxuICAgIH0pXG4gICAgcmVzcG9uc2Uub24oXCJjbG9zZVwiLCBmdW5jdGlvbiAoKSB7c2VsZi5lbWl0KFwiY2xvc2VcIil9KVxuXG4gICAgaWYgKHNlbGYuY2FsbGJhY2spIHtcbiAgICAgIHZhciBidWZmZXIgPSBbXVxuICAgICAgdmFyIGJvZHlMZW4gPSAwXG4gICAgICBzZWxmLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgYnVmZmVyLnB1c2goY2h1bmspXG4gICAgICAgIGJvZHlMZW4gKz0gY2h1bmsubGVuZ3RoXG4gICAgICB9KVxuICAgICAgc2VsZi5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdlbmQgZXZlbnQnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoICYmIEJ1ZmZlci5pc0J1ZmZlcihidWZmZXJbMF0pKSB7XG4gICAgICAgICAgZGVidWcoJ2hhcyBib2R5Jywgc2VsZi51cmkuaHJlZiwgYm9keUxlbilcbiAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoYm9keUxlbilcbiAgICAgICAgICB2YXIgaSA9IDBcbiAgICAgICAgICBidWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGNodW5rLmNvcHkoYm9keSwgaSwgMCwgY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgaSArPSBjaHVuay5sZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keS50b1N0cmluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIFVURjggQk9NIFsweEVGLDB4QkIsMHhCRl0gaXMgY29udmVydGVkIHRvIFsweEZFLDB4RkZdIGluIHRoZSBKUyBVVEMxNi9VQ1MyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgIC8vIFN0cmlwIHRoaXMgdmFsdWUgb3V0IHdoZW4gdGhlIGVuY29kaW5nIGlzIHNldCB0byAndXRmOCcsIGFzIHVwc3RyZWFtIGNvbnN1bWVycyB3b24ndCBleHBlY3QgaXQgYW5kIGl0IGJyZWFrcyBKU09OLnBhcnNlKCkuXG4gICAgICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBidWZmZXJbMF0ubGVuZ3RoID4gMCAmJiBidWZmZXJbMF1bMF0gPT09IFwiXFx1RkVGRlwiKSB7XG4gICAgICAgICAgICBidWZmZXJbMF0gPSBidWZmZXJbMF0uc3Vic3RyaW5nKDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBidWZmZXIuam9pbignJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9qc29uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnZW1pdHRpbmcgY29tcGxldGUnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICBpZihyZXNwb25zZS5ib2R5ID09IHVuZGVmaW5lZCAmJiAhc2VsZi5fanNvbikge1xuICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGRlYnVnKCdmaW5pc2ggaW5pdCBmdW5jdGlvbicsIHNlbGYudXJpLmhyZWYpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZVxuXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxLmFib3J0KClcbiAgfVxuICBlbHNlIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXNwb25zZS5hYm9ydCgpXG4gIH1cblxuICB0aGlzLmVtaXQoXCJhYm9ydFwiKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlRGVzdCA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2VcbiAgLy8gQ2FsbGVkIGFmdGVyIHRoZSByZXNwb25zZSBpcyByZWNlaXZlZFxuICBpZiAoZGVzdC5oZWFkZXJzKSB7XG4gICAgZGVzdC5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHtcbiAgICAgIGRlc3QuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICB9XG4gIH1cbiAgaWYgKGRlc3Quc2V0SGVhZGVyKSB7XG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICBkZXN0LnNldEhlYWRlcihpLCByZXNwb25zZS5oZWFkZXJzW2ldKVxuICAgIH1cbiAgICBkZXN0LnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlXG4gIH1cbiAgaWYgKHRoaXMucGlwZWZpbHRlcikgdGhpcy5waXBlZmlsdGVyKHJlc3BvbnNlLCBkZXN0KVxufVxuXG4vLyBDb21wb3NhYmxlIEFQSVxuUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjbG9iYmVyKSB7XG4gIGlmIChjbG9iYmVyID09PSB1bmRlZmluZWQpIGNsb2JiZXIgPSB0cnVlXG4gIGlmIChjbG9iYmVyIHx8ICF0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHRoaXMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gIGVsc2UgdGhpcy5oZWFkZXJzW25hbWVdICs9ICcsJyArIHZhbHVlXG4gIHJldHVybiB0aGlzXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgZm9yICh2YXIgaSBpbiBoZWFkZXJzKSB7dGhpcy5zZXRIZWFkZXIoaSwgaGVhZGVyc1tpXSl9XG4gIHJldHVybiB0aGlzXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5xcyA9IGZ1bmN0aW9uIChxLCBjbG9iYmVyKSB7XG4gIHZhciBiYXNlXG4gIGlmICghY2xvYmJlciAmJiB0aGlzLnVyaS5xdWVyeSkgYmFzZSA9IHFzLnBhcnNlKHRoaXMudXJpLnF1ZXJ5KVxuICBlbHNlIGJhc2UgPSB7fVxuXG4gIGZvciAodmFyIGkgaW4gcSkge1xuICAgIGJhc2VbaV0gPSBxW2ldXG4gIH1cblxuICBpZiAocXMuc3RyaW5naWZ5KGJhc2UpID09PSAnJyl7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoaXMudXJpID0gdXJsLnBhcnNlKHRoaXMudXJpLmhyZWYuc3BsaXQoJz8nKVswXSArICc/JyArIHFzLnN0cmluZ2lmeShiYXNlKSlcbiAgdGhpcy51cmwgPSB0aGlzLnVyaVxuICB0aGlzLnBhdGggPSB0aGlzLnVyaS5wYXRoXG5cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xuICBpZiAoZm9ybSkge1xuICAgIHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04J1xuICAgIHRoaXMuYm9keSA9IHFzLnN0cmluZ2lmeShmb3JtKS50b1N0cmluZygndXRmOCcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBjcmVhdGUgZm9ybS1kYXRhIG9iamVjdFxuICB0aGlzLl9mb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgcmV0dXJuIHRoaXMuX2Zvcm1cbn1cblJlcXVlc3QucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIChtdWx0aXBhcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuYm9keSA9IFtdXG5cbiAgaWYgKCFzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXS5zcGxpdCgnOycpWzBdICsgJzsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnlcbiAgfVxuXG4gIGlmICghbXVsdGlwYXJ0LmZvckVhY2gpIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgZXJyb3IsIG9wdGlvbnMubXVsdGlwYXJ0LicpXG5cbiAgaWYgKHNlbGYucHJlYW1ibGVDUkxGKSB7XG4gICAgc2VsZi5ib2R5LnB1c2gobmV3IEJ1ZmZlcignXFxyXFxuJykpXG4gIH1cblxuICBtdWx0aXBhcnQuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBib2R5ID0gcGFydC5ib2R5XG4gICAgaWYoYm9keSA9PSBudWxsKSB0aHJvdyBFcnJvcignQm9keSBhdHRyaWJ1dGUgbWlzc2luZyBpbiBtdWx0aXBhcnQuJylcbiAgICBkZWxldGUgcGFydC5ib2R5XG4gICAgdmFyIHByZWFtYmxlID0gJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnXFxyXFxuJ1xuICAgIE9iamVjdC5rZXlzKHBhcnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcHJlYW1ibGUgKz0ga2V5ICsgJzogJyArIHBhcnRba2V5XSArICdcXHJcXG4nXG4gICAgfSlcbiAgICBwcmVhbWJsZSArPSAnXFxyXFxuJ1xuICAgIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIocHJlYW1ibGUpKVxuICAgIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIoYm9keSkpXG4gICAgc2VsZi5ib2R5LnB1c2gobmV3IEJ1ZmZlcignXFxyXFxuJykpXG4gIH0pXG4gIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIoJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnLS0nKSlcbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNldEFjY2VwdEhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICBcdGlmICghc2VsZi5oZWFkZXJzWydhY2NlcHQnXSAmJiAhc2VsZi5oZWFkZXJzWydBY2NlcHQnXSkge1xuXHRcdFx0ICBzZWxmLnNldEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuXHRcdH1cblx0fVxuICBzZXRBY2NlcHRIZWFkZXIoKTtcbiAgdGhpcy5fanNvbiA9IHRydWVcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5ib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0QWNjZXB0SGVhZGVyKCk7XG4gICAgICB0aGlzLmJvZHkgPSBzYWZlU3RyaW5naWZ5KHRoaXMuYm9keSlcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEFjY2VwdEhlYWRlcigpO1xuICAgIHRoaXMuYm9keSA9IHNhZmVTdHJpbmdpZnkodmFsKVxuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcihuYW1lLCBoZWFkZXJzKSB7XG4gICAgdmFyIHJlc3VsdCwgcmUsIG1hdGNoXG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChuYW1lLCAnaScpXG4gICAgICAgIG1hdGNoID0ga2V5Lm1hdGNoKHJlKVxuICAgICAgICBpZiAobWF0Y2gpIHJlc3VsdCA9IGhlYWRlcnNba2V5XVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpIHtcbiAgaWYgKHR5cGVvZiB1c2VyICE9PSAnc3RyaW5nJyB8fCAocGFzcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXNzICE9PSAnc3RyaW5nJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGgoKSByZWNlaXZlZCBpbnZhbGlkIHVzZXIgb3IgcGFzc3dvcmQnKVxuICB9XG4gIHRoaXMuX3VzZXIgPSB1c2VyXG4gIHRoaXMuX3Bhc3MgPSBwYXNzXG4gIHRoaXMuX2hhc0F1dGggPSB0cnVlXG4gIGlmIChzZW5kSW1tZWRpYXRlbHkgfHwgdHlwZW9mIHNlbmRJbW1lZGlhdGVseSA9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyB0b0Jhc2U2NCh1c2VyICsgJzonICsgcGFzcykpXG4gICAgdGhpcy5fc2VudEF1dGggPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmF3cyA9IGZ1bmN0aW9uIChvcHRzLCBub3cpIHtcbiAgaWYgKCFub3cpIHtcbiAgICB0aGlzLl9hd3MgPSBvcHRzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKClcbiAgdGhpcy5zZXRIZWFkZXIoJ2RhdGUnLCBkYXRlLnRvVVRDU3RyaW5nKCkpXG4gIHZhciBhdXRoID1cbiAgICB7IGtleTogb3B0cy5rZXlcbiAgICAsIHNlY3JldDogb3B0cy5zZWNyZXRcbiAgICAsIHZlcmI6IHRoaXMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAsIGRhdGU6IGRhdGVcbiAgICAsIGNvbnRlbnRUeXBlOiBnZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIHRoaXMuaGVhZGVycykgfHwgJydcbiAgICAsIG1kNTogZ2V0SGVhZGVyKCdjb250ZW50LW1kNScsIHRoaXMuaGVhZGVycykgfHwgJydcbiAgICAsIGFtYXpvbkhlYWRlcnM6IGF3cy5jYW5vbmljYWxpemVIZWFkZXJzKHRoaXMuaGVhZGVycylcbiAgICB9XG4gIGlmIChvcHRzLmJ1Y2tldCAmJiB0aGlzLnBhdGgpIHtcbiAgICBhdXRoLnJlc291cmNlID0gJy8nICsgb3B0cy5idWNrZXQgKyB0aGlzLnBhdGhcbiAgfSBlbHNlIGlmIChvcHRzLmJ1Y2tldCAmJiAhdGhpcy5wYXRoKSB7XG4gICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0XG4gIH0gZWxzZSBpZiAoIW9wdHMuYnVja2V0ICYmIHRoaXMucGF0aCkge1xuICAgIGF1dGgucmVzb3VyY2UgPSB0aGlzLnBhdGhcbiAgfSBlbHNlIGlmICghb3B0cy5idWNrZXQgJiYgIXRoaXMucGF0aCkge1xuICAgIGF1dGgucmVzb3VyY2UgPSAnLydcbiAgfVxuICBhdXRoLnJlc291cmNlID0gYXdzLmNhbm9uaWNhbGl6ZVJlc291cmNlKGF1dGgucmVzb3VyY2UpXG4gIHRoaXMuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXdzLmF1dGhvcml6YXRpb24oYXV0aCkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmh0dHBTaWduYXR1cmUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmVxID0gdGhpc1xuICBodHRwU2lnbmF0dXJlLnNpZ25SZXF1ZXN0KHtcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGdldEhlYWRlcihoZWFkZXIsIHJlcS5oZWFkZXJzKVxuICAgIH0sXG4gICAgc2V0SGVhZGVyOiBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICByZXEuc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpXG4gICAgfSxcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHBhdGg6IHRoaXMucGF0aFxuICB9LCBvcHRzKVxuICBkZWJ1ZygnaHR0cFNpZ25hdHVyZSBhdXRob3JpemF0aW9uJywgZ2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgdGhpcy5oZWFkZXJzKSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXdrID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBoYXdrLmNsaWVudC5oZWFkZXIodGhpcy51cmksIHRoaXMubWV0aG9kLCBvcHRzKS5maWVsZFxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5vYXV0aCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIGZvcm1cbiAgaWYgKHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gJiZcbiAgICAgIHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10uc2xpY2UoMCwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcubGVuZ3RoKSA9PT1cbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgKSB7XG4gICAgZm9ybSA9IHFzLnBhcnNlKHRoaXMuYm9keSlcbiAgfVxuICBpZiAodGhpcy51cmkucXVlcnkpIHtcbiAgICBmb3JtID0gcXMucGFyc2UodGhpcy51cmkucXVlcnkpXG4gIH1cbiAgaWYgKCFmb3JtKSBmb3JtID0ge31cbiAgdmFyIG9hID0ge31cbiAgZm9yICh2YXIgaSBpbiBmb3JtKSBvYVtpXSA9IGZvcm1baV1cbiAgZm9yICh2YXIgaSBpbiBfb2F1dGgpIG9hWydvYXV0aF8nK2ldID0gX29hdXRoW2ldXG4gIGlmICghb2Eub2F1dGhfdmVyc2lvbikgb2Eub2F1dGhfdmVyc2lvbiA9ICcxLjAnXG4gIGlmICghb2Eub2F1dGhfdGltZXN0YW1wKSBvYS5vYXV0aF90aW1lc3RhbXAgPSBNYXRoLmZsb29yKCBEYXRlLm5vdygpIC8gMTAwMCApLnRvU3RyaW5nKClcbiAgaWYgKCFvYS5vYXV0aF9ub25jZSkgb2Eub2F1dGhfbm9uY2UgPSB1dWlkKCkucmVwbGFjZSgvLS9nLCAnJylcblxuICBvYS5vYXV0aF9zaWduYXR1cmVfbWV0aG9kID0gJ0hNQUMtU0hBMSdcblxuICB2YXIgY29uc3VtZXJfc2VjcmV0ID0gb2Eub2F1dGhfY29uc3VtZXJfc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF9jb25zdW1lcl9zZWNyZXRcbiAgdmFyIHRva2VuX3NlY3JldCA9IG9hLm9hdXRoX3Rva2VuX3NlY3JldFxuICBkZWxldGUgb2Eub2F1dGhfdG9rZW5fc2VjcmV0XG4gIHZhciB0aW1lc3RhbXAgPSBvYS5vYXV0aF90aW1lc3RhbXBcblxuICB2YXIgYmFzZXVybCA9IHRoaXMudXJpLnByb3RvY29sICsgJy8vJyArIHRoaXMudXJpLmhvc3QgKyB0aGlzLnVyaS5wYXRobmFtZVxuICB2YXIgc2lnbmF0dXJlID0gb2F1dGguaG1hY3NpZ24odGhpcy5tZXRob2QsIGJhc2V1cmwsIG9hLCBjb25zdW1lcl9zZWNyZXQsIHRva2VuX3NlY3JldClcblxuICAvLyBvYS5vYXV0aF9zaWduYXR1cmUgPSBzaWduYXR1cmVcbiAgZm9yICh2YXIgaSBpbiBmb3JtKSB7XG4gICAgaWYgKCBpLnNsaWNlKDAsICdvYXV0aF8nKSBpbiBfb2F1dGgpIHtcbiAgICAgIC8vIHNraXBcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9hWydvYXV0aF8nK2ldXG4gICAgICBpZiAoaSAhPT0gJ3hfYXV0aF9tb2RlJykgZGVsZXRlIG9hW2ldXG4gICAgfVxuICB9XG4gIG9hLm9hdXRoX3RpbWVzdGFtcCA9IHRpbWVzdGFtcFxuICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgJ09BdXRoICcrT2JqZWN0LmtleXMob2EpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGkpIHtyZXR1cm4gaSsnPVwiJytvYXV0aC5yZmMzOTg2KG9hW2ldKSsnXCInfSkuam9pbignLCcpXG4gIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uICs9ICcsb2F1dGhfc2lnbmF0dXJlPVwiJyArIG9hdXRoLnJmYzM5ODYoc2lnbmF0dXJlKSArICdcIidcbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmphciA9IGZ1bmN0aW9uIChqYXIpIHtcbiAgdmFyIGNvb2tpZXNcblxuICBpZiAodGhpcy5fcmVkaXJlY3RzRm9sbG93ZWQgPT09IDApIHtcbiAgICB0aGlzLm9yaWdpbmFsQ29va2llSGVhZGVyID0gdGhpcy5oZWFkZXJzLmNvb2tpZVxuICB9XG5cbiAgaWYgKGphciA9PT0gZmFsc2UpIHtcbiAgICAvLyBkaXNhYmxlIGNvb2tpZXNcbiAgICBjb29raWVzID0gZmFsc2VcbiAgICB0aGlzLl9kaXNhYmxlQ29va2llcyA9IHRydWVcbiAgfSBlbHNlIGlmIChqYXIpIHtcbiAgICAvLyBmZXRjaCBjb29raWUgZnJvbSB0aGUgdXNlciBkZWZpbmVkIGNvb2tpZSBqYXJcbiAgICBjb29raWVzID0gamFyLmdldCh7IHVybDogdGhpcy51cmkuaHJlZiB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGZldGNoIGNvb2tpZSBmcm9tIHRoZSBnbG9iYWwgY29va2llIGphclxuICAgIGNvb2tpZXMgPSBjb29raWVKYXIuZ2V0KHsgdXJsOiB0aGlzLnVyaS5ocmVmIH0pXG4gIH1cblxuICBpZiAoY29va2llcyAmJiBjb29raWVzLmxlbmd0aCkge1xuICAgIHZhciBjb29raWVTdHJpbmcgPSBjb29raWVzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMubmFtZSArIFwiPVwiICsgYy52YWx1ZVxuICAgIH0pLmpvaW4oXCI7IFwiKVxuXG4gICAgaWYgKHRoaXMub3JpZ2luYWxDb29raWVIZWFkZXIpIHtcbiAgICAgIC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBDb29raWUgaGVhZGVyXG4gICAgICB0aGlzLmhlYWRlcnMuY29va2llID0gdGhpcy5vcmlnaW5hbENvb2tpZUhlYWRlciArICc7ICcgKyBjb29raWVTdHJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzLmNvb2tpZSA9IGNvb2tpZVN0cmluZ1xuICAgIH1cbiAgfVxuICB0aGlzLl9qYXIgPSBqYXJcbiAgcmV0dXJuIHRoaXNcbn1cblxuXG4vLyBTdHJlYW0gQVBJXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIG9wdHMpIHtcbiAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICBpZiAodGhpcy5fZGVzdGRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgcGlwZSBhZnRlciBkYXRhIGhhcyBiZWVuIGVtaXR0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuXCIpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBwaXBlIGFmdGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBlbmRlZC5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLlN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICB0aGlzLnBpcGVEZXN0KGRlc3QpXG4gICAgICByZXR1cm4gZGVzdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlc3RzLnB1c2goZGVzdClcbiAgICBzdHJlYW0uU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwodGhpcywgZGVzdCwgb3B0cylcbiAgICByZXR1cm4gZGVzdFxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9zdGFydGVkKSB0aGlzLnN0YXJ0KClcbiAgcmV0dXJuIHRoaXMucmVxLndyaXRlLmFwcGx5KHRoaXMucmVxLCBhcmd1bWVudHMpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKGNodW5rKSB0aGlzLndyaXRlKGNodW5rKVxuICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHRoaXMuc3RhcnQoKVxuICB0aGlzLnJlcS5lbmQoKVxufVxuUmVxdWVzdC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5yZXNwb25zZSkgdGhpcy5fcGF1c2VkID0gdHJ1ZVxuICBlbHNlIHRoaXMucmVzcG9uc2UucGF1c2UuYXBwbHkodGhpcy5yZXNwb25zZSwgYXJndW1lbnRzKVxufVxuUmVxdWVzdC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucmVzcG9uc2UpIHRoaXMuX3BhdXNlZCA9IGZhbHNlXG4gIGVsc2UgdGhpcy5yZXNwb25zZS5yZXN1bWUuYXBwbHkodGhpcy5yZXNwb25zZSwgYXJndW1lbnRzKVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9lbmRlZCkgdGhpcy5lbmQoKVxuICBlbHNlIGlmICh0aGlzLnJlc3BvbnNlKSB0aGlzLnJlc3BvbnNlLmRlc3Ryb3koKVxufVxuXG4vLyBvcmdhbml6ZSBwYXJhbXMgZm9yIHBhdGNoLCBwb3N0LCBwdXQsIGhlYWQsIGRlbFxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpICYmICFjYWxsYmFjaykgY2FsbGJhY2sgPSBvcHRpb25zXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMudXJpID0gdXJpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge3VyaTp1cml9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHVyaVxuICAgIHVyaSA9IG9wdGlvbnMudXJpXG4gIH1cbiAgcmV0dXJuIHsgdXJpOiB1cmksIG9wdGlvbnM6IG9wdGlvbnMsIGNhbGxiYWNrOiBjYWxsYmFjayB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCB1cmkgb3Igb3B0aW9ucyBvYmplY3QuJylcbiAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgJiYgIWNhbGxiYWNrKSBjYWxsYmFjayA9IG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucy51cmkgPSB1cmlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7dXJpOnVyaX1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gdXJpXG4gIH1cblxuICBvcHRpb25zID0gY29weShvcHRpb25zKVxuXG4gIGlmIChjYWxsYmFjaykgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIHZhciByID0gbmV3IFJlcXVlc3Qob3B0aW9ucylcbiAgcmV0dXJuIHJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbnJlcXVlc3QuZGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9yZXF1ZXN0Ly50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG5cbnJlcXVlc3QuaW5pdFBhcmFtcyA9IGluaXRQYXJhbXNcblxucmVxdWVzdC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXF1ZXN0ZXIpIHtcbiAgdmFyIGRlZiA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB2YXIgZCA9IGZ1bmN0aW9uICh1cmksIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdHMsIGNhbGxiYWNrKVxuICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChwYXJhbXMub3B0aW9uc1tpXSA9PT0gdW5kZWZpbmVkKSBwYXJhbXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiByZXF1ZXN0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYobWV0aG9kID09PSByZXF1ZXN0KSB7XG4gICAgICAgICAgbWV0aG9kID0gcmVxdWVzdGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLm9wdGlvbnMuX3JlcXVlc3RlciA9IHJlcXVlc3RlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aG9kKHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG4gICAgfVxuICAgIHJldHVybiBkXG4gIH1cbiAgdmFyIGRlID0gZGVmKHJlcXVlc3QpXG4gIGRlLmdldCA9IGRlZihyZXF1ZXN0LmdldClcbiAgZGUucGF0Y2ggPSBkZWYocmVxdWVzdC5wYXRjaClcbiAgZGUucG9zdCA9IGRlZihyZXF1ZXN0LnBvc3QpXG4gIGRlLnB1dCA9IGRlZihyZXF1ZXN0LnB1dClcbiAgZGUuaGVhZCA9IGRlZihyZXF1ZXN0LmhlYWQpXG4gIGRlLmRlbCA9IGRlZihyZXF1ZXN0LmRlbClcbiAgZGUuY29va2llID0gZGVmKHJlcXVlc3QuY29va2llKVxuICBkZS5qYXIgPSByZXF1ZXN0LmphclxuICByZXR1cm4gZGVcbn1cblxucmVxdWVzdC5mb3JldmVyID0gZnVuY3Rpb24gKGFnZW50T3B0aW9ucywgb3B0aW9uc0FyZykge1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmIChvcHRpb25zQXJnKSB7XG4gICAgZm9yIChvcHRpb24gaW4gb3B0aW9uc0FyZykge1xuICAgICAgb3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc0FyZ1tvcHRpb25dXG4gICAgfVxuICB9XG4gIGlmIChhZ2VudE9wdGlvbnMpIG9wdGlvbnMuYWdlbnRPcHRpb25zID0gYWdlbnRPcHRpb25zXG4gIG9wdGlvbnMuZm9yZXZlciA9IHRydWVcbiAgcmV0dXJuIHJlcXVlc3QuZGVmYXVsdHMob3B0aW9ucylcbn1cblxucmVxdWVzdC5nZXQgPSByZXF1ZXN0XG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnUE9TVCdcbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnUFVUJ1xuICByZXR1cm4gcmVxdWVzdChwYXJhbXMudXJpIHx8IG51bGwsIHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG59XG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgcGFyYW1zLm9wdGlvbnMubWV0aG9kID0gJ1BBVENIJ1xuICByZXR1cm4gcmVxdWVzdChwYXJhbXMudXJpIHx8IG51bGwsIHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG59XG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnSEVBRCdcbiAgaWYgKHBhcmFtcy5vcHRpb25zLmJvZHkgfHxcbiAgICAgIHBhcmFtcy5vcHRpb25zLnJlcXVlc3RCb2R5U3RyZWFtIHx8XG4gICAgICAocGFyYW1zLm9wdGlvbnMuanNvbiAmJiB0eXBlb2YgcGFyYW1zLm9wdGlvbnMuanNvbiAhPT0gJ2Jvb2xlYW4nKSB8fFxuICAgICAgcGFyYW1zLm9wdGlvbnMubXVsdGlwYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBIRUFEIHJlcXVlc3RzIE1VU1QgTk9UIGluY2x1ZGUgYSByZXF1ZXN0IGJvZHkuXCIpXG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5kZWwgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnREVMRVRFJ1xuICBpZih0eXBlb2YgcGFyYW1zLm9wdGlvbnMuX3JlcXVlc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlcXVlc3QgPSBwYXJhbXMub3B0aW9ucy5fcmVxdWVzdGVyXG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5qYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29va2llSmFyXG59XG5yZXF1ZXN0LmNvb2tpZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0ciAmJiBzdHIudXJpKSBzdHIgPSBzdHIudXJpXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvb2tpZSBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgU1RSSU5HIGFzIHBhcmFtXCIpXG4gIHJldHVybiBuZXcgQ29va2llKHN0cilcbn1cblxuLy8gU2FmZSB0b0pTT05cblxuZnVuY3Rpb24gZ2V0U2FmZSAoc2VsZiwgdXVpZCkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBzZWxmID09PSAnZnVuY3Rpb24nKSB2YXIgc2FmZSA9IHt9XG4gIGlmIChBcnJheS5pc0FycmF5KHNlbGYpKSB2YXIgc2FmZSA9IFtdXG5cbiAgdmFyIHJlY3Vyc2UgPSBbXVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCB1dWlkLCB7fSlcblxuICB2YXIgYXR0cnMgPSBPYmplY3Qua2V5cyhzZWxmKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoaSA9PT0gdXVpZCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKCAodHlwZW9mIHNlbGZbaV0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBzZWxmW2ldICE9PSAnZnVuY3Rpb24nKSB8fCBzZWxmW2ldID09PSBudWxsKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiAhKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZltpXSwgdXVpZCkpXG4gIH0pXG5cblxuICBmb3IgKHZhciBpPTA7aTxhdHRycy5sZW5ndGg7aSsrKSB7XG4gICAgaWYgKCAodHlwZW9mIHNlbGZbYXR0cnNbaV1dICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2VsZlthdHRyc1tpXV0gIT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgc2VsZlthdHRyc1tpXV0gPT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICBzYWZlW2F0dHJzW2ldXSA9IHNlbGZbYXR0cnNbaV1dXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3Vyc2UucHVzaChhdHRyc1tpXSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmW2F0dHJzW2ldXSwgdXVpZCwge30pXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaT0wO2k8cmVjdXJzZS5sZW5ndGg7aSsrKSB7XG4gICAgc2FmZVtyZWN1cnNlW2ldXSA9IGdldFNhZmUoc2VsZltyZWN1cnNlW2ldXSwgdXVpZClcbiAgfVxuXG4gIHJldHVybiBzYWZlXG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiBnZXRTYWZlKHRoaXMsICdfXycgKyAoKCgxK01hdGgucmFuZG9tKCkpKjB4MTAwMDApfDApLnRvU3RyaW5nKDE2KSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUudG9KU09OID0gdG9KU09OXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxuZXhwb3J0cy5oZXhfc2hhMSA9IGhleF9zaGExO1xuZXhwb3J0cy5iNjRfc2hhMSA9IGI2NF9zaGExO1xuZXhwb3J0cy5zdHJfc2hhMSA9IHN0cl9zaGExO1xuZXhwb3J0cy5oZXhfaG1hY19zaGExID0gaGV4X2htYWNfc2hhMTtcbmV4cG9ydHMuYjY0X2htYWNfc2hhMSA9IGI2NF9obWFjX3NoYTE7XG5leHBvcnRzLnN0cl9obWFjX3NoYTEgPSBzdHJfaG1hY19zaGExO1xuXG4vKlxuICogQ29uZmlndXJhYmxlIHZhcmlhYmxlcy4gWW91IG1heSBuZWVkIHRvIHR3ZWFrIHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAqL1xudmFyIGhleGNhc2UgPSAwOyAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG52YXIgY2hyc3ogICA9IDg7ICAvKiBiaXRzIHBlciBpbnB1dCBjaGFyYWN0ZXIuIDggLSBBU0NJSTsgMTYgLSBVbmljb2RlICAgICAgKi9cblxuLypcbiAqIFRoZXNlIGFyZSB0aGUgZnVuY3Rpb25zIHlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gY2FsbFxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGhleF9zaGExKHMpe3JldHVybiBiaW5iMmhleChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGI2NF9zaGExKHMpe3JldHVybiBiaW5iMmI2NChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIHN0cl9zaGExKHMpe3JldHVybiBiaW5iMnN0cihjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGhleF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyaGV4KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIGI2NF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyYjY0KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIHN0cl9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyc3RyKGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cblxuLypcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xuICovXG5mdW5jdGlvbiBzaGExX3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X3NoYTEoXCJhYmNcIikgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcblxuICB2YXIgdyA9IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIHZhciBvbGRlID0gZTtcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdO1xuICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm9sKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7XG5cbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSBzdHIyYmluYihrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gY29yZV9zaGExKGJrZXksIGtleS5sZW5ndGggKiBjaHJzeik7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gY29yZV9zaGExKGlwYWQuY29uY2F0KHN0cjJiaW5iKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiBjb3JlX3NoYTEob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDE2MCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gOC1iaXQgb3IgMTYtYml0IHN0cmluZyB0byBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzXG4gKiBJbiA4LWJpdCBmdW5jdGlvbiwgY2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGktYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBzdHIyYmluYihzdHIpXG57XG4gIHZhciBiaW4gPSBBcnJheSgpO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICogY2hyc3o7IGkgKz0gY2hyc3opXG4gICAgYmluW2k+PjVdIHw9IChzdHIuY2hhckNvZGVBdChpIC8gY2hyc3opICYgbWFzaykgPDwgKDMyIC0gY2hyc3ogLSBpJTMyKTtcbiAgcmV0dXJuIGJpbjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMnN0cihiaW4pXG57XG4gIHZhciBzdHIgPSBcIlwiO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoICogMzI7IGkgKz0gY2hyc3opXG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGJpbltpPj41XSA+Pj4gKDMyIC0gY2hyc3ogLSBpJTMyKSkgJiBtYXNrKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJpbmIyaGV4KGJpbmFycmF5KVxue1xuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkrKylcbiAge1xuICAgIHN0ciArPSBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4KzQpKSAmIDB4RikgK1xuICAgICAgICAgICBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4ICApKSAmIDB4Rik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGJhc2UtNjQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmIyYjY0KGJpbmFycmF5KVxue1xuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoKChiaW5hcnJheVtpICAgPj4gMl0gPj4gOCAqICgzIC0gIGkgICAlNCkpICYgMHhGRikgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoKChiaW5hcnJheVtpKzEgPj4gMl0gPj4gOCAqICgzIC0gKGkrMSklNCkpICYgMHhGRikgPDwgOCApXG4gICAgICAgICAgICAgICAgfCAgKChiaW5hcnJheVtpKzIgPj4gMl0gPj4gOCAqICgzIC0gKGkrMiklNCkpICYgMHhGRik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gYmluYXJyYXkubGVuZ3RoICogMzIpIHN0ciArPSBiNjRwYWQ7XG4gICAgICBlbHNlIHN0ciArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbiIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICAvLyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgaW4gd2Via2l0LWJhc2VkIGJyb3dzZXJzLlxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHZhciBfcm5kcyA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICB3aGF0d2dSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzKTtcblxuICAgICAgZm9yICh2YXIgYyA9IDAgOyBjIDwgc2l6ZTsgYysrKSB7XG4gICAgICAgIGJ5dGVzW2NdID0gX3JuZHNbYyA+PiAyXSA+Pj4gKChjICYgMHgwMykgKiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKSIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCJcIjsgIC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfbWQ1KHMpICAgIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpKTsgfVxuZnVuY3Rpb24gYjY0X21kNShzKSAgICB7IHJldHVybiByc3RyMmI2NChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGFueV9tZDUocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSksIGUpOyB9XG5mdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGI2NF9obWFjX21kNShrLCBkKVxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYW55X2htYWNfbWQ1KGssIGQsIGUpXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSksIGUpOyB9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X21kNShcImFiY1wiKS50b0xvd2VyQ2FzZSgpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGEgcmF3IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyX21kNShzKVxue1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtTUQ1LCBvZiBhIGtleSBhbmQgc29tZSBkYXRhIChyYXcgc3RyaW5ncylcbiAqL1xuZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gcnN0cjJiaW5sKGtleSk7XG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5sX21kNShia2V5LCBrZXkubGVuZ3RoICogOCk7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gYmlubF9tZDUoaXBhZC5jb25jYXQocnN0cjJiaW5sKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiA4KTtcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTI4KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJoZXgoaW5wdXQpXG57XG4gIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIHg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAge1xuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIG91dHB1dCArPSBoZXhfdGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBGKVxuICAgICAgICAgICArICBoZXhfdGFiLmNoYXJBdCggeCAgICAgICAgJiAweDBGKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmI2NChpbnB1dClcbntcbiAgdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcbiAgICAgICAgICAgICAgICB8IChpICsgMSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsxKSA8PCA4IDogMClcbiAgICAgICAgICAgICAgICB8IChpICsgMiA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsyKSAgICAgIDogMCk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gaW5wdXQubGVuZ3RoICogOCkgb3V0cHV0ICs9IGI2NHBhZDtcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcmJpdHJhcnkgc3RyaW5nIGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcbntcbiAgdmFyIGRpdmlzb3IgPSBlbmNvZGluZy5sZW5ndGg7XG4gIHZhciBpLCBqLCBxLCB4LCBxdW90aWVudDtcblxuICAvKiBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIDE2LWJpdCBiaWctZW5kaWFuIHZhbHVlcywgZm9ybWluZyB0aGUgZGl2aWRlbmQgKi9cbiAgdmFyIGRpdmlkZW5kID0gQXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDIpKTtcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICBkaXZpZGVuZFtpXSA9IChpbnB1dC5jaGFyQ29kZUF0KGkgKiAyKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBlbmNvZGluZyBpcyB0aGUgZGl2aXNvci4gT25jZSBjb21wdXRlZCwgdGhlIHF1b3RpZW50XG4gICAqIGZvcm1zIHRoZSBkaXZpZGVuZCBmb3IgdGhlIG5leHQgc3RlcC4gQWxsIHJlbWFpbmRlcnMgYXJlIHN0b3JlZCBmb3IgbGF0ZXJcbiAgICogdXNlLlxuICAgKi9cbiAgdmFyIGZ1bGxfbGVuZ3RoID0gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAqIDggL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpO1xuICB2YXIgcmVtYWluZGVycyA9IEFycmF5KGZ1bGxfbGVuZ3RoKTtcbiAgZm9yKGogPSAwOyBqIDwgZnVsbF9sZW5ndGg7IGorKylcbiAge1xuICAgIHF1b3RpZW50ID0gQXJyYXkoKTtcbiAgICB4ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XG4gICAgICBxID0gTWF0aC5mbG9vcih4IC8gZGl2aXNvcik7XG4gICAgICB4IC09IHEgKiBkaXZpc29yO1xuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcbiAgICAgICAgcXVvdGllbnRbcXVvdGllbnQubGVuZ3RoXSA9IHE7XG4gICAgfVxuICAgIHJlbWFpbmRlcnNbal0gPSB4O1xuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XG4gIH1cblxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IoaSA9IHJlbWFpbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04LlxuICogRm9yIGVmZmljaWVuY3ksIHRoaXMgYXNzdW1lcyB0aGUgaW5wdXQgaXMgdmFsaWQgdXRmLTE2LlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGY4KGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHgsIHk7XG5cbiAgd2hpbGUoKytpIDwgaW5wdXQubGVuZ3RoKVxuICB7XG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICB5ID0gaSArIDEgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKSA6IDA7XG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXG4gICAge1xuICAgICAgeCA9IDB4MTAwMDAgKyAoKHggJiAweDAzRkYpIDw8IDEwKSArICh5ICYgMHgwM0ZGKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXG4gICAgaWYoeCA8PSAweDdGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoeCA+Pj4gNiApICYgMHgxRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKHggPj4+IDEyKSAmIDB4MEYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4MUZGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGMCB8ICgoeCA+Pj4gMTgpICYgMHgwNyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTE2XG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2bGUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZiZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IEFycmF5KGlucHV0Lmxlbmd0aCA+PiAyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXRbaV0gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KVxuICAgIG91dHB1dFtpPj41XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoaSUzMik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGJpbmxfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cblxuZXhwb3J0cy5oZXhfbWQ1ID0gaGV4X21kNTtcbmV4cG9ydHMuYjY0X21kNSA9IGI2NF9tZDU7XG5leHBvcnRzLmFueV9tZDUgPSBhbnlfbWQ1O1xuIiwiLy8gdG9kb1xuIixudWxsLCJ2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbiAgO1xuXG5mdW5jdGlvbiBzaGExIChrZXksIGJvZHkpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywga2V5KS51cGRhdGUoYm9keSkuZGlnZXN0KCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiByZmMzOTg2IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgLnJlcGxhY2UoLyEvZywnJTIxJylcbiAgICAucmVwbGFjZSgvXFwqL2csJyUyQScpXG4gICAgLnJlcGxhY2UoL1xcKC9nLCclMjgnKVxuICAgIC5yZXBsYWNlKC9cXCkvZywnJTI5JylcbiAgICAucmVwbGFjZSgvJy9nLCclMjcnKVxuICAgIDtcbn1cblxuZnVuY3Rpb24gaG1hY3NpZ24gKGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMsIGNvbnN1bWVyX3NlY3JldCwgdG9rZW5fc2VjcmV0KSB7XG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2Rldi50d2l0dGVyLmNvbS9kb2NzL2F1dGgvb2F1dGggYW5kIFxuICAvLyBodHRwczovL2Rldi50d2l0dGVyLmNvbS9kb2NzL2F1dGgvY3JlYXRpbmctc2lnbmF0dXJlXG5cbiAgdmFyIHF1ZXJ5c3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCkubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgLy8gYmlnIFdURiBoZXJlIHdpdGggdGhlIGVzY2FwZSArIGVuY29kaW5nIGJ1dCBpdCdzIHdoYXQgdHdpdHRlciB3YW50c1xuICAgIHJldHVybiBlc2NhcGUocmZjMzk4NihrZXkpKSArIFwiJTNEXCIgKyBlc2NhcGUocmZjMzk4NihwYXJhbXNba2V5XSkpXG4gIH0pLmpvaW4oJyUyNicpXG5cbiAgdmFyIGJhc2UgPSBbXG4gICAgaHR0cE1ldGhvZCA/IGh0dHBNZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICAgIHJmYzM5ODYoYmFzZV91cmkpLFxuICAgIHF1ZXJ5c3RyaW5nXG4gIF0uam9pbignJicpXG5cbiAgdmFyIGtleSA9IFtcbiAgICBjb25zdW1lcl9zZWNyZXQsXG4gICAgdG9rZW5fc2VjcmV0IHx8ICcnXG4gIF0ubWFwKHJmYzM5ODYpLmpvaW4oJyYnKVxuXG4gIHJldHVybiBzaGExKGtleSwgYmFzZSlcbn1cblxuZXhwb3J0cy5obWFjc2lnbiA9IGhtYWNzaWduXG5leHBvcnRzLnJmYzM5ODYgPSByZmMzOTg2XG4iLCJcbi8qIVxuICoga25veCAtIGF1dGhcbiAqIENvcHlyaWdodChjKSAyMDEwIExlYXJuQm9vc3QgPGRldkBsZWFybmJvb3N0LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgLCBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG4gIDtcblxuLyoqXG4gKiBWYWxpZCBrZXlzLlxuICovXG5cbnZhciBrZXlzID0gXG4gIFsgJ2FjbCdcbiAgLCAnbG9jYXRpb24nXG4gICwgJ2xvZ2dpbmcnXG4gICwgJ25vdGlmaWNhdGlvbidcbiAgLCAncGFydE51bWJlcidcbiAgLCAncG9saWN5J1xuICAsICdyZXF1ZXN0UGF5bWVudCdcbiAgLCAndG9ycmVudCdcbiAgLCAndXBsb2FkSWQnXG4gICwgJ3VwbG9hZHMnXG4gICwgJ3ZlcnNpb25JZCdcbiAgLCAndmVyc2lvbmluZydcbiAgLCAndmVyc2lvbnMnXG4gICwgJ3dlYnNpdGUnXG4gIF1cblxuLyoqXG4gKiBSZXR1cm4gYW4gXCJBdXRob3JpemF0aW9uXCIgaGVhZGVyIHZhbHVlIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYFxuICogaW4gdGhlIGZvcm0gb2YgXCJBV1MgPGtleT46PHNpZ25hdHVyZT5cIlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhdXRob3JpemF0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiAnQVdTICcgKyBvcHRpb25zLmtleSArICc6JyArIHNpZ24ob3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhdXRob3JpemF0aW9uXG5tb2R1bGUuZXhwb3J0cy5hdXRob3JpemF0aW9uID0gYXV0aG9yaXphdGlvblxuXG4vKipcbiAqIFNpbXBsZSBITUFDLVNIQTEgV3JhcHBlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqLyBcblxuZnVuY3Rpb24gaG1hY1NoYTEgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywgb3B0aW9ucy5zZWNyZXQpLnVwZGF0ZShvcHRpb25zLm1lc3NhZ2UpLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxubW9kdWxlLmV4cG9ydHMuaG1hY1NoYTEgPSBobWFjU2hhMVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzaGExIEhNQUMgZm9yIGBvcHRpb25zYC4gXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaWduIChvcHRpb25zKSB7XG4gIG9wdGlvbnMubWVzc2FnZSA9IHN0cmluZ1RvU2lnbihvcHRpb25zKVxuICByZXR1cm4gaG1hY1NoYTEob3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzLnNpZ24gPSBzaWduXG5cbi8qKlxuICogQ3JlYXRlIGEgYmFzZTY0IHNoYTEgSE1BQyBmb3IgYG9wdGlvbnNgLiBcbiAqXG4gKiBTcGVjaWZpY2FsbHkgdG8gYmUgdXNlZCB3aXRoIFMzIHByZXNpZ25lZCBVUkxzXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaWduUXVlcnkgKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5tZXNzYWdlID0gcXVlcnlTdHJpbmdUb1NpZ24ob3B0aW9ucylcbiAgcmV0dXJuIGhtYWNTaGExKG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cy5zaWduUXVlcnk9IHNpZ25RdWVyeVxuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBmb3Igc2lnbigpIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBTcGVjOlxuICogXG4gKiAgICA8dmVyYj5cXG5cbiAqICAgIDxtZDU+XFxuXG4gKiAgICA8Y29udGVudC10eXBlPlxcblxuICogICAgPGRhdGU+XFxuXG4gKiAgICBbaGVhZGVyc1xcbl1cbiAqICAgIDxyZXNvdXJjZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9TaWduIChvcHRpb25zKSB7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5hbWF6b25IZWFkZXJzIHx8ICcnXG4gIGlmIChoZWFkZXJzKSBoZWFkZXJzICs9ICdcXG4nXG4gIHZhciByID0gXG4gICAgWyBvcHRpb25zLnZlcmJcbiAgICAsIG9wdGlvbnMubWQ1XG4gICAgLCBvcHRpb25zLmNvbnRlbnRUeXBlXG4gICAgLCBvcHRpb25zLmRhdGUudG9VVENTdHJpbmcoKVxuICAgICwgaGVhZGVycyArIG9wdGlvbnMucmVzb3VyY2VcbiAgICBdXG4gIHJldHVybiByLmpvaW4oJ1xcbicpXG59XG5tb2R1bGUuZXhwb3J0cy5xdWVyeVN0cmluZ1RvU2lnbiA9IHN0cmluZ1RvU2lnblxuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBmb3Igc2lnbigpIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYCwgYnV0IGlzIG1lYW50IGV4Y2x1c2l2ZWx5XG4gKiBmb3IgUzMgcHJlc2lnbmVkIFVSTHNcbiAqXG4gKiBTcGVjOlxuICogXG4gKiAgICA8ZGF0ZT5cXG5cbiAqICAgIDxyZXNvdXJjZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXVlcnlTdHJpbmdUb1NpZ24gKG9wdGlvbnMpe1xuICByZXR1cm4gJ0dFVFxcblxcblxcbicgKyBvcHRpb25zLmRhdGUgKyAnXFxuJyArIG9wdGlvbnMucmVzb3VyY2Vcbn1cbm1vZHVsZS5leHBvcnRzLnF1ZXJ5U3RyaW5nVG9TaWduID0gcXVlcnlTdHJpbmdUb1NpZ25cblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWdub3JlIG5vbi1hbWF6b24gaGVhZGVyc1xuICogIC0gbG93ZXJjYXNlIGZpZWxkc1xuICogIC0gc29ydCBsZXhpY29ncmFwaGljYWxseVxuICogIC0gdHJpbSB3aGl0ZXNwYWNlIGJldHdlZW4gXCI6XCJcbiAqICAtIGpvaW4gd2l0aCBuZXdsaW5lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdXG4gICAgLCBmaWVsZHMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgIDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXVxuICAgICAgLCB2YWwgPSBoZWFkZXJzW2ZpZWxkXVxuICAgICAgLCBmaWVsZCA9IGZpZWxkLnRvTG93ZXJDYXNlKClcbiAgICAgIDtcbiAgICBpZiAoMCAhPT0gZmllbGQuaW5kZXhPZigneC1hbXonKSkgY29udGludWVcbiAgICBidWYucHVzaChmaWVsZCArICc6JyArIHZhbClcbiAgfVxuICByZXR1cm4gYnVmLnNvcnQoKS5qb2luKCdcXG4nKVxufVxubW9kdWxlLmV4cG9ydHMuY2Fub25pY2FsaXplSGVhZGVycyA9IGNhbm9uaWNhbGl6ZUhlYWRlcnNcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWdub3JlIG5vbiBzdWItcmVzb3VyY2VzXG4gKiAgLSBzb3J0IGxleGljb2dyYXBoaWNhbGx5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVSZXNvdXJjZSAocmVzb3VyY2UpIHtcbiAgdmFyIHVybCA9IHBhcnNlKHJlc291cmNlLCB0cnVlKVxuICAgICwgcGF0aCA9IHVybC5wYXRobmFtZVxuICAgICwgYnVmID0gW11cbiAgICA7XG5cbiAgT2JqZWN0LmtleXModXJsLnF1ZXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgaWYgKCF+a2V5cy5pbmRleE9mKGtleSkpIHJldHVyblxuICAgIHZhciB2YWwgPSAnJyA9PSB1cmwucXVlcnlba2V5XSA/ICcnIDogJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybC5xdWVyeVtrZXldKVxuICAgIGJ1Zi5wdXNoKGtleSArIHZhbClcbiAgfSlcblxuICByZXR1cm4gcGF0aCArIChidWYubGVuZ3RoID8gJz8nICsgYnVmLnNvcnQoKS5qb2luKCcmJykgOiAnJylcbn1cbm1vZHVsZS5leHBvcnRzLmNhbm9uaWNhbGl6ZVJlc291cmNlID0gY2Fub25pY2FsaXplUmVzb3VyY2VcbiIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZVxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZztcblxuICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgLy9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgaWYgKHR5cGVvZihyZXF1aXJlKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmIgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICAgIF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIV9ybmcgJiYgX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vXG4gICAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgICByZXR1cm4gX3JuZHM4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIV9ybmcpIHtcbiAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgLy9cbiAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgIC8vIHF1YWxpdHkuXG4gICAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9IHR5cGVvZihCdWZmZXIpID09ICdmdW5jdGlvbicgPyBCdWZmZXIgOiBBcnJheTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgICBidWYgPSBidWYgfHwgW107XG4gICAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW1xuICAgIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbiAgXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAgIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICAgIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAgIC8vIHRpbWUgaW50ZXJ2YWxcbiAgICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT0gbnVsbCkge1xuICAgICAgbnNlY3MgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICAgIH1cblxuICAgIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAgIC8vIGB0aW1lX2xvd2BcbiAgICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gICAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9taWRgXG4gICAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcblxuICBpZiAoX2dsb2JhbC5kZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFB1Ymxpc2ggYXMgQU1EIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gdXVpZDt9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIHZhciBfcHJldmlvdXNSb290ID0gX2dsb2JhbC51dWlkO1xuXG4gICAgLy8gKipgbm9Db25mbGljdCgpYCAtIChicm93c2VyIG9ubHkpIHRvIHJlc2V0IGdsb2JhbCAndXVpZCcgdmFyKipcbiAgICB1dWlkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9nbG9iYWwudXVpZCA9IF9wcmV2aW91c1Jvb3Q7XG4gICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuXG4gICAgX2dsb2JhbC51dWlkID0gdXVpZDtcbiAgfVxufSgpKTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihwcm9jZXNzLF9fZGlybmFtZSl7dmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5mdW5jdGlvbiBNaW1lKCkge1xuICAvLyBNYXAgb2YgZXh0ZW5zaW9uIC0+IG1pbWUgdHlwZVxuICB0aGlzLnR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBNYXAgb2YgbWltZSB0eXBlIC0+IGV4dGVuc2lvblxuICB0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIERlZmluZSBtaW1ldHlwZSAtPiBleHRlbnNpb24gbWFwcGluZ3MuICBFYWNoIGtleSBpcyBhIG1pbWUtdHlwZSB0aGF0IG1hcHNcbiAqIHRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0eXBlLiAgVGhlIGZpcnN0IGV4dGVuc2lvbiBpc1xuICogdXNlZCBhcyB0aGUgZGVmYXVsdCBleHRlbnNpb24gZm9yIHRoZSB0eXBlLlxuICpcbiAqIGUuZy4gbWltZS5kZWZpbmUoeydhdWRpby9vZ2cnLCBbJ29nYScsICdvZ2cnLCAnc3B4J119KTtcbiAqXG4gKiBAcGFyYW0gbWFwIChPYmplY3QpIHR5cGUgZGVmaW5pdGlvbnNcbiAqL1xuTWltZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKG1hcCkge1xuICBmb3IgKHZhciB0eXBlIGluIG1hcCkge1xuICAgIHZhciBleHRzID0gbWFwW3R5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfTUlNRSAmJiB0aGlzLnR5cGVzW2V4dHNdKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0aGlzLl9sb2FkaW5nLnJlcGxhY2UoLy4qXFwvLywgJycpLCAnY2hhbmdlcyBcIicgKyBleHRzW2ldICsgJ1wiIGV4dGVuc2lvbiB0eXBlIGZyb20gJyArXG4gICAgICAgICAgdGhpcy50eXBlc1tleHRzXSArICcgdG8gJyArIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR5cGVzW2V4dHNbaV1dID0gdHlwZTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGV4dGVuc2lvbiBpcyB0aGUgZmlyc3Qgb25lIHdlIGVuY291bnRlclxuICAgIGlmICghdGhpcy5leHRlbnNpb25zW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbdHlwZV0gPSBleHRzWzBdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMb2FkIGFuIEFwYWNoZTItc3R5bGUgXCIudHlwZXNcIiBmaWxlXG4gKlxuICogVGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIChpdCdzIGV4cGVjdGVkKS4gIFdoZXJlIGZpbGVzIGRlY2xhcmVcbiAqIG92ZXJsYXBwaW5nIHR5cGVzL2V4dGVuc2lvbnMsIHRoZSBsYXN0IGZpbGUgd2lucy5cbiAqXG4gKiBAcGFyYW0gZmlsZSAoU3RyaW5nKSBwYXRoIG9mIGZpbGUgdG8gbG9hZC5cbiAqL1xuTWltZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGZpbGUpIHtcblxuICB0aGlzLl9sb2FkaW5nID0gZmlsZTtcbiAgLy8gUmVhZCBmaWxlIGFuZCBzcGxpdCBpbnRvIGxpbmVzXG4gIHZhciBtYXAgPSB7fSxcbiAgICAgIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ2FzY2lpJyksXG4gICAgICBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoL1tcXHJcXG5dKy8pO1xuXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UvY29tbWVudHMsIGFuZCBzcGxpdCBpbnRvIGZpZWxkc1xuICAgIHZhciBmaWVsZHMgPSBsaW5lLnJlcGxhY2UoL1xccyojLip8Xlxccyp8XFxzKiQvZywgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgbWFwW2ZpZWxkcy5zaGlmdCgpXSA9IGZpZWxkcztcbiAgfSk7XG5cbiAgdGhpcy5kZWZpbmUobWFwKTtcblxuICB0aGlzLl9sb2FkaW5nID0gbnVsbDtcbn07XG5cbi8qKlxuICogTG9va3VwIGEgbWltZSB0eXBlIGJhc2VkIG9uIGV4dGVuc2lvblxuICovXG5NaW1lLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihwYXRoLCBmYWxsYmFjaykge1xuICB2YXIgZXh0ID0gcGF0aC5yZXBsYWNlKC8uKltcXC5cXC9dLywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHRoaXMudHlwZXNbZXh0XSB8fCBmYWxsYmFjayB8fCB0aGlzLmRlZmF1bHRfdHlwZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpbGUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCBhIG1pbWUgdHlwZVxuICovXG5NaW1lLnByb3RvdHlwZS5leHRlbnNpb24gPSBmdW5jdGlvbihtaW1lVHlwZSkge1xuICByZXR1cm4gdGhpcy5leHRlbnNpb25zW21pbWVUeXBlXTtcbn07XG5cbi8vIERlZmF1bHQgaW5zdGFuY2VcbnZhciBtaW1lID0gbmV3IE1pbWUoKTtcblxuLy8gTG9hZCBsb2NhbCBjb3B5IG9mXG4vLyBodHRwOi8vc3ZuLmFwYWNoZS5vcmcvcmVwb3MvYXNmL2h0dHBkL2h0dHBkL3RydW5rL2RvY3MvY29uZi9taW1lLnR5cGVzXG5taW1lLmxvYWQocGF0aC5qb2luKF9fZGlybmFtZSwgJ3R5cGVzL21pbWUudHlwZXMnKSk7XG5cbi8vIExvYWQgYWRkaXRpb25hbCB0eXBlcyBmcm9tIG5vZGUuanMgY29tbXVuaXR5XG5taW1lLmxvYWQocGF0aC5qb2luKF9fZGlybmFtZSwgJ3R5cGVzL25vZGUudHlwZXMnKSk7XG5cbi8vIERlZmF1bHQgdHlwZVxubWltZS5kZWZhdWx0X3R5cGUgPSBtaW1lLmxvb2t1cCgnYmluJyk7XG5cbi8vXG4vLyBBZGRpdGlvbmFsIEFQSSBzcGVjaWZpYyB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuLy9cblxubWltZS5NaW1lID0gTWltZTtcblxuLyoqXG4gKiBMb29rdXAgYSBjaGFyc2V0IGJhc2VkIG9uIG1pbWUgdHlwZS5cbiAqL1xubWltZS5jaGFyc2V0cyA9IHtcbiAgbG9va3VwOiBmdW5jdGlvbihtaW1lVHlwZSwgZmFsbGJhY2spIHtcbiAgICAvLyBBc3N1bWUgdGV4dCB0eXBlcyBhcmUgdXRmOFxuICAgIHJldHVybiAoL150ZXh0XFwvLykudGVzdChtaW1lVHlwZSkgPyAnVVRGLTgnIDogZmFsbGJhY2s7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltZTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLFwiL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9taW1lXCIpIiwiKGZ1bmN0aW9uKHByb2Nlc3MsQnVmZmVyKXsndXNlIHN0cmljdCdcblxudmFyIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICwgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgLCBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG4gICwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG4gICwgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbiAgLCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuICAsIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgO1xuXG5leHBvcnRzLmh0dHBPdmVySHR0cCA9IGh0dHBPdmVySHR0cFxuZXhwb3J0cy5odHRwc092ZXJIdHRwID0gaHR0cHNPdmVySHR0cFxuZXhwb3J0cy5odHRwT3Zlckh0dHBzID0gaHR0cE92ZXJIdHRwc1xuZXhwb3J0cy5odHRwc092ZXJIdHRwcyA9IGh0dHBzT3Zlckh0dHBzXG5cblxuZnVuY3Rpb24gaHR0cE92ZXJIdHRwKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwLnJlcXVlc3RcbiAgcmV0dXJuIGFnZW50XG59XG5cbmZ1bmN0aW9uIGh0dHBzT3Zlckh0dHAob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucylcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHAucmVxdWVzdFxuICBhZ2VudC5jcmVhdGVTb2NrZXQgPSBjcmVhdGVTZWN1cmVTb2NrZXRcbiAgcmV0dXJuIGFnZW50XG59XG5cbmZ1bmN0aW9uIGh0dHBPdmVySHR0cHMob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucylcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHBzLnJlcXVlc3RcbiAgcmV0dXJuIGFnZW50XG59XG5cbmZ1bmN0aW9uIGh0dHBzT3Zlckh0dHBzKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0XG4gIGFnZW50LmNyZWF0ZVNvY2tldCA9IGNyZWF0ZVNlY3VyZVNvY2tldFxuICByZXR1cm4gYWdlbnRcbn1cblxuXG5mdW5jdGlvbiBUdW5uZWxpbmdBZ2VudChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHNlbGYucHJveHlPcHRpb25zID0gc2VsZi5vcHRpb25zLnByb3h5IHx8IHt9XG4gIHNlbGYubWF4U29ja2V0cyA9IHNlbGYub3B0aW9ucy5tYXhTb2NrZXRzIHx8IGh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHNcbiAgc2VsZi5yZXF1ZXN0cyA9IFtdXG4gIHNlbGYuc29ja2V0cyA9IFtdXG5cbiAgc2VsZi5vbignZnJlZScsIGZ1bmN0aW9uIG9uRnJlZShzb2NrZXQsIGhvc3QsIHBvcnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5yZXF1ZXN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdmFyIHBlbmRpbmcgPSBzZWxmLnJlcXVlc3RzW2ldXG4gICAgICBpZiAocGVuZGluZy5ob3N0ID09PSBob3N0ICYmIHBlbmRpbmcucG9ydCA9PT0gcG9ydCkge1xuICAgICAgICAvLyBEZXRlY3QgdGhlIHJlcXVlc3QgdG8gY29ubmVjdCBzYW1lIG9yaWdpbiBzZXJ2ZXIsXG4gICAgICAgIC8vIHJldXNlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICBzZWxmLnJlcXVlc3RzLnNwbGljZShpLCAxKVxuICAgICAgICBwZW5kaW5nLnJlcXVlc3Qub25Tb2NrZXQoc29ja2V0KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgc29ja2V0LmRlc3Ryb3koKVxuICAgIHNlbGYucmVtb3ZlU29ja2V0KHNvY2tldClcbiAgfSlcbn1cbnV0aWwuaW5oZXJpdHMoVHVubmVsaW5nQWdlbnQsIGV2ZW50cy5FdmVudEVtaXR0ZXIpXG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0ID0gZnVuY3Rpb24gYWRkUmVxdWVzdChyZXEsIGhvc3QsIHBvcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuc29ja2V0cy5sZW5ndGggPj0gdGhpcy5tYXhTb2NrZXRzKSB7XG4gICAgLy8gV2UgYXJlIG92ZXIgbGltaXQgc28gd2UnbGwgYWRkIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICBzZWxmLnJlcXVlc3RzLnB1c2goe2hvc3Q6IGhvc3QsIHBvcnQ6IHBvcnQsIHJlcXVlc3Q6IHJlcX0pXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBJZiB3ZSBhcmUgdW5kZXIgbWF4U29ja2V0cyBjcmVhdGUgYSBuZXcgb25lLlxuICBzZWxmLmNyZWF0ZVNvY2tldCh7aG9zdDogaG9zdCwgcG9ydDogcG9ydCwgcmVxdWVzdDogcmVxfSwgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKVxuICAgIHNvY2tldC5vbignY2xvc2UnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgc29ja2V0Lm9uKCdhZ2VudFJlbW92ZScsIG9uQ2xvc2VPclJlbW92ZSlcbiAgICByZXEub25Tb2NrZXQoc29ja2V0KVxuXG4gICAgZnVuY3Rpb24gb25GcmVlKCkge1xuICAgICAgc2VsZi5lbWl0KCdmcmVlJywgc29ja2V0LCBob3N0LCBwb3J0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2VPclJlbW92ZShlcnIpIHtcbiAgICAgIHNlbGYucmVtb3ZlU29ja2V0KClcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZnJlZScsIG9uRnJlZSlcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2FnZW50UmVtb3ZlJywgb25DbG9zZU9yUmVtb3ZlKVxuICAgIH1cbiAgfSlcbn1cblxuVHVubmVsaW5nQWdlbnQucHJvdG90eXBlLmNyZWF0ZVNvY2tldCA9IGZ1bmN0aW9uIGNyZWF0ZVNvY2tldChvcHRpb25zLCBjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBsYWNlaG9sZGVyID0ge31cbiAgc2VsZi5zb2NrZXRzLnB1c2gocGxhY2Vob2xkZXIpXG5cbiAgdmFyIGNvbm5lY3RPcHRpb25zID0gbWVyZ2VPcHRpb25zKHt9LCBzZWxmLnByb3h5T3B0aW9ucywgXG4gICAgeyBtZXRob2Q6ICdDT05ORUNUJ1xuICAgICwgcGF0aDogb3B0aW9ucy5ob3N0ICsgJzonICsgb3B0aW9ucy5wb3J0XG4gICAgLCBhZ2VudDogZmFsc2VcbiAgICB9XG4gIClcbiAgaWYgKGNvbm5lY3RPcHRpb25zLnByb3h5QXV0aCkge1xuICAgIGNvbm5lY3RPcHRpb25zLmhlYWRlcnMgPSBjb25uZWN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgY29ubmVjdE9wdGlvbnMuaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgK1xuICAgICAgICBuZXcgQnVmZmVyKGNvbm5lY3RPcHRpb25zLnByb3h5QXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIH1cblxuICBkZWJ1ZygnbWFraW5nIENPTk5FQ1QgcmVxdWVzdCcpXG4gIHZhciBjb25uZWN0UmVxID0gc2VsZi5yZXF1ZXN0KGNvbm5lY3RPcHRpb25zKVxuICBjb25uZWN0UmVxLnVzZUNodW5rZWRFbmNvZGluZ0J5RGVmYXVsdCA9IGZhbHNlIC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgncmVzcG9uc2UnLCBvblJlc3BvbnNlKSAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ3VwZ3JhZGUnLCBvblVwZ3JhZGUpICAgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCdjb25uZWN0Jywgb25Db25uZWN0KSAgIC8vIGZvciB2MC43IG9yIGxhdGVyXG4gIGNvbm5lY3RSZXEub25jZSgnZXJyb3InLCBvbkVycm9yKVxuICBjb25uZWN0UmVxLmVuZCgpXG5cbiAgZnVuY3Rpb24gb25SZXNwb25zZShyZXMpIHtcbiAgICAvLyBWZXJ5IGhhY2t5LiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBodHRwLXBhcnNlciBsZWFrcy5cbiAgICByZXMudXBncmFkZSA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVXBncmFkZShyZXMsIHNvY2tldCwgaGVhZCkge1xuICAgIC8vIEhhY2t5LlxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBvbkNvbm5lY3QocmVzLCBzb2NrZXQsIGhlYWQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdChyZXMsIHNvY2tldCwgaGVhZCkge1xuICAgIGNvbm5lY3RSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKClcblxuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBhc3NlcnQuZXF1YWwoaGVhZC5sZW5ndGgsIDApXG4gICAgICBkZWJ1ZygndHVubmVsaW5nIGNvbm5lY3Rpb24gaGFzIGVzdGFibGlzaGVkJylcbiAgICAgIHNlbGYuc29ja2V0c1tzZWxmLnNvY2tldHMuaW5kZXhPZihwbGFjZWhvbGRlcildID0gc29ja2V0XG4gICAgICBjYihzb2NrZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgc3RhdHVzQ29kZT0lZCcsIHJlcy5zdGF0dXNDb2RlKVxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgJyArICdzdGF0dXNDb2RlPScgKyByZXMuc3RhdHVzQ29kZSlcbiAgICAgIGVycm9yLmNvZGUgPSAnRUNPTk5SRVNFVCdcbiAgICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQocGxhY2Vob2xkZXIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FcnJvcihjYXVzZSkge1xuICAgIGNvbm5lY3RSZXEucmVtb3ZlQWxsTGlzdGVuZXJzKClcblxuICAgIGRlYnVnKCd0dW5uZWxpbmcgc29ja2V0IGNvdWxkIG5vdCBiZSBlc3RhYmxpc2hlZCwgY2F1c2U9JXNcXG4nLCBjYXVzZS5tZXNzYWdlLCBjYXVzZS5zdGFjaylcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICsgJ2NhdXNlPScgKyBjYXVzZS5tZXNzYWdlKVxuICAgIGVycm9yLmNvZGUgPSAnRUNPTk5SRVNFVCdcbiAgICBvcHRpb25zLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcilcbiAgfVxufVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUucmVtb3ZlU29ja2V0ID0gZnVuY3Rpb24gcmVtb3ZlU29ja2V0KHNvY2tldCkge1xuICB2YXIgcG9zID0gdGhpcy5zb2NrZXRzLmluZGV4T2Yoc29ja2V0KVxuICBpZiAocG9zID09PSAtMSkgcmV0dXJuXG4gIFxuICB0aGlzLnNvY2tldHMuc3BsaWNlKHBvcywgMSlcblxuICB2YXIgcGVuZGluZyA9IHRoaXMucmVxdWVzdHMuc2hpZnQoKVxuICBpZiAocGVuZGluZykge1xuICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyByZXF1ZXN0cyBhbmQgYSBzb2NrZXQgZ2V0cyBjbG9zZWQgYSBuZXcgb25lXG4gICAgLy8gbmVlZHMgdG8gYmUgY3JlYXRlZCB0byB0YWtlIG92ZXIgaW4gdGhlIHBvb2wgZm9yIHRoZSBvbmUgdGhhdCBjbG9zZWQuXG4gICAgdGhpcy5jcmVhdGVTb2NrZXQocGVuZGluZywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgICBwZW5kaW5nLnJlcXVlc3Qub25Tb2NrZXQoc29ja2V0KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VjdXJlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBUdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0LmNhbGwoc2VsZiwgb3B0aW9ucywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgLy8gMCBpcyBkdW1teSBwb3J0IGZvciB2MC42XG4gICAgdmFyIHNlY3VyZVNvY2tldCA9IHRscy5jb25uZWN0KDAsIG1lcmdlT3B0aW9ucyh7fSwgc2VsZi5vcHRpb25zLCBcbiAgICAgIHsgc2VydmVybmFtZTogb3B0aW9ucy5ob3N0XG4gICAgICAsIHNvY2tldDogc29ja2V0XG4gICAgICB9XG4gICAgKSlcbiAgICBjYihzZWN1cmVTb2NrZXQpXG4gIH0pXG59XG5cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIG92ZXJyaWRlcyA9IGFyZ3VtZW50c1tpXVxuICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpXG4gICAgICBmb3IgKHZhciBqID0gMCwga2V5TGVuID0ga2V5cy5sZW5ndGg7IGogPCBrZXlMZW47ICsraikge1xuICAgICAgICB2YXIgayA9IGtleXNbal1cbiAgICAgICAgaWYgKG92ZXJyaWRlc1trXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0W2tdID0gb3ZlcnJpZGVzW2tdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5cbnZhciBkZWJ1Z1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL1xcYnR1bm5lbFxcYi8udGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSkge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFyZ3NbMF0gPSAnVFVOTkVMOiAnICsgYXJnc1swXVxuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnVuc2hpZnQoJ1RVTk5FTDonKVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpXG4gIH1cbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7fVxufVxuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnIC8vIGZvciB0ZXN0XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZSAoZm4sIGRlY3ljbGUpIHtcbiAgdmFyIHNlZW4gPSBbXTtcbiAgZGVjeWNsZSA9IGRlY3ljbGUgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlKSB7XG4gICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlKSAhPT0gLTEpXG4gICAgICAgIHJldCA9IGRlY3ljbGUoa2V5LCB2YWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChmbikgcmV0ID0gZm4oa2V5LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgZm4sIHNwYWNlcywgZGVjeWNsZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoZm4sIGRlY3ljbGUpLCBzcGFjZXMpO1xufVxuXG5zdHJpbmdpZnkuZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBGb3JldmVyQWdlbnRcbkZvcmV2ZXJBZ2VudC5TU0wgPSBGb3JldmVyQWdlbnRTU0xcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBBZ2VudCA9IHJlcXVpcmUoJ2h0dHAnKS5BZ2VudFxuICAsIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICwgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgLCBBZ2VudFNTTCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnRcblxuZnVuY3Rpb24gRm9yZXZlckFnZW50KG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgc2VsZi5yZXF1ZXN0cyA9IHt9XG4gIHNlbGYuc29ja2V0cyA9IHt9XG4gIHNlbGYuZnJlZVNvY2tldHMgPSB7fVxuICBzZWxmLm1heFNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWF4U29ja2V0cyB8fCBBZ2VudC5kZWZhdWx0TWF4U29ja2V0c1xuICBzZWxmLm1pblNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWluU29ja2V0cyB8fCBGb3JldmVyQWdlbnQuZGVmYXVsdE1pblNvY2tldHNcbiAgc2VsZi5vbignZnJlZScsIGZ1bmN0aW9uKHNvY2tldCwgaG9zdCwgcG9ydCkge1xuICAgIHZhciBuYW1lID0gaG9zdCArICc6JyArIHBvcnRcbiAgICBpZiAoc2VsZi5yZXF1ZXN0c1tuYW1lXSAmJiBzZWxmLnJlcXVlc3RzW25hbWVdLmxlbmd0aCkge1xuICAgICAgc2VsZi5yZXF1ZXN0c1tuYW1lXS5zaGlmdCgpLm9uU29ja2V0KHNvY2tldClcbiAgICB9IGVsc2UgaWYgKHNlbGYuc29ja2V0c1tuYW1lXS5sZW5ndGggPCBzZWxmLm1pblNvY2tldHMpIHtcbiAgICAgIGlmICghc2VsZi5mcmVlU29ja2V0c1tuYW1lXSkgc2VsZi5mcmVlU29ja2V0c1tuYW1lXSA9IFtdXG4gICAgICBzZWxmLmZyZWVTb2NrZXRzW25hbWVdLnB1c2goc29ja2V0KVxuICAgICAgXG4gICAgICAvLyBpZiBhbiBlcnJvciBoYXBwZW5zIHdoaWxlIHdlIGRvbid0IHVzZSB0aGUgc29ja2V0IGFueXdheSwgbWVoLCB0aHJvdyB0aGUgc29ja2V0IGF3YXlcbiAgICAgIGZ1bmN0aW9uIG9uSWRsZUVycm9yKCkge1xuICAgICAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgICB9XG4gICAgICBzb2NrZXQuX29uSWRsZUVycm9yID0gb25JZGxlRXJyb3JcbiAgICAgIHNvY2tldC5vbignZXJyb3InLCBvbklkbGVFcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgcmVxdWVzdHMganVzdCBkZXN0cm95IHRoZVxuICAgICAgLy8gc29ja2V0IGFuZCBpdCB3aWxsIGdldCByZW1vdmVkIGZyb20gdGhlIHBvb2wuIFRoaXNcbiAgICAgIC8vIGdldHMgdXMgb3V0IG9mIHRpbWVvdXQgaXNzdWVzIGFuZCBhbGxvd3MgdXMgdG9cbiAgICAgIC8vIGRlZmF1bHQgdG8gQ29ubmVjdGlvbjprZWVwLWFsaXZlLlxuICAgICAgc29ja2V0LmRlc3Ryb3koKVxuICAgIH1cbiAgfSlcblxufVxudXRpbC5pbmhlcml0cyhGb3JldmVyQWdlbnQsIEFnZW50KVxuXG5Gb3JldmVyQWdlbnQuZGVmYXVsdE1pblNvY2tldHMgPSA1XG5cblxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gbmV0LmNyZWF0ZUNvbm5lY3Rpb25cbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdE5vcmV1c2UgPSBBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdFxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxLCBob3N0LCBwb3J0KSB7XG4gIHZhciBuYW1lID0gaG9zdCArICc6JyArIHBvcnRcbiAgaWYgKHRoaXMuZnJlZVNvY2tldHNbbmFtZV0gJiYgdGhpcy5mcmVlU29ja2V0c1tuYW1lXS5sZW5ndGggPiAwICYmICFyZXEudXNlQ2h1bmtlZEVuY29kaW5nQnlEZWZhdWx0KSB7XG4gICAgdmFyIGlkbGVTb2NrZXQgPSB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLnBvcCgpXG4gICAgaWRsZVNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlU29ja2V0Ll9vbklkbGVFcnJvcilcbiAgICBkZWxldGUgaWRsZVNvY2tldC5fb25JZGxlRXJyb3JcbiAgICByZXEuX3JldXNlZFNvY2tldCA9IHRydWVcbiAgICByZXEub25Tb2NrZXQoaWRsZVNvY2tldClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZFJlcXVlc3ROb3JldXNlKHJlcSwgaG9zdCwgcG9ydClcbiAgfVxufVxuXG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLnJlbW92ZVNvY2tldCA9IGZ1bmN0aW9uKHMsIG5hbWUsIGhvc3QsIHBvcnQpIHtcbiAgaWYgKHRoaXMuc29ja2V0c1tuYW1lXSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuc29ja2V0c1tuYW1lXS5pbmRleE9mKHMpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5zb2NrZXRzW25hbWVdLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5zb2NrZXRzW25hbWVdICYmIHRoaXMuc29ja2V0c1tuYW1lXS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBkb24ndCBsZWFrXG4gICAgZGVsZXRlIHRoaXMuc29ja2V0c1tuYW1lXVxuICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RzW25hbWVdXG4gIH1cbiAgXG4gIGlmICh0aGlzLmZyZWVTb2NrZXRzW25hbWVdKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHMpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5mcmVlU29ja2V0c1tuYW1lXS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICBpZiAodGhpcy5mcmVlU29ja2V0c1tuYW1lXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZnJlZVNvY2tldHNbbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5yZXF1ZXN0c1tuYW1lXSAmJiB0aGlzLnJlcXVlc3RzW25hbWVdLmxlbmd0aCkge1xuICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyByZXF1ZXN0cyBhbmQgYSBzb2NrZXQgZ2V0cyBjbG9zZWQgYSBuZXcgb25lXG4gICAgLy8gbmVlZHMgdG8gYmUgY3JlYXRlZCB0byB0YWtlIG92ZXIgaW4gdGhlIHBvb2wgZm9yIHRoZSBvbmUgdGhhdCBjbG9zZWQuXG4gICAgdGhpcy5jcmVhdGVTb2NrZXQobmFtZSwgaG9zdCwgcG9ydCkuZW1pdCgnZnJlZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gRm9yZXZlckFnZW50U1NMIChvcHRpb25zKSB7XG4gIEZvcmV2ZXJBZ2VudC5jYWxsKHRoaXMsIG9wdGlvbnMpXG59XG51dGlsLmluaGVyaXRzKEZvcmV2ZXJBZ2VudFNTTCwgRm9yZXZlckFnZW50KVxuXG5Gb3JldmVyQWdlbnRTU0wucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBjcmVhdGVDb25uZWN0aW9uU1NMXG5Gb3JldmVyQWdlbnRTU0wucHJvdG90eXBlLmFkZFJlcXVlc3ROb3JldXNlID0gQWdlbnRTU0wucHJvdG90eXBlLmFkZFJlcXVlc3RcblxuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvblNTTCAocG9ydCwgaG9zdCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBvcnQgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHBvcnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGhvc3QgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGhvc3Q7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwb3J0ID09PSAnbnVtYmVyJykge1xuICAgIG9wdGlvbnMucG9ydCA9IHBvcnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5ob3N0ID0gaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cbiIsIi8qKlxuICogT2JqZWN0I3RvU3RyaW5nKCkgcmVmIGZvciBzdHJpbmdpZnkoKS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIE9iamVjdCNoYXNPd25Qcm9wZXJ0eSByZWZcbiAqL1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFycmF5I2luZGV4T2Ygc2hpbS5cbiAqL1xuXG52YXIgaW5kZXhPZiA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJ1xuICA/IGZ1bmN0aW9uKGFyciwgZWwpIHsgcmV0dXJuIGFyci5pbmRleE9mKGVsKTsgfVxuICA6IGZ1bmN0aW9uKGFyciwgZWwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IGVsKSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4vKipcbiAqIEFycmF5LmlzQXJyYXkgc2hpbS5cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogT2JqZWN0LmtleXMgc2hpbS5cbiAqL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHJldC5wdXNoKGtleSk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEFycmF5I2ZvckVhY2ggc2hpbS5cbiAqL1xuXG52YXIgZm9yRWFjaCA9IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJ1xuICA/IGZ1bmN0aW9uKGFyciwgZm4pIHsgcmV0dXJuIGFyci5mb3JFYWNoKGZuKTsgfVxuICA6IGZ1bmN0aW9uKGFyciwgZm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0pO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkjcmVkdWNlIHNoaW0uXG4gKi9cblxudmFyIHJlZHVjZSA9IGZ1bmN0aW9uKGFyciwgZm4sIGluaXRpYWwpIHtcbiAgaWYgKHR5cGVvZiBhcnIucmVkdWNlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXJyLnJlZHVjZShmbiwgaW5pdGlhbCk7XG4gIHZhciByZXMgPSBpbml0aWFsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcmVzID0gZm4ocmVzLCBhcnJbaV0pO1xuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBudWxsYXJ5IG9iamVjdCBpZiBwb3NzaWJsZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGVcbiAgICA/IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICA6IHt9O1xufVxuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBpc2ludCA9IC9eWzAtOV0rJC87XG5cbmZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgaWYgKHBhcmVudFtrZXldLmxlbmd0aCA9PSAwKSByZXR1cm4gcGFyZW50W2tleV0gPSBjcmVhdGVPYmplY3QoKTtcbiAgdmFyIHQgPSBjcmVhdGVPYmplY3QoKTtcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudFtrZXldLCBpKSkge1xuICAgICAgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICAgIH1cbiAgfVxuICBwYXJlbnRba2V5XSA9IHQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBwYXJzZShwYXJ0cywgcGFyZW50LCBrZXksIHZhbCkge1xuICB2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gIC8vIGVuZFxuICBpZiAoIXBhcnQpIHtcbiAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgIHBhcmVudFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgLy8gYXJyYXlcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2JqID0gcGFyZW50W2tleV0gPSBwYXJlbnRba2V5XSB8fCBbXTtcbiAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKCcnICE9IHZhbCkgb2JqLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICBvYmpbb2JqZWN0S2V5cyhvYmopLmxlbmd0aF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3BcbiAgICB9IGVsc2UgaWYgKH5pbmRleE9mKHBhcnQsICddJykpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnN1YnN0cigwLCBwYXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgICAgLy8ga2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBwYXJlbnQga2V5L3ZhbCBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHBhcmVudCwga2V5LCB2YWwpe1xuICBpZiAofmluZGV4T2Yoa2V5LCAnXScpKSB7XG4gICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICwgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAsIGxhc3QgPSBsZW4gLSAxO1xuICAgIHBhcnNlKHBhcnRzLCBwYXJlbnQsICdiYXNlJywgdmFsKTtcbiAgICAvLyBvcHRpbWl6ZVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICB2YXIgdCA9IGNyZWF0ZU9iamVjdCgpO1xuICAgICAgZm9yICh2YXIgayBpbiBwYXJlbnQuYmFzZSkgdFtrXSA9IHBhcmVudC5iYXNlW2tdO1xuICAgICAgcGFyZW50LmJhc2UgPSB0O1xuICAgIH1cbiAgICBzZXQocGFyZW50LmJhc2UsIGtleSwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8qKlxuICogQ29tcGFjdCBzcGFyc2UgYXJyYXlzLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBhY3Qob2JqKSB7XG4gIGlmICgnb2JqZWN0JyAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkge1xuICAgICAgICByZXQucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgb2JqW2tleV0gPSBjb21wYWN0KG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUmVzdG9yZSBPYmplY3QucHJvdG90eXBlLlxuICogc2VlIHB1bGwtcmVxdWVzdCAjNThcbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlUHJvdG8ob2JqKSB7XG4gIGlmICghT2JqZWN0LmNyZWF0ZSkgcmV0dXJuIG9iajtcbiAgaWYgKGlzQXJyYXkob2JqKSkgcmV0dXJuIG9iajtcbiAgaWYgKG9iaiAmJiAnb2JqZWN0JyAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIG9ialtrZXldID0gcmVzdG9yZVByb3RvKG9ialtrZXldKTtcbiAgICB9XG4gIH1cblxuICBvYmouX19wcm90b19fID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gb2JqLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iail7XG4gIHZhciByZXQgPSB7IGJhc2U6IHt9IH07XG5cbiAgZm9yRWFjaChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKG5hbWUpe1xuICAgIG1lcmdlKHJldCwgbmFtZSwgb2JqW25hbWVdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbXBhY3QocmV0LmJhc2UpO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBzdHIuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKXtcbiAgdmFyIHJldCA9IHJlZHVjZShTdHJpbmcoc3RyKS5zcGxpdCgnJicpLCBmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgIHZhciBlcWwgPSBpbmRleE9mKHBhaXIsICc9JylcbiAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgLCBrZXkgPSBwYWlyLnN1YnN0cigwLCBicmFjZSB8fCBlcWwpXG4gICAgICAsIHZhbCA9IHBhaXIuc3Vic3RyKGJyYWNlIHx8IGVxbCwgcGFpci5sZW5ndGgpXG4gICAgICAsIHZhbCA9IHZhbC5zdWJzdHIoaW5kZXhPZih2YWwsICc9JykgKyAxLCB2YWwubGVuZ3RoKTtcblxuICAgIC8vID9mb29cbiAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcbiAgICBpZiAoJycgPT0ga2V5KSByZXR1cm4gcmV0O1xuXG4gICAgcmV0dXJuIG1lcmdlKHJldCwgZGVjb2RlKGtleSksIGRlY29kZSh2YWwpKTtcbiAgfSwgeyBiYXNlOiBjcmVhdGVPYmplY3QoKSB9KS5iYXNlO1xuXG4gIHJldHVybiByZXN0b3JlUHJvdG8oY29tcGFjdChyZXQpKTtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gcXVlcnkgYHN0cmAgb3IgYG9iamAsIHJldHVybmluZyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB8IHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKG51bGwgPT0gc3RyIHx8ICcnID09IHN0cikgcmV0dXJuIHt9O1xuICByZXR1cm4gJ29iamVjdCcgPT0gdHlwZW9mIHN0clxuICAgID8gcGFyc2VPYmplY3Qoc3RyKVxuICAgIDogcGFyc2VTdHJpbmcoc3RyKTtcbn07XG5cbi8qKlxuICogVHVybiB0aGUgZ2l2ZW4gYG9iamAgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT0gdG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcob2JqLCBwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXggKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG9iaikpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaW5nKHN0ciwgcHJlZml4KSB7XG4gIGlmICghcHJlZml4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdpZnkgZXhwZWN0cyBhbiBvYmplY3QnKTtcbiAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChzdHIpO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYGFycmAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheShhcnIsIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW107XG4gIGlmICghcHJlZml4KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdpZnkgZXhwZWN0cyBhbiBvYmplY3QnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICByZXQucHVzaChzdHJpbmdpZnkoYXJyW2ldLCBwcmVmaXggKyAnWycgKyBpICsgJ10nKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3Qob2JqLCBwcmVmaXgpIHtcbiAgdmFyIHJldCA9IFtdXG4gICAgLCBrZXlzID0gb2JqZWN0S2V5cyhvYmopXG4gICAgLCBrZXk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgnJyA9PSBrZXkpIGNvbnRpbnVlO1xuICAgIGlmIChudWxsID09IG9ialtrZXldKSB7XG4gICAgICByZXQucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wdXNoKHN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4XG4gICAgICAgID8gcHJlZml4ICsgJ1snICsgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnXSdcbiAgICAgICAgOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQuam9pbignJicpO1xufVxuXG4vKipcbiAqIFNldCBgb2JqYCdzIGBrZXlgIHRvIGB2YWxgIHJlc3BlY3RpbmdcbiAqIHRoZSB3ZWlyZCBhbmQgd29uZGVyZnVsIHN5bnRheCBvZiBhIHFzLFxuICogd2hlcmUgXCJmb289YmFyJmZvbz1iYXpcIiBiZWNvbWVzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIHZhciB2ID0gb2JqW2tleV07XG4gIGlmICh1bmRlZmluZWQgPT09IHYpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHYpKSB7XG4gICAgdi5wdXNoKHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSBbdiwgdmFsXTtcbiAgfVxufVxuXG4vKipcbiAqIExvY2F0ZSBsYXN0IGJyYWNlIGluIGBzdHJgIHdpdGhpbiB0aGUga2V5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxhc3RCcmFjZUluS2V5KHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aFxuICAgICwgYnJhY2VcbiAgICAsIGM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjID0gc3RyW2ldO1xuICAgIGlmICgnXScgPT0gYykgYnJhY2UgPSBmYWxzZTtcbiAgICBpZiAoJ1snID09IGMpIGJyYWNlID0gdHJ1ZTtcbiAgICBpZiAoJz0nID09IGMgJiYgIWJyYWNlKSByZXR1cm4gaTtcbiAgfVxufVxuXG4vKipcbiAqIERlY29kZSBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iLCJ2YXIgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4veG1wcC9jb25uZWN0aW9uJyk7XG52YXIgQ2xpZW50ID0gcmVxdWlyZSgnLi94bXBwL2NsaWVudCcpLkNsaWVudDtcbnZhciBKSUQgPSByZXF1aXJlKCcuL3htcHAvamlkJyk7XG52YXIgbHR4ID0gcmVxdWlyZSgnbHR4Jyk7XG52YXIgU3RhbnphID0gcmVxdWlyZSgnLi94bXBwL3N0YW56YScpO1xuXG5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG5leHBvcnRzLkpJRCA9IEpJRDtcbmV4cG9ydHMuRWxlbWVudCA9IGx0eC5FbGVtZW50O1xuZXhwb3J0cy5TdGFuemEgPSBTdGFuemEuU3RhbnphO1xuZXhwb3J0cy5NZXNzYWdlID0gU3RhbnphLk1lc3NhZ2U7XG5leHBvcnRzLlByZXNlbmNlID0gU3RhbnphLlByZXNlbmNlO1xuZXhwb3J0cy5JcSA9IFN0YW56YS5JcTtcblxud2luZG93LlhNUFAgPSBleHBvcnRzO1xuIiwiZXhwb3J0cy5yZWFkSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0JFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0JFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0JFID8gMSA6IC0xLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGVJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzQkUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzQkUgPyAtMSA6IDEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIihmdW5jdGlvbigpe3ZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyO1xuQnVmZmVyLnBvb2xTaXplID0gODE5MjtcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuZnVuY3Rpb24gQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KTtcbiAgfVxuICB0aGlzLnBhcmVudCA9IHRoaXM7XG4gIHRoaXMub2Zmc2V0ID0gMDtcblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIGxlbmd0aFxuICAgIHN3aXRjaCAodHlwZSA9IHR5cGVvZiBzdWJqZWN0KSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzogLy8gQXNzdW1lIG9iamVjdCBpcyBhbiBhcnJheVxuICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcnJheSBvciBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5LlxuICAgIGlmIChpc0FycmF5SXNoKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN1YmplY3QgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpc1tpXSA9IHN1YmplY3RbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzW2ldO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXNbaV0gPSB2O1xufTtcblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGg7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGg7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlXcml0ZSA9IEJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZTtcblxuQnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iYXNlNjRTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLmZyb21CeXRlQXJyYXkoYnl0ZXMpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmVzID0gXCJcIjtcbiAgdmFyIHRtcCA9IFwiXCI7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXNbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICAgIHRtcCA9IFwiXCI7XG4gICAgfSBlbHNlXG4gICAgICB0bXAgKz0gXCIlXCIgKyBieXRlc1tpXS50b1N0cmluZygxNik7XG5cbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJldCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICByZXR1cm4gcmV0O1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlO1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KHRoaXNbaV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDI7XG4gIHJldHVybiBpO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgaXNOYU4oZW5kKSkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG4gIHRhcmdldF9zdGFydCB8fCAodGFyZ2V0X3N0YXJ0ID0gMCk7XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0Jyk7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRhcmdldC5sZW5ndGggPT0gMCB8fCBzb3VyY2UubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnQ7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICBmb3IgKHZhciBpPXN0YXJ0OyBpPGVuZDsgaSsrKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiB0aGlzW2ldICE9PSAndW5kZWZpbmVkJywgXCJjb3B5aW5nIHVuZGVmaW5lZCBidWZmZXIgYnl0ZXMhXCIpO1xuICAgIHRlbXAucHVzaCh0aGlzW2ldKTtcbiAgfVxuXG4gIGZvciAodmFyIGk9dGFyZ2V0X3N0YXJ0OyBpPHRhcmdldF9zdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldF9zdGFydF07XG4gIH1cbn07XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vLyBTdGF0aWMgbWV0aG9kc1xuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICByZXR1cm4gYiBpbnN0YW5jZW9mIEJ1ZmZlciB8fCBiIGluc3RhbmNlb2YgQnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gaGVscGVyc1xuXG5mdW5jdGlvbiBjb2VyY2UobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aCk7XG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fFxuICAgIGZ1bmN0aW9uKHN1YmplY3Qpe1xuICAgICAgcmV0dXJuIHt9LnRvU3RyaW5nLmFwcGx5KHN1YmplY3QpID09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9KVxuICAgIChzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhcihzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCk7IC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8vIHJlYWQvd3JpdGUgYml0LXR3aWRkbGluZ1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgcmV0dXJuIGJ1ZmZlcltvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4O1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdmFsIHw9IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyW29mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDFdIDw8IDg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiAwO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXQgKyAxXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlcltvZmZzZXQgKyAzXTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyW29mZnNldF0gPDwgMjQgPj4+IDApO1xuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDFdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlcltvZmZzZXRdO1xuICAgIGlmIChvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCA9IHZhbCArIChidWZmZXJbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyW29mZnNldF0gJiAweDgwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAoYnVmZmVyW29mZnNldF0pO1xuICB9XG5cbiAgcmV0dXJuICgoMHhmZiAtIGJ1ZmZlcltvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSsrKSB7XG4gICAgYnVmZmVyW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAoaXNCaWdFbmRpYW4gPyAxIC0gaSA6IGkpKSkpID4+PlxuICAgICAgICAgICAgKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSAqIDg7XG4gIH1cblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4oYnVmZmVyLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkrKykge1xuICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG59KSgpIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2Z1bmN0aW9uIGZpbHRlciAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gUmVnZXggdG8gc3BsaXQgYSBmaWxlbmFtZSBpbnRvIFsqLCBkaXIsIGJhc2VuYW1lLCBleHRdXG4vLyBwb3NpeCB2ZXJzaW9uXG52YXIgc3BsaXRQYXRoUmUgPSAvXiguK1xcLyg/ISQpfFxcLyk/KCg/Oi4rPyk/KFxcLlteLl0qKT8pJC87XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xudmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICB2YXIgcGF0aCA9IChpID49IDApXG4gICAgICA/IGFyZ3VtZW50c1tpXVxuICAgICAgOiBwcm9jZXNzLmN3ZCgpO1xuXG4gIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnIHx8ICFwYXRoKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbi8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xudmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nO1xuXG4vLyBOb3JtYWxpemUgdGhlIHBhdGhcbnBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cbiAgXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIHJldHVybiBwICYmIHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgZGlyID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVsxXSB8fCAnJztcbiAgdmFyIGlzV2luZG93cyA9IGZhbHNlO1xuICBpZiAoIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWVcbiAgICByZXR1cm4gJy4nO1xuICB9IGVsc2UgaWYgKGRpci5sZW5ndGggPT09IDEgfHxcbiAgICAgIChpc1dpbmRvd3MgJiYgZGlyLmxlbmd0aCA8PSAzICYmIGRpci5jaGFyQXQoMSkgPT09ICc6JykpIHtcbiAgICAvLyBJdCBpcyBqdXN0IGEgc2xhc2ggb3IgYSBkcml2ZSBsZXR0ZXIgd2l0aCBhIHNsYXNoXG4gICAgcmV0dXJuIGRpcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJdCBpcyBhIGZ1bGwgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICByZXR1cm4gZGlyLnN1YnN0cmluZygwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbMl0gfHwgJyc7XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVszXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCIvLyBub3RoaW5nIHRvIHNlZSBoZXJlLi4uIG5vIGZpbGUgbWV0aG9kcyBmb3IgdGhlIGJyb3dzZXJcbiIsIi8qIVxuICogVG9iaSAtIENvb2tpZVxuICogQ29weXJpZ2h0KGMpIDIwMTAgTGVhcm5Cb29zdCA8ZGV2QGxlYXJuYm9vc3QuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDb29raWVgIHdpdGggdGhlIGdpdmVuIGNvb2tpZSBgc3RyYCBhbmQgYHJlcWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtJbmNvbWluZ1JlcXVlc3R9IHJlcVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIENvb2tpZSA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENvb2tpZShzdHIsIHJlcSkge1xuICB0aGlzLnN0ciA9IHN0cjtcblxuICAvLyBNYXAgdGhlIGtleS92YWwgcGFpcnNcbiAgc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZShmdW5jdGlvbihvYmosIHBhaXIpe1xuICAgdmFyIHAgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgIHZhciBrZXkgPSBwID4gMCA/IHBhaXIuc3Vic3RyaW5nKDAsIHApLnRyaW0oKSA6IHBhaXIudHJpbSgpO1xuICAgdmFyIGxvd2VyQ2FzZWRLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgIHZhciB2YWx1ZSA9IHAgPiAwID8gcGFpci5zdWJzdHJpbmcocCArIDEpLnRyaW0oKSA6IHRydWU7XG5cbiAgIGlmICghb2JqLm5hbWUpIHtcbiAgICAvLyBGaXJzdCBrZXkgaXMgdGhlIG5hbWVcbiAgICBvYmoubmFtZSA9IGtleTtcbiAgICBvYmoudmFsdWUgPSB2YWx1ZTtcbiAgIH1cbiAgIGVsc2UgaWYgKGxvd2VyQ2FzZWRLZXkgPT09ICdodHRwb25seScpIHtcbiAgICBvYmouaHR0cE9ubHkgPSB2YWx1ZTtcbiAgIH1cbiAgIGVsc2Uge1xuICAgIG9ialtsb3dlckNhc2VkS2V5XSA9IHZhbHVlO1xuICAgfVxuICAgcmV0dXJuIG9iajtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gRXhwaXJlc1xuICB0aGlzLmV4cGlyZXMgPSB0aGlzLmV4cGlyZXNcbiAgICA/IG5ldyBEYXRlKHRoaXMuZXhwaXJlcylcbiAgICA6IEluZmluaXR5O1xuXG4gIC8vIERlZmF1bHQgb3IgdHJpbSBwYXRoXG4gIHRoaXMucGF0aCA9IHRoaXMucGF0aFxuICAgID8gdGhpcy5wYXRoLnRyaW0oKTogcmVxIFxuICAgID8gdXJsLnBhcnNlKHJlcS51cmwpLnBhdGhuYW1lOiAnLyc7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgb3JpZ2luYWwgY29va2llIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvb2tpZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5zdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5KYXIgPSByZXF1aXJlKCcuL2phcicpIiwiLy8gVGFyZ2V0IEFQSTpcbi8vXG4vLyAgdmFyIHMgPSByZXF1aXJlKCduZXQnKS5jcmVhdGVTdHJlYW0oMjUsICdzbXRwLmV4YW1wbGUuY29tJyk7XG4vLyAgcy5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuLy8gICByZXF1aXJlKCdzdGFydHRscycpKHMsIGNyZWRzLCBmYWxzZSwgZnVuY3Rpb24oKSB7XG4vLyAgICAgIGlmICghcy5hdXRob3JpemVkKSB7XG4vLyAgICAgICAgcy5kZXN0cm95KCk7XG4vLyAgICAgICAgcmV0dXJuO1xuLy8gICAgICB9XG4vL1xuLy8gICAgICBzLmVuZChcImhlbGxvIHdvcmxkXFxuXCIpO1xuLy8gICAgfSk7XG4vLyAgfSk7XG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciB0bHMgPSByZXF1aXJlKCd0bHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdGFydHRscyhzb2NrZXQsIGNyZWRlbnRpYWxzLCBpc1NlcnZlciwgY2IpIHtcblxuICB2YXIgcGFpciA9IHRscy5jcmVhdGVTZWN1cmVQYWlyKGNyZWRlbnRpYWxzLCBpc1NlcnZlciwgZmFsc2UsICFpc1NlcnZlcik7XG5cbiAgdmFyIGNsZWFydGV4dCA9IHBpcGUocGFpciwgc29ja2V0KTtcblxuICBwYWlyLm9uKCdzZWN1cmUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3NsID0gcGFpci5fc3NsIHx8IHBhaXIuc3NsO1xuICAgIHZhciB2ZXJpZnlFcnJvciA9IHNzbC52ZXJpZnlFcnJvcigpO1xuXG4gICAgaWYgKHZlcmlmeUVycm9yKSB7XG4gICAgICBjbGVhcnRleHQuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgICAgY2xlYXJ0ZXh0LmF1dGhvcml6YXRpb25FcnJvciA9IHZlcmlmeUVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhcnRleHQuYXV0aG9yaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNiKSBjYigpO1xuICB9KTtcblxuICBjbGVhcnRleHQuX2NvbnRyb2xSZWxlYXNlZCA9IHRydWU7XG4gIHJldHVybiBjbGVhcnRleHQ7XG59O1xuXG5cbmZ1bmN0aW9uIHBpcGUocGFpciwgc29ja2V0KSB7XG4gIHBhaXIuZW5jcnlwdGVkLnBpcGUoc29ja2V0KTtcbiAgc29ja2V0LnBpcGUocGFpci5lbmNyeXB0ZWQpO1xuXG4gIHBhaXIuZmQgPSBzb2NrZXQuZmQ7XG4gIHZhciBjbGVhcnRleHQgPSBwYWlyLmNsZWFydGV4dDtcbiAgY2xlYXJ0ZXh0LnNvY2tldCA9IHNvY2tldDtcbiAgY2xlYXJ0ZXh0LmVuY3J5cHRlZCA9IHBhaXIuZW5jcnlwdGVkO1xuICBjbGVhcnRleHQuYXV0aG9yaXplZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZSkge1xuICAgIGlmIChjbGVhcnRleHQuX2NvbnRyb2xSZWxlYXNlZCkge1xuICAgICAgY2xlYXJ0ZXh0LmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgc29ja2V0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzb2NrZXQub24oJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgcmV0dXJuIGNsZWFydGV4dDtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDExIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgc2lnbmVyID0gcmVxdWlyZSgnLi9zaWduZXInKTtcbnZhciB2ZXJpZnkgPSByZXF1aXJlKCcuL3ZlcmlmeScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcGFyc2U6IHBhcnNlci5wYXJzZVJlcXVlc3QsXG4gIHBhcnNlUmVxdWVzdDogcGFyc2VyLnBhcnNlUmVxdWVzdCxcblxuICBzaWduOiBzaWduZXIuc2lnblJlcXVlc3QsXG4gIHNpZ25SZXF1ZXN0OiBzaWduZXIuc2lnblJlcXVlc3QsXG5cbiAgc3NoS2V5VG9QRU06IHV0aWwuc3NoS2V5VG9QRU0sXG4gIHNzaEtleUZpbmdlcnByaW50OiB1dGlsLmZpbmdlcnByaW50LFxuXG4gIHZlcmlmeTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5U2lnbmF0dXJlOiB2ZXJpZnkudmVyaWZ5U2lnbmF0dXJlXG59O1xuIiwiKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudmFyIFJlc3BvbnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlID0gbmV3IFN0cmVhbTtcblxudmFyIGNhcGFibGUgPSB7XG4gICAgc3RyZWFtaW5nIDogdHJ1ZSxcbiAgICBzdGF0dXMyIDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChyZXMpIHtcbiAgICB2YXIgbGluZXMgPSByZXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmUgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtWzFdLnRvTG93ZXJDYXNlKCksIHZhbHVlID0gbVsyXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFsgaGVhZGVyc1trZXldLCB2YWx1ZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyc1tsaW5lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICB2YXIgcmVzcFR5cGUgPSBTdHJpbmcoeGhyLnJlc3BvbnNlVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVzcFR5cGUgPT09ICdibG9iJykgcmV0dXJuIHhoci5yZXNwb25zZUJsb2IgfHwgeGhyLnJlc3BvbnNlO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5yZWFkeVN0YXRlID09PSAyICYmIGNhcGFibGUuc3RhdHVzMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RhdHVzMiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwYWJsZS5zdHJlYW1pbmcgJiYgcmVzLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge31cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdERhdGEocmVzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzLmdldFJlc3BvbnNlKHJlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX2VtaXREYXRhID0gZnVuY3Rpb24gKHJlcykge1xuICAgIHZhciByZXNwQm9keSA9IHRoaXMuZ2V0UmVzcG9uc2UocmVzKTtcbiAgICBpZiAocmVzcEJvZHkudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXlCdWZmZXIvKSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBuZXcgVWludDhBcnJheShyZXNwQm9keSwgdGhpcy5vZmZzZXQpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSByZXNwQm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwQm9keS5sZW5ndGggPiB0aGlzLm9mZnNldCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXNwQm9keS5zbGljZSh0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5Lmxlbmd0aDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4qIFRvYmkgLSBDb29raWVKYXJcbiogQ29weXJpZ2h0KGMpIDIwMTAgTGVhcm5Cb29zdCA8ZGV2QGxlYXJuYm9vc3QuY29tPlxuKiBNSVQgTGljZW5zZWRcbiovXG5cbi8qKlxuKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4vKipcbiogSW5pdGlhbGl6ZSBhIG5ldyBgQ29va2llSmFyYC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG52YXIgQ29va2llSmFyID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ29va2llSmFyKCkge1xuICB0aGlzLmNvb2tpZXMgPSBbXTtcbn07XG5cbi8qKlxuKiBBZGQgdGhlIGdpdmVuIGBjb29raWVgIHRvIHRoZSBqYXIuXG4qXG4qIEBwYXJhbSB7Q29va2llfSBjb29raWVcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Db29raWVKYXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvb2tpZSl7XG4gIHRoaXMuY29va2llcyA9IHRoaXMuY29va2llcy5maWx0ZXIoZnVuY3Rpb24oYyl7XG4gICAgLy8gQXZvaWQgZHVwbGljYXRpb24gKHNhbWUgcGF0aCwgc2FtZSBuYW1lKVxuICAgIHJldHVybiAhKGMubmFtZSA9PSBjb29raWUubmFtZSAmJiBjLnBhdGggPT0gY29va2llLnBhdGgpO1xuICB9KTtcbiAgdGhpcy5jb29raWVzLnB1c2goY29va2llKTtcbn07XG5cbi8qKlxuKiBHZXQgY29va2llcyBmb3IgdGhlIGdpdmVuIGByZXFgLlxuKlxuKiBAcGFyYW0ge0luY29taW5nUmVxdWVzdH0gcmVxXG4qIEByZXR1cm4ge0FycmF5fVxuKiBAYXBpIHByaXZhdGVcbiovXG5cbkNvb2tpZUphci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocmVxKXtcbiAgdmFyIHBhdGggPSB1cmwucGFyc2UocmVxLnVybCkucGF0aG5hbWVcbiAgICAsIG5vdyA9IG5ldyBEYXRlXG4gICAgLCBzcGVjaWZpY2l0eSA9IHt9O1xuICByZXR1cm4gdGhpcy5jb29raWVzLmZpbHRlcihmdW5jdGlvbihjb29raWUpe1xuICAgIGlmICgwID09IHBhdGguaW5kZXhPZihjb29raWUucGF0aCkgJiYgbm93IDwgY29va2llLmV4cGlyZXNcbiAgICAgICYmIGNvb2tpZS5wYXRoLmxlbmd0aCA+IChzcGVjaWZpY2l0eVtjb29raWUubmFtZV0gfHwgMCkpXG4gICAgICByZXR1cm4gc3BlY2lmaWNpdHlbY29va2llLm5hbWVdID0gY29va2llLnBhdGgubGVuZ3RoO1xuICB9KTtcbn07XG5cbi8qKlxuKiBSZXR1cm4gQ29va2llIHN0cmluZyBmb3IgdGhlIGdpdmVuIGByZXFgLlxuKlxuKiBAcGFyYW0ge0luY29taW5nUmVxdWVzdH0gcmVxXG4qIEByZXR1cm4ge1N0cmluZ31cbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Db29raWVKYXIucHJvdG90eXBlLmNvb2tpZVN0cmluZyA9IGZ1bmN0aW9uKHJlcSl7XG4gIHZhciBjb29raWVzID0gdGhpcy5nZXQocmVxKTtcbiAgaWYgKGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNvb2tpZXMubWFwKGZ1bmN0aW9uKGNvb2tpZSl7XG4gICAgICByZXR1cm4gY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWU7XG4gICAgfSkuam9pbignOyAnKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCIvKiBDYXVzZSBicm93c2VyaWZ5IHRvIGJ1bmRsZSBTQVggcGFyc2VyczogKi9cbi8vcmVxdWlyZSgnLi9zYXhfZWFzeXNheCcpO1xuLy9yZXF1aXJlKCcuL3NheF9zYXhqcycpO1xucmVxdWlyZSgnLi9zYXhfbHR4Jyk7XG5cbi8qIFNISU0gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbmRleCcpOyIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG52YXIgQk9TSCA9IHJlcXVpcmUoJy4vYm9zaCcpO1xudmFyIFdlYlNvY2tldHMgPSByZXF1aXJlKCcuL3dlYnNvY2tldHMnKTtcbnZhciBKSUQgPSByZXF1aXJlKCcuL2ppZCcpLkpJRDtcbnZhciB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBTUlYgPSByZXF1aXJlKCcuL3NydicpO1xuXG5mdW5jdGlvbiBTZXNzaW9uKG9wdHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIG9wdHMuamlkID09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLmppZCA9IG5ldyBKSUQob3B0cy5qaWQpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5qaWQgPSBvcHRzLmppZDtcbiAgICB0aGlzLnBhc3N3b3JkID0gb3B0cy5wYXNzd29yZDtcbiAgICB0aGlzLnByZWZlcnJlZFNhc2xNZWNoYW5pc20gPSBvcHRzLnByZWZlcnJlZFNhc2xNZWNoYW5pc207XG4gICAgdGhpcy5hdmFpbGFibGVTYXNsTWVjaGFuaXNtcyA9IFtdO1xuICAgIHRoaXMuYXBpX2tleSA9IG9wdHMuYXBpX2tleTtcbiAgICB0aGlzLmFjY2Vzc190b2tlbiA9IG9wdHMuYWNjZXNzX3Rva2VuO1xuICAgIHRoaXMub2F1dGgyX3Rva2VuID0gb3B0cy5vYXV0aDJfdG9rZW47XG4gICAgdGhpcy5vYXV0aDJfYXV0aCA9IG9wdHMub2F1dGgyX2F1dGg7XG4gICAgdGhpcy5yZWdpc3RlciA9IG9wdHMucmVnaXN0ZXI7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmFjdEFzID09ICdzdHJpbmcnKSBcbiAgICBcdHRoaXMuYWN0QXMgPSBuZXcgSklEKG9wdHMuYWN0QXMpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5hY3RBcyA9IG9wdHMuYWN0QXM7XG4gICAgZGVsZXRlIHRoaXMuZGlkX2JpbmQ7XG4gICAgZGVsZXRlIHRoaXMuZGlkX3Nlc3Npb247XG5cbiAgICBpZiAob3B0cy53ZWJzb2NrZXRzVVJMKSB7XG5cdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXRzLldTQ29ubmVjdGlvbihvcHRzLndlYnNvY2tldHNVUkwpO1xuXHR0aGlzLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSlcblx0XHRzZWxmLmNvbm5lY3Rpb24uc3RhcnRTdHJlYW0oKTtcblx0fSk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmJvc2hVUkwpIHtcblx0dGhpcy5jb25uZWN0aW9uID0gbmV3IEJPU0guQk9TSENvbm5lY3Rpb24oe1xuXHQgICAgamlkOiB0aGlzLmppZCxcblx0ICAgIGJvc2hVUkw6IG9wdHMuYm9zaFVSTFxuXHR9KTtcbiAgICB9IGVsc2Uge1xuXHR0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbi5Db25uZWN0aW9uKHtcblx0ICAgIHhtbG5zOiB7ICcnOiBvcHRzLnhtbG5zIH0sXG5cdCAgICBzdHJlYW1BdHRyczoge1xuXHRcdHZlcnNpb246IFwiMS4wXCIsXG5cdFx0dG86IHRoaXMuamlkLmRvbWFpblxuXHQgICAgfVxuXHR9KTtcblx0dmFyIGNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmIChvcHRzLmhvc3QpIHtcbiAgICBcdCAgICBzZWxmLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpIHtcbiAgICBcdCAgICAgICAgaWYgKHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSlcbiAgICBcdFx0ICAgICAgICBzZWxmLmNvbm5lY3Rpb24uc3RhcnRTdHJlYW0oKTtcbiAgICBcdCAgICB9KTtcblxuXHQgICAgICAgIGlmIChvcHRzLmxlZ2FjeVNTTCkge1xuXHQgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uYWxsb3dUTFMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLnNvY2tldCA9IHRscy5jb25uZWN0KG9wdHMucG9ydCB8fCA1MjIzLCBvcHRzLmhvc3QsIG9wdHMuY3JlZGVudGlhbHMgfHwge30sIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLnNldHVwU3RyZWFtKCk7XG5cdCAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uc3RhcnRQYXJzZXIoKTtcbiAgICAgICAgICAgIFx0ICAgIHNlbGYuY29ubmVjdGlvbi5lbWl0KCdjb25uZWN0Jyk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG5cdCAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uY3JlZGVudGlhbHMgPSBjcnlwdG8uY3JlYXRlQ3JlZGVudGlhbHMob3B0cy5jcmVkZW50aWFscyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLnNvY2tldC5vbihcImNvbm5lY3RcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uZW1pdCgnY29ubmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29ubmVjdGlvbi5zb2NrZXQuY29ubmVjdChvcHRzLnBvcnQgfHwgNTIyMiwgb3B0cy5ob3N0KTtcbiAgICBcdFx0fVxuXHQgICAgfSBlbHNlIGlmICghU1JWKSB7XG5cdFx0ICAgIHRocm93IFwiQ2Fubm90IGxvYWQgU1JWXCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChvcHRzLmxlZ2FjeVNTTCkge1xuXHQgICAgICAgICAgICB0aHJvdyBcIkxlZ2FjeVNTTCBtb2RlIGRvZXMgbm90IHN1cHBvcnQgRE5TIGxvb2t1cHNcIjtcblx0ICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLmNyZWRlbnRpYWxzID0gY3J5cHRvLmNyZWF0ZUNyZWRlbnRpYWxzKG9wdHMuY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgfVxuXHQgICAgICAgIFxuXHRcdCAgICB2YXIgYXR0ZW1wdCA9IFNSVi5jb25uZWN0KHNlbGYuY29ubmVjdGlvbi5zb2NrZXQsXG5cdFx0ICAgICAgICBbJ194bXBwLWNsaWVudC5fdGNwJ10sIHNlbGYuamlkLmRvbWFpbiwgNTIyMik7XG5cdFx0ICAgIGF0dGVtcHQuYWRkTGlzdGVuZXIoJ2Nvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHQgICAgaWYgKHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSlcblx0XHRcdCAgICBzZWxmLmNvbm5lY3Rpb24uc3RhcnRTdHJlYW0oKTtcblx0XHR9KTtcblx0XHRhdHRlbXB0LmFkZExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcblx0XHQgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpO1xuXHRcdH0pO1xuXHQgICAgfVxuXHR9O1xuXHRpZiAob3B0cy5yZWNvbm5lY3QpXG5cdCAgICBzZWxmLnJlY29ubmVjdCA9IGNvbm5lY3Q7XG5cdGNvbm5lY3QoKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZExpc3RlbmVyKCdzdGFuemEnLCB0aGlzLm9uU3RhbnphLmJpbmQodGhpcykpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRMaXN0ZW5lcignZHJhaW4nLCB0aGlzLmVtaXQuYmluZCh0aGlzLCAnZHJhaW4nKSk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24uYWRkTGlzdGVuZXIoJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFNlc3Npb24sIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLlNlc3Npb24gPSBTZXNzaW9uO1xuXG5cblNlc3Npb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucGF1c2UpXG5cdHRoaXMuY29ubmVjdGlvbi5wYXVzZSgpO1xufTtcblxuU2Vzc2lvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucmVzdW1lKVxuXHR0aGlzLmNvbm5lY3Rpb24ucmVzdW1lKCk7XG59O1xuXG5TZXNzaW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbilcblx0dGhpcy5jb25uZWN0aW9uLnNlbmQoc3RhbnphLnJvb3QoKSk7XG59O1xuXG5TZXNzaW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uKVxuXHR0aGlzLmNvbm5lY3Rpb24uZW5kKCk7XG59O1xuXG5TZXNzaW9uLnByb3RvdHlwZS5vblN0YW56YSA9IGZ1bmN0aW9uKHN0YW56YSkge1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG5jb25zdCBTVEFURV9URVhUID0gMCxcbiAgICBTVEFURV9JR05PUkVfVEFHID0gMSxcbiAgICBTVEFURV9UQUdfTkFNRSA9IDIsXG4gICAgU1RBVEVfVEFHID0gMyxcbiAgICBTVEFURV9BVFRSX05BTUUgPSA0LFxuICAgIFNUQVRFX0FUVFJfRVEgPSA1LFxuICAgIFNUQVRFX0FUVFJfUVVPVCA9IDYsXG4gICAgU1RBVEVfQVRUUl9WQUxVRSA9IDc7XG5cbnZhciBSRV9UQUdfTkFNRSA9IC9eW15cXHNcXC8+XSskLyxcbiAgICBSRV9BVFRSX05BTUUgPSAvXlteXFxzPV0rJC87XG5cbnZhciBTYXhMdHggPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNheEx0eCgpIHtcbiAgICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc3RhdGUgPSBTVEFURV9URVhULCByZW1haW5kZXI7XG4gICAgdmFyIHRhZ05hbWUsIGF0dHJzLCBlbmRUYWcsIHNlbGZDbG9zaW5nLCBhdHRyUXVvdGU7XG4gICAgdmFyIHJlY29yZFN0YXJ0ID0gMDtcblxuICAgIHRoaXMud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG5cdGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpXG5cdCAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB2YXIgcG9zID0gMFxuICAgICAgICB2YXIgYXR0ck5hbWVcblxuXHQvKiBBbnl0aGluZyBmcm9tIHByZXZpb3VzIHdyaXRlKCk/ICovXG5cdGlmIChyZW1haW5kZXIpIHtcblx0ICAgIGRhdGEgPSByZW1haW5kZXIgKyBkYXRhO1xuXHQgICAgcG9zICs9IHJlbWFpbmRlci5sZW5ndGg7XG5cdCAgICBkZWxldGUgcmVtYWluZGVyO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5kUmVjb3JkaW5nKCkge1xuXHQgICAgaWYgKHR5cGVvZiByZWNvcmRTdGFydCA9PT0gJ251bWJlcicpIHtcblx0XHR2YXIgcmVjb3JkZWQgPSBkYXRhLnNsaWNlKHJlY29yZFN0YXJ0LCBwb3MpO1xuXHRcdHJlY29yZFN0YXJ0ID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiByZWNvcmRlZDtcblx0ICAgIH1cblx0fVxuXG5cdGZvcig7IHBvcyA8IGRhdGEubGVuZ3RoOyBwb3MrKykge1xuXHQgICAgdmFyIGMgPSBkYXRhLmNoYXJDb2RlQXQocG9zKTtcblx0ICAgIC8vY29uc29sZS5sb2coXCJzdGF0ZVwiLCBzdGF0ZSwgXCJjXCIsIGMsIGRhdGFbcG9zXSk7XG5cdCAgICBzd2l0Y2goc3RhdGUpIHtcblx0ICAgIGNhc2UgU1RBVEVfVEVYVDpcblx0XHRpZiAoYyA9PT0gNjAgLyogPCAqLykge1xuXHRcdCAgICB2YXIgdGV4dCA9IGVuZFJlY29yZGluZygpO1xuXHRcdCAgICBpZiAodGV4dClcblx0XHRcdHRoaXMuZW1pdCgndGV4dCcsIHVuZXNjYXBlWG1sKHRleHQpKTtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9UQUdfTkFNRTtcblx0XHQgICAgcmVjb3JkU3RhcnQgPSBwb3MgKyAxO1xuXHRcdCAgICBhdHRycyA9IHt9O1xuXHRcdH1cblx0XHRicmVhaztcblx0ICAgIGNhc2UgU1RBVEVfVEFHX05BTUU6XG5cdFx0aWYgKGMgPT09IDQ3IC8qIC8gKi8gJiYgcmVjb3JkU3RhcnQgPT09IHBvcykge1xuXHRcdCAgICByZWNvcmRTdGFydCA9IHBvcyArIDE7XG5cdFx0ICAgIGVuZFRhZyA9IHRydWU7XG5cdFx0fSBlbHNlIGlmIChjID09PSAzMyAvKiAhICovIHx8IGMgPT09IDYzIC8qID8gKi8pIHtcblx0XHQgICAgcmVjb3JkU3RhcnQgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIHN0YXRlID0gU1RBVEVfSUdOT1JFX1RBRztcblx0XHR9IGVsc2UgaWYgKGMgPD0gMzIgfHwgYyA9PT0gNDcgLyogLyAqLyB8fCBjID09PSA2MiAvKiA+ICovKSB7XG5cdFx0ICAgIHRhZ05hbWUgPSBlbmRSZWNvcmRpbmcoKTtcblx0XHQgICAgcG9zLS07XG5cdFx0ICAgIHN0YXRlID0gU1RBVEVfVEFHO1xuXHRcdH1cblx0XHRicmVhaztcblx0ICAgIGNhc2UgU1RBVEVfSUdOT1JFX1RBRzpcblx0XHRpZiAoYyA9PT0gNjIgLyogPiAqLykge1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX1RFWFQ7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgY2FzZSBTVEFURV9UQUc6XG5cdFx0aWYgKGMgPT09IDYyIC8qID4gKi8pIHtcblx0XHQgICAgaWYgKCFlbmRUYWcpIHtcblx0XHRcdHRoaXMuZW1pdCgnc3RhcnRFbGVtZW50JywgdGFnTmFtZSwgYXR0cnMpO1xuXHRcdFx0aWYgKHNlbGZDbG9zaW5nKVxuXHRcdFx0ICAgIHRoaXMuZW1pdCgnZW5kRWxlbWVudCcsIHRhZ05hbWUpO1xuXHRcdCAgICB9IGVsc2Vcblx0XHRcdHRoaXMuZW1pdCgnZW5kRWxlbWVudCcsIHRhZ05hbWUpO1xuXHRcdCAgICB0YWdOYW1lID0gdW5kZWZpbmVkO1xuXHRcdCAgICBhdHRycyA9IHVuZGVmaW5lZDtcblx0XHQgICAgZW5kVGFnID0gdW5kZWZpbmVkO1xuXHRcdCAgICBzZWxmQ2xvc2luZyA9IHVuZGVmaW5lZDtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9URVhUO1xuXHRcdCAgICByZWNvcmRTdGFydCA9IHBvcyArIDE7XG5cdFx0fSBlbHNlIGlmIChjID09PSA0NyAvKiAvICovKSB7XG5cdFx0ICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGMgPiAzMikge1xuXHRcdCAgICByZWNvcmRTdGFydCA9IHBvcztcblx0XHQgICAgc3RhdGUgPSBTVEFURV9BVFRSX05BTUU7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgY2FzZSBTVEFURV9BVFRSX05BTUU6XG5cdFx0aWYgKGMgPD0gMzIgfHwgYyA9PT0gNjEgLyogPSAqLykge1xuXHRcdCAgICBhdHRyTmFtZSA9IGVuZFJlY29yZGluZygpO1xuXHRcdCAgICBwb3MtLTtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9BVFRSX0VRO1xuXHRcdH1cblx0XHRicmVhaztcblx0ICAgIGNhc2UgU1RBVEVfQVRUUl9FUTpcblx0XHRpZiAoYyA9PT0gNjEgLyogPSAqLykge1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX0FUVFJfUVVPVDtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdCAgICBjYXNlIFNUQVRFX0FUVFJfUVVPVDpcblx0XHRpZiAoYyA9PT0gMzQgLyogXCIgKi8gfHwgYyA9PT0gMzkgLyogJyAqLykge1xuXHRcdCAgICBhdHRyUXVvdGUgPSBjO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX0FUVFJfVkFMVUU7XG5cdFx0ICAgIHJlY29yZFN0YXJ0ID0gcG9zICsgMTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdCAgICBjYXNlIFNUQVRFX0FUVFJfVkFMVUU6XG5cdFx0aWYgKGMgPT09IGF0dHJRdW90ZSkge1xuXHRcdCAgICB2YXIgdmFsdWUgPSB1bmVzY2FwZVhtbChlbmRSZWNvcmRpbmcoKSk7XG5cdFx0ICAgIGF0dHJzW2F0dHJOYW1lXSA9IHZhbHVlO1xuXHRcdCAgICBhdHRyTmFtZSA9IHVuZGVmaW5lZDtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9UQUc7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKHR5cGVvZiByZWNvcmRTdGFydCA9PT0gJ251bWJlcicgJiZcblx0ICAgIHJlY29yZFN0YXJ0IDw9IGRhdGEubGVuZ3RoKSB7XG5cblx0ICAgIHJlbWFpbmRlciA9IGRhdGEuc2xpY2UocmVjb3JkU3RhcnQpO1xuXHQgICAgcmVjb3JkU3RhcnQgPSAwO1xuXHR9XG4gICAgfTtcblxuICAgIC8qdmFyIG9yaWdFbWl0ID0gdGhpcy5lbWl0O1xuICAgIHRoaXMuZW1pdCA9IGZ1bmN0aW9uKCkge1xuXHRjb25zb2xlLmxvZygnbHR4JywgYXJndW1lbnRzKTtcblx0b3JpZ0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9OyovXG59O1xudXRpbC5pbmhlcml0cyhTYXhMdHgsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5cblNheEx0eC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhKVxuXHR0aGlzLndyaXRlKGRhdGEpO1xuXG4gICAgLyogVWgsIHllYWggKi9cbiAgICB0aGlzLndyaXRlID0gZnVuY3Rpb24oKSB7XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIHVuZXNjYXBlWG1sKHMpIHtcbiAgICByZXR1cm4gcy5cbiAgICAgICAgcmVwbGFjZSgvXFwmYW1wOy9nLCAnJicpLlxuICAgICAgICByZXBsYWNlKC9cXCZsdDsvZywgJzwnKS5cbiAgICAgICAgcmVwbGFjZSgvXFwmZ3Q7L2csICc+JykuXG4gICAgICAgIHJlcGxhY2UoL1xcJnF1b3Q7L2csICdcIicpLlxuICAgICAgICByZXBsYWNlKC9cXCZhcG9zOy9nLCAnXFwnJyk7XG59XG4iLCIoZnVuY3Rpb24oKXt2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgY29uY2F0U3RyZWFtID0gcmVxdWlyZSgnY29uY2F0LXN0cmVhbScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcblxudmFyIFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4aHIsIHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLnhociA9IHhocjtcbiAgICBzZWxmLmJvZHkgPSBjb25jYXRTdHJlYW0oKVxuICAgIFxuICAgIHZhciB1cmkgPSBwYXJhbXMuaG9zdFxuICAgICAgICArIChwYXJhbXMucG9ydCA/ICc6JyArIHBhcmFtcy5wb3J0IDogJycpXG4gICAgICAgICsgKHBhcmFtcy5wYXRoIHx8ICcvJylcbiAgICA7XG4gICAgXG4gICAgeGhyLm9wZW4oXG4gICAgICAgIHBhcmFtcy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIChwYXJhbXMuc2NoZW1lIHx8ICdodHRwJykgKyAnOi8vJyArIHVyaSxcbiAgICAgICAgdHJ1ZVxuICAgICk7XG4gICAgXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTYWZlUmVxdWVzdEhlYWRlcihrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWVbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYW1zLmF1dGgpIHtcbiAgICAgICAgLy9iYXNpYyBhdXRoXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKHBhcmFtcy5hdXRoKS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBuZXcgUmVzcG9uc2U7XG4gICAgcmVzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHJlcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIH0pO1xuICAgIFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcy5oYW5kbGUoeGhyKTtcbiAgICB9O1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUgPSBuZXcgU3RyZWFtO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cblJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHMpIHtcbiAgICB0aGlzLmJvZHkud3JpdGUocyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgIT09IHVuZGVmaW5lZCkgdGhpcy5ib2R5LndyaXRlKHMpO1xuICAgIHRoaXMuYm9keS5lbmQoKVxuICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5LmdldEJvZHkoKSk7XG59O1xuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS9tb3ppbGxhLWNlbnRyYWwvY29udGVudC9iYXNlL3NyYy9uc1hNTEh0dHBSZXF1ZXN0LmNwcC5odG1sXG5SZXF1ZXN0LnVuc2FmZUhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ1c2VyLWFnZW50XCIsXG4gICAgXCJ2aWFcIlxuXTtcblxuUmVxdWVzdC5wcm90b3R5cGUuaXNTYWZlUmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJOYW1lKSB7XG4gICAgaWYgKCFoZWFkZXJOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGluZGV4T2YoUmVxdWVzdC51bnNhZmVIZWFkZXJzLCBoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMTtcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbn0pKCkiLCJ2YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbHR4ID0gcmVxdWlyZSgnbHR4Jyk7XG52YXIgU3RyZWFtUGFyc2VyID0gcmVxdWlyZSgnLi9zdHJlYW1fcGFyc2VyJyk7XG52YXIgc3RhcnR0bHMgPSByZXF1aXJlKCcuLi9zdGFydHRscycpO1xuXG52YXIgTlNfWE1QUF9UTFMgPSBleHBvcnRzLk5TX1hNUFBfVExTID0gJ3VybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC10bHMnO1xudmFyIE5TX1NUUkVBTSA9IGV4cG9ydHMuTlNfU1RSRUFNID0gJ2h0dHA6Ly9ldGhlcnguamFiYmVyLm9yZy9zdHJlYW1zJztcbnZhciBOU19YTVBQX1NUUkVBTVMgPSAndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXN0cmVhbXMnO1xuXG4vKipcbiBCYXNlIGNsYXNzIGZvciBjb25uZWN0aW9uLWJhc2VkIHN0cmVhbXMgKFRDUCkuXG5cbiBUaGUgc29ja2V0IHBhcmFtZXRlciBpcyBvcHRpb25hbCBmb3IgaW5jb21pbmcgY29ubmVjdGlvbnMuXG4qL1xuXG52YXIgTUFYX1JFQ09OTkVDVF9ERUxBWSA9IDMwICogMTAwMDtcblxuXG5mdW5jdGlvbiBDb25uZWN0aW9uKG9wdHMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc3RyZWFtQXR0cnMgPSAob3B0cyAmJiBvcHRzLnN0cmVhbUF0dHJzKSB8fCB7fTtcbiAgICB0aGlzLnhtbG5zID0gKG9wdHMgJiYgb3B0cy54bWxucykgfHwge307XG4gICAgdGhpcy54bWxucy5zdHJlYW0gPSBOU19TVFJFQU07XG5cbiAgICB0aGlzLnNvY2tldCA9IChvcHRzICYmIG9wdHMuc29ja2V0KSB8fCBuZXcgbmV0LlNvY2tldCgpO1xuICAgIHRoaXMucmVjb25uZWN0RGVsYXkgPSAwO1xuXG4gICAgdGhpcy5zZXR1cFN0cmVhbSgpO1xuICAgIGlmICh0aGlzLnNvY2tldC5yZWFkYWJsZSlcblx0dGhpcy5zdGFydFBhcnNlcigpO1xuICAgIGVsc2Uge1xuXHR2YXIgdGhhdCA9IHRoaXM7XG5cdHRoaXMuc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdCAgICB0aGF0LnN0YXJ0UGFyc2VyKCk7XG5cdCAgICB0aGF0LmVtaXQoJ2Nvbm5lY3QnKTtcblx0fSk7XG4gICAgfVxuXG4gICAgdGhpcy5taXhpbnMgPSBbXTtcbn1cblxudXRpbC5pbmhlcml0cyhDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcblxuLy8gRGVmYXVsdHNcbkNvbm5lY3Rpb24ucHJvdG90eXBlLmFsbG93VExTID0gdHJ1ZTtcblxuLyoqXG4gVXNlZCBieSBib3RoIHRoZSBjb25zdHJ1Y3RvciBhbmQgYnkgcmVpbml0aWFsaXphdGlvbiBpbiBzZXRTZWN1cmUoKS5cbiovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZXR1cFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc29ja2V0LmFkZExpc3RlbmVyKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRMaXN0ZW5lcignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub25FbmQoKTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbigpIHtcblx0LyogdW5oYW5kbGVkIGVycm9ycyBtYXkgdGhyb3cgdXAgaW4gbm9kZSwgcHJldmVudGluZyBhIHJlY29ubmVjdCAqL1xuICAgICAgICBzZWxmLm9uRW5kKCk7XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG5cdHNlbGYub25DbG9zZSgpO1xuICAgIH0pO1xuICAgIHZhciBwcm94eUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgc2VsZi5zb2NrZXQuYWRkTGlzdGVuZXIoZXZlbnQsIGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgYXJncy51bnNoaWZ0KGV2ZW50KTtcblx0ICAgIHNlbGYuZW1pdC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBwcm94eUV2ZW50KCdkYXRhJyk7ICAvLyBsZXQgdGhlbSBzbmlmZiB1bnBhcnNlZCBYTUxcbiAgICBwcm94eUV2ZW50KCdkcmFpbicpO1xuICAgIC8vcHJveHlFdmVudCgnY2xvc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgb3B0aW1pemVkIGZvciBjb250aW51b3VzIFRDUCBzdHJlYW1zLiBJZiB5b3VyIFwic29ja2V0XCJcbiAgICAgKiBhY3R1YWxseSB0cmFuc3BvcnRzIGZyYW1lcyAoV2ViU29ja2V0cykgYW5kIHlvdSBjYW4ndCBoYXZlXG4gICAgICogc3RhbnphcyBzcGxpdCBhY3Jvc3MgdGhvc2UsIHVzZTpcbiAgICAgKiAgICAgY2IoZWwudG9TdHJpbmcoKSk7XG4gICAgICovXG4gICAgaWYgKCF0aGlzLnNvY2tldC5zZXJpYWxpemVTdGFuemEpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuc2VyaWFsaXplU3RhbnphID0gZnVuY3Rpb24oZWwsIGNiKSB7XG4gICAgICAgICAgICAvLyBDb250aW51b3VzbHkgd3JpdGUgb3V0XG4gICAgICAgICAgICBlbC53cml0ZShmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgY2Iocyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LnBhdXNlKVxuXHR0aGlzLnNvY2tldC5wYXVzZSgpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LnJlc3VtZSlcblx0dGhpcy5zb2NrZXQucmVzdW1lKCk7XG59O1xuXG4vKiogQ2xpbWJzIHRoZSBzdGFuemEgdXAgaWYgYSBjaGlsZCB3YXMgcGFzc2VkLFxuICAgIGJ1dCB5b3UgY2FuIHNlbmQgc3RyaW5ncyBhbmQgYnVmZmVycyB0b28uXG5cbiAgICBSZXR1cm5zIHdoZXRoZXIgdGhlIHNvY2tldCBmbHVzaGVkIGRhdGEuXG4qL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHN0YW56YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmx1c2hlZCA9IHRydWU7XG4gICAgaWYgKCF0aGlzLnNvY2tldCkge1xuICAgICAgICByZXR1cm47IC8vIERvaCFcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNvY2tldC53cml0YWJsZSkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGFuemEucm9vdCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLnJtWG1sbnMoc3RhbnphLnJvb3QoKSk7XG4gICAgICAgIHRoaXMuc29ja2V0LnNlcmlhbGl6ZVN0YW56YShlbCwgZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgZmx1c2hlZCA9IHNlbGYuc29ja2V0LndyaXRlKHMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmbHVzaGVkID0gdGhpcy5zb2NrZXQud3JpdGUoc3RhbnphKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsdXNoZWQ7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBTdHJlYW1QYXJzZXIuU3RyZWFtUGFyc2VyKHRoaXMubWF4U3RhbnphU2l6ZSk7XG5cbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignc3RyZWFtU3RhcnQnLCBmdW5jdGlvbihhdHRycykge1xuICAgICAgICAvKiBXZSBuZWVkIHRob3NlIHhtbG5zIG9mdGVuLCBzdG9yZSB0aGVtIGV4dHJhICovXG4gICAgICAgIHNlbGYuc3RyZWFtTnNBdHRycyA9IHt9O1xuICAgICAgICBmb3IodmFyIGsgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGsgPT0gJ3htbG5zJyB8fFxuICAgICAgICAgICAgay5zdWJzdHIoMCwgNikgPT0gJ3htbG5zOicpXG4gICAgICAgICAgICAgICAgc2VsZi5zdHJlYW1Oc0F0dHJzW2tdID0gYXR0cnNba107XG4gICAgICAgIH1cblxuICAgICAgICAvKiBOb3RpZnkgaW4gY2FzZSB3ZSBkb24ndCB3YWl0IGZvciA8c3RyZWFtOmZlYXR1cmVzLz5cbiAgICAgICAgICAgKENvbXBvbmVudCBvciBub24tMS4wIHN0cmVhbXMpXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmVtaXQoJ3N0cmVhbVN0YXJ0JywgYXR0cnMpO1xuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdzdGFuemEnLCBmdW5jdGlvbihzdGFuemEpIHtcbiAgICAgICAgc2VsZi5vblN0YW56YShzZWxmLmFkZFN0cmVhbU5zKHN0YW56YSkpO1xuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlLmNvbmRpdGlvbiB8fCAnaW50ZXJuYWwtc2VydmVyLWVycm9yJywgZS5tZXNzYWdlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuc3RvcFBhcnNlcigpO1xuICAgICAgICBzZWxmLmVuZCgpO1xuICAgIH0pO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RvcFBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vIG1vcmUgZXZlbnRzLCBwbGVhc2UgKG1heSBoYXBwZW4gaG93ZXZlcikgKi9cbiAgICBpZih0aGlzLnBhcnNlcikge1xuICAgICAgICAvKiBHZXQgR0MnZWQgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMucGFyc2VyO1xuICAgIH1cbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcmVzZXQgcmVjb25uZWN0IGRlbGF5ICovXG4gICAgdGhpcy5yZWNvbm5lY3REZWxheSA9IDA7XG4gICAgXG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgZm9yKHZhciBrIGluIHRoaXMueG1sbnMpIHtcbiAgICAgICAgaWYgKHRoaXMueG1sbnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGlmICghaylcbiAgICAgICAgICAgICAgICBhdHRycy54bWxucyA9IHRoaXMueG1sbnNba107XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXR0cnNbJ3htbG5zOicgKyBrXSA9IHRoaXMueG1sbnNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGsgaW4gdGhpcy5zdHJlYW1BdHRycykge1xuXHRpZiAodGhpcy5zdHJlYW1BdHRycy5oYXNPd25Qcm9wZXJ0eShrKSlcblx0ICAgIGF0dHJzW2tdID0gdGhpcy5zdHJlYW1BdHRyc1trXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJlYW1UbykgeyAvLyBpbiBjYXNlIG9mIGEgY29tcG9uZW50IGNvbm5lY3RpbmdcbiAgICAgICAgYXR0cnMudG8gPSB0aGlzLnN0cmVhbVRvO1xuICAgIH1cblxuICAgIHZhciBlbCA9IG5ldyBsdHguRWxlbWVudCgnc3RyZWFtOnN0cmVhbScsIGF0dHJzKTtcbiAgICAvLyBtYWtlIGl0IG5vbi1lbXB0eSB0byBjdXQgdGhlIGNsb3NpbmcgdGFnXG4gICAgZWwudCgnICcpO1xuICAgIHZhciBzID0gZWwudG9TdHJpbmcoKTtcbiAgICB0aGlzLnNlbmQocy5zdWJzdHIoMCwgcy5pbmRleE9mKCcgPC9zdHJlYW06c3RyZWFtPicpKSk7XG5cbiAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyKVxuICAgICAgICB0aGlzLnBhcnNlci53cml0ZShkYXRhKTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFNlY3VyZSA9IGZ1bmN0aW9uKGNyZWRlbnRpYWxzLCBpc1NlcnZlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFJlbW92ZSBvbGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XG4gICAgLy8gcmV0YWluIHNvY2tldCAnZW5kJyBsaXN0ZW5lcnMgYmVjYXVzZSBzc2wgbGF5ZXIgZG9lc24ndCBzdXBwb3J0IGl0XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgIHRoaXMuc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcbiAgICAvLyByZW1vdmUgaWRsZV90aW1lb3V0XG4gICAgaWYgKHRoaXMuc29ja2V0LmNsZWFyVGltZXIpXG5cdHRoaXMuc29ja2V0LmNsZWFyVGltZXIoKTtcblxuICAgIHRoaXMuc3RvcFBhcnNlcigpO1xuICAgIHZhciBjdCA9IHN0YXJ0dGxzKHRoaXMuc29ja2V0LCBjcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzLCBpc1NlcnZlciwgZnVuY3Rpb24oKSB7XG5cdHNlbGYuaXNTZWN1cmUgPSB0cnVlO1xuXHRzZWxmLnN0YXJ0UGFyc2VyKCk7XG5cdGlmICghaXNTZXJ2ZXIpXG5cdCAgICAvLyBDbGllbnRzIHN0YXJ0IDxzdHJlYW06c3RyZWFtPiwgc2VydmVycyByZXBseVxuXHQgICAgc2VsZi5zdGFydFN0cmVhbSgpO1xuICAgIH0pO1xuICAgIGN0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuXHRzZWxmLm9uQ2xvc2UoKTtcblx0c2VsZi5pc1NlY3VyZSA9IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIHNvY2tldCBpcyBub3cgdGhlIGNsZWFydGV4dCBzdHJlYW1cbiAgICB0aGlzLnNvY2tldCA9IGN0O1xuXG4gICAgLy8gQXR0YWNoIG5ldyBsaXN0ZW5lcnMgb24gdGhlIGNsZWFydGV4dCBzdHJlYW1cbiAgICB0aGlzLnNldHVwU3RyZWFtKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgbm90IGFuIGV2ZW50IGxpc3RlbmVyLCBidXQgdGFrZXMgY2FyZSBvZiB0aGUgVExTIGhhbmRzaGFrZVxuICogYmVmb3JlICdzdGFuemEnIGV2ZW50cyBhcmUgZW1pdHRlZCB0byB0aGUgZGVyaXZlZCBjbGFzc2VzLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vblN0YW56YSA9IGZ1bmN0aW9uKHN0YW56YSkge1xuICAgIGlmIChzdGFuemEuaXMoJ2Vycm9yJywgTlNfU1RSRUFNKSkge1xuICAgICAgICAvKiBUT0RPOiBleHRyYWN0IGVycm9yIHRleHQgKi9cbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHN0YW56YSk7XG4gICAgfSBlbHNlIGlmIChzdGFuemEuaXMoJ2ZlYXR1cmVzJywgTlNfU1RSRUFNKSAmJlxuICAgICAgICAgICAgICAgdGhpcy5hbGxvd1RMUyAmJlxuXHQgICAgICAgIXRoaXMuaXNTZWN1cmUgJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5nZXRDaGlsZCgnc3RhcnR0bHMnLCBOU19YTVBQX1RMUykpIHtcbiAgICAgICAgLyogU2lnbmFsIHdpbGxpbmduZXNzIHRvIHBlcmZvcm0gVExTIGhhbmRzaGFrZSAqL1xuICAgICAgICB0aGlzLnNlbmQobmV3IGx0eC5FbGVtZW50KCdzdGFydHRscycsIHsgeG1sbnM6IE5TX1hNUFBfVExTIH0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWxsb3dUTFMgJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5pcygncHJvY2VlZCcsIE5TX1hNUFBfVExTKSkge1xuICAgICAgICAvKiBTZXJ2ZXIgaXMgd2FpdGluZyBmb3IgVExTIGhhbmRzaGFrZSAqL1xuICAgICAgICB0aGlzLnNldFNlY3VyZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhbnphJywgc3RhbnphKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBzdHJlYW0geG1sbnMgdG8gYSBzdGFuemFcbiAqXG4gKiBEb2VzIG5vdCBhZGQgb3VyIGRlZmF1bHQgeG1sbnMgYXMgaXQgaXMgZGlmZmVyZW50IGZvclxuICogQzJTL1MyUy9Db21wb25lbnQgY29ubmVjdGlvbnMuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbU5zID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgZm9yKHZhciBhdHRyIGluIHRoaXMuc3RyZWFtTnNBdHRycykge1xuICAgICAgICBpZiAoIXN0YW56YS5hdHRyc1thdHRyXSAmJlxuXHQgICAgIShhdHRyID09PSAneG1sbnMnICYmXG5cdCAgICAgIHRoaXMuc3RyZWFtTnNBdHRyc1thdHRyXSA9PT0gdGhpcy54bWxuc1snJ10pKVxuICAgICAgICAgICAgc3RhbnphLmF0dHJzW2F0dHJdID0gdGhpcy5zdHJlYW1Oc0F0dHJzW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gc3RhbnphO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgc3VwZXJmbHVvdXMgeG1sbnMgdGhhdCB3ZXJlIGFsZWFkeSBkZWNsYXJlZCBpblxuICogb3VyIDxzdHJlYW06c3RyZWFtPlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5ybVhtbG5zID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgZm9yKHZhciBwcmVmaXggaW4gdGhpcy54bWxucykge1xuICAgICAgICB2YXIgYXR0ciA9IHByZWZpeCA/ICd4bWxuczonK3ByZWZpeCA6ICd4bWxucyc7XG4gICAgICAgIGlmIChzdGFuemEuYXR0cnNbYXR0cl0gPT0gdGhpcy54bWxuc1twcmVmaXhdKVxuICAgICAgICAgICAgZGVsZXRlIHN0YW56YS5hdHRyc1thdHRyXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YW56YTtcbn07XG5cblxuLyoqXG4gKiBDb25uZWN0aW9uIGhhcyBiZWVuIGVuZGVkIGJ5IHJlbW90ZSwgd2Ugd2lsbCBub3QgZ2V0IGFueSBpbmNvbWluZ1xuICogJ2RhdGEnIGV2ZW50cy4gQWx0ZXJuYXRpdmVseSwgdXNlZCBmb3IgJ2Vycm9yJyBldmVudC5cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BQYXJzZXIoKTtcbiAgICBpZiAodGhpcy5zb2NrZXQpXG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xufTtcblxuLyoqXG4gKiBYTVBQLXN0eWxlIGVuZCBjb25uZWN0aW9uIGZvciB1c2VyXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNvY2tldC53cml0YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHJlYW1PcGVuZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKCc8L3N0cmVhbTpzdHJlYW0+Jyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1PcGVuZWQ7XG5cdCAgICAvKiB3YWl0IGZvciBiZWluZyBjYWxsZWQgYWdhaW4gdXBvbiAnZW5kJyBmcm9tIG90aGVyIHNpZGUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zb2NrZXQpXG5cdC8qIEEgcmVjb25uZWN0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgKi9cblx0cmV0dXJuO1xuXG4gICAgZGVsZXRlIHRoaXMuc29ja2V0O1xuICAgIGlmICh0aGlzLnJlY29ubmVjdCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdCAgICBzZWxmLnNvY2tldCA9IG5ldyBuZXQuU3RyZWFtKCk7XG5cdCAgICBzZWxmLnNldHVwU3RyZWFtKCk7XG5cdCAgICBzZWxmLnJlY29ubmVjdCgpO1xuXHR9LCB0aGlzLnJlY29ubmVjdERlbGF5KTtcblx0Y29uc29sZS5sb2coXCJSZWNvbm5lY3QgaW5cIiwgdGhpcy5yZWNvbm5lY3REZWxheSk7XG5cdHRoaXMucmVjb25uZWN0RGVsYXkgKz0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAyMDAwKTtcblx0aWYgKHRoaXMucmVjb25uZWN0RGVsYXkgPiBNQVhfUkVDT05ORUNUX0RFTEFZKVxuXHQgICAgdGhpcy5yZWNvbm5lY3REZWxheSA9IE1BWF9SRUNPTk5FQ1RfREVMQVk7XG4gICAgfSBlbHNlIHtcblx0dGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kIGNvbm5lY3Rpb24gd2l0aCBzdHJlYW0gZXJyb3IuXG4gKiBFbWl0cyAnZXJyb3InIGV2ZW50IHRvby5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZGl0aW9uIFhNUFAgZXJyb3IgY29uZGl0aW9uLCBzZWUgUkZDMzkyMCA0LjcuMy4gRGVmaW5lZCBDb25kaXRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBPcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG5cbiAgICBpZiAoIXRoaXMuc29ja2V0IHx8ICF0aGlzLnNvY2tldC53cml0YWJsZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgaWYoIXRoaXMuc3RyZWFtT3BlbmVkKVxuICAgICAgICB0aGlzLnN0YXJ0U3RyZWFtKCk7IC8qIFJGQyAzOTIwLCA0LjcuMSBzdHJlYW0tbGV2ZWwgZXJyb3JzIHJ1bGVzICovXG5cbiAgICB2YXIgZSA9IG5ldyBsdHguRWxlbWVudCgnc3RyZWFtOmVycm9yJyk7XG4gICAgZS5jKGNvbmRpdGlvbiwgeyB4bWxuczogTlNfWE1QUF9TVFJFQU1TIH0pO1xuICAgIGlmIChtZXNzYWdlKVxuICAgICAgICBlLmMoJ3RleHQnLCB7IHhtbG5zOiBOU19YTVBQX1NUUkVBTVMsXG4gICAgICAgICAgICAgICAgICAgICAgJ3htbDpsYW5nJzogJ2VuJyB9KS5cbiAgICAgICAgdChtZXNzYWdlKTtcblxuICAgIHRoaXMuc2VuZChlKTtcbiAgICB0aGlzLmVuZCgpO1xufTtcbiIsIihmdW5jdGlvbigpe3ZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgU2Vzc2lvbiA9IHJlcXVpcmUoJy4vc2Vzc2lvbicpLlNlc3Npb247XG52YXIgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xudmFyIEpJRCA9IHJlcXVpcmUoJy4vamlkJykuSklEO1xudmFyIGx0eCA9IHJlcXVpcmUoJ2x0eCcpO1xudmFyIHNhc2wgPSByZXF1aXJlKCcuL3Nhc2wnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudHJ5IHtcbiAgICB2YXIgU1JWID0gcmVxdWlyZSgnLi9zcnYnKTtcbn0gY2F0Y2ggKGUpIHsgfVxuXG52YXIgTlNfQ0xJRU5UID0gJ2phYmJlcjpjbGllbnQnO1xudmFyIE5TX1JFR0lTVEVSID0gJ2phYmJlcjppcTpyZWdpc3Rlcic7XG52YXIgTlNfWE1QUF9TQVNMID0gJ3VybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1zYXNsJztcbnZhciBOU19YTVBQX0JJTkQgPSAndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLWJpbmQnO1xudmFyIE5TX1hNUFBfU0VTU0lPTiA9ICd1cm46aWV0ZjpwYXJhbXM6eG1sOm5zOnhtcHAtc2Vzc2lvbic7XG5cbnZhciBTVEFURV9QUkVBVVRIID0gMCxcbiAgICBTVEFURV9BVVRIID0gMSxcbiAgICBTVEFURV9BVVRIRUQgPSAyLFxuICAgIFNUQVRFX0JJTkQgPSAzLFxuICAgIFNUQVRFX1NFU1NJT04gPSA0LFxuICAgIFNUQVRFX09OTElORSA9IDU7XG52YXIgSVFJRF9TRVNTSU9OID0gJ3Nlc3MnLFxuICAgIElRSURfQklORCA9ICdiaW5kJztcblxuLyoqXG4gKiBwYXJhbXMgb2JqZWN0OlxuICogICBqaWQ6IFN0cmluZyAocmVxdWlyZWQpXG4gKiAgIHBhc3N3b3JkOiBTdHJpbmcgKHJlcXVpcmVkKVxuICogICBob3N0OiBTdHJpbmcgKG9wdGlvbmFsKVxuICogICBwb3J0OiBOdW1iZXIgKG9wdGlvbmFsKVxuICogICByZWNvbm5lY3Q6IEJvb2xlYW4gKG9wdGlvbmFsKVxuICogICByZWdpc3RlcjogQm9vbGVhbiAob3B0aW9uKSAtIHJlZ2lzdGVyIGFjY291bnQgYmVmb3JlIGF1dGhlbnRpY2F0aW9uXG4gKiAgIGxlZ2FjeVNTTDogQm9vbGVhbiAob3B0aW9uYWwpIC0gY29ubmVjdCB0byB0aGUgbGVnYWN5IFNTTCBwb3J0LCByZXF1aXJlcyBhdCBsZWFzdCB0aGUgaG9zdCB0byBiZSBzcGVjaWZpZWRcbiAqICAgY3JlZGVudGlhbHM6IERpY3Rpb25hcnkgKG9wdGlvbmFsKSAtIFRMUyBvciBTU0wga2V5IGFuZCBjZXJ0aWZpY2F0ZSBjcmVkZW50aWFsc1xuICogICBhY3RBczogU3RyaW5nIChvcHRpb25hbCkgLSBpZiBhZG1pbiB1c2VyIGFjdCBvbiBiZWhhbGYgb2YgYW5vdGhlciB1c2VyIChqdXN0IHVzZXIpXG4gKlxuICogRXhhbXBsZXM6XG4gKiAgIHZhciBjbCA9IG5ldyB4bXBwLkNsaWVudCh7XG4gKiAgICAgICBqaWQ6IFwibWVAZXhhbXBsZS5jb21cIixcbiAqICAgICAgIHBhc3N3b3JkOiBcInNlY3JldFwiXG4gKiAgIH0pO1xuICogICB2YXIgYWNlYm9vID0gbmV3IHhtcHAuQ2xpZW50KHtcbiAqICAgICAgIGppZDogJy0nICsgZmJVSUQgKyAnQGNoYXQuZmFjZWJvb2suY29tJyxcbiAqICAgICAgIGFwaV9rZXk6ICc1NDMyMScsIC8vIGFwaSBrZXkgb2YgeW91ciBmYWNlYm9vayBhcHBcbiAqICAgICAgIGFjY2Vzc190b2tlbjogJ2FiY2RlZmcnLCAvLyB1c2VyIGFjY2VzcyB0b2tlblxuICogICAgICAgaG9zdDogJ2NoYXQuZmFjZWJvb2suY29tJ1xuICogICB9KTtcbiAqICAgdmFyIGd0YWxrID0gbmV3IHhtcHAuQ2xpZW50KHtcbiAqICAgICAgIGppZDogJ21lQGdtYWlsLmNvbScsXG4gKiAgICAgICBvYXV0aDJfdG9rZW46ICd4eHh4Lnh4eHh4eHh4eHh4JywgLy8gZnJvbSBPQXV0aDJcbiAqICAgICAgIG9hdXRoMl9hdXRoOiAnaHR0cDovL3d3dy5nb29nbGUuY29tL3RhbGsvcHJvdG9jb2wvYXV0aCcsXG4gKiAgICAgICBob3N0OiAndGFsay5nb29nbGUuY29tJ1xuICogICB9KTtcbiAqXG4gKiBFeGFtcGxlIFNBU0wgRVhURVJOQUw6XG4gKiBcbiAqIHZhciBteUNyZWRlbnRpYWxzID0geyBcbiAqICAgLy8gVGhlc2UgYXJlIG5lY2Vzc2FyeSBvbmx5IGlmIHVzaW5nIHRoZSBjbGllbnQgY2VydGlmaWNhdGUgYXV0aGVudGljYXRpb25cbiAqICAga2V5OiBmcy5yZWFkRmlsZVN5bmMoJ2tleS5wZW0nKSxcbiAqICAgY2VydDogZnMucmVhZEZpbGVTeW5jKCdjZXJ0LnBlbScpLFxuICogICAvLyBwYXNzcGhyYXNlOiAnb3B0aW9uYWwnXG4gKiB9O1xuICogdmFyIGNsID0gbmV3IHhtcHBDbGllbnQoe2ppZDogXCJtZUBleGFtcGxlLmNvbVwiLCBjcmVkZW50aWFsczogbXlDcmVkZW50aWFscyB9KTsgXG4gXG4gKi9cbmZ1bmN0aW9uIENsaWVudChvcHRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgb3B0cy54bWxucyA9IE5TX0NMSUVOVDtcbiAgICBzZWxmLnN0YXRlID0gU1RBVEVfUFJFQVVUSDtcbiAgICBkZWxldGUgc2VsZi5kaWRfYmluZDtcbiAgICBkZWxldGUgc2VsZi5kaWRfc2Vzc2lvbjtcblxuICAgIFNlc3Npb24uY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMucHJlZmVycmVkU2FzbE1lY2hhbmlzbSA9ICdFWFRFUk5BTCc7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlU2FzbE1lY2hhbmlzbXMgPSBbIHNhc2wuRXh0ZXJuYWwgXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUFJFQVVUSDtcbiAgICB0aGlzLmFkZExpc3RlbmVyKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFNUQVRFX1BSRUFVVEg7XG4gICAgICAgIHNlbGYuZW1pdCgnb2ZmbGluZScpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBTVEFURV9QUkVBVVRIO1xuICAgIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKENsaWVudCwgU2Vzc2lvbik7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcblxuQ2xpZW50LnByb3RvdHlwZS5vblN0YW56YSA9IGZ1bmN0aW9uKHN0YW56YSkge1xuICAgIC8qIEFjdHVhbGx5LCB3ZSBzaG91bGRuJ3Qgd2FpdCBmb3IgPHN0cmVhbTpmZWF0dXJlcy8+IGlmXG4gICAgICAgdGhpcy5zdHJlYW1BdHRycy52ZXJzaW9uIGlzIG1pc3NpbmcsIGJ1dCB3aG8gdXNlcyBwcmUtWE1QUC0xLjBcbiAgICAgICB0aGVzZSBkYXlzIGFueXdheT8gKi9cbiAgICBpZiAodGhpcy5zdGF0ZSAhPSBTVEFURV9PTkxJTkUgJiZcbiAgICAgICAgc3RhbnphLmlzKCdmZWF0dXJlcycsIENvbm5lY3Rpb24uTlNfU1RSRUFNKSkge1xuICAgICAgICB0aGlzLnN0cmVhbUZlYXR1cmVzID0gc3RhbnphO1xuICAgICAgICB0aGlzLnVzZUZlYXR1cmVzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX0FVVEgpIHtcbiAgICAgICAgaWYgKHN0YW56YS5pcygnY2hhbGxlbmdlJywgTlNfWE1QUF9TQVNMKSkge1xuICAgICAgICAgICAgdmFyIGNoYWxsZW5nZU1zZyA9IGRlY29kZTY0KHN0YW56YS5nZXRUZXh0KCkpO1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlTXNnID0gZW5jb2RlNjQodGhpcy5tZWNoLmNoYWxsZW5nZShjaGFsbGVuZ2VNc2cpKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChuZXcgbHR4LkVsZW1lbnQoJ3Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4bWxuczogTlNfWE1QUF9TQVNMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnQocmVzcG9uc2VNc2cpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFuemEuaXMoJ3N1Y2Nlc3MnLCBOU19YTVBQX1NBU0wpKSB7XG4gICAgICAgICAgICB0aGlzLm1lY2ggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0FVVEhFRDtcblx0ICAgIGlmICh0aGlzLmNvbm5lY3Rpb24uc3RhcnRQYXJzZXIpXG5cdFx0dGhpcy5jb25uZWN0aW9uLnN0YXJ0UGFyc2VyKCk7XG5cdCAgICBpZiAodGhpcy5jb25uZWN0aW9uLnN0YXJ0U3RyZWFtKVxuXHRcdHRoaXMuY29ubmVjdGlvbi5zdGFydFN0cmVhbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdYTVBQIGF1dGhlbnRpY2F0aW9uIGZhaWx1cmUnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9CSU5EICYmXG4gICAgICAgICAgICAgICBzdGFuemEuaXMoJ2lxJykgJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5hdHRycy5pZCA9PSBJUUlEX0JJTkQpIHtcbiAgICAgICAgaWYgKHN0YW56YS5hdHRycy50eXBlID09ICdyZXN1bHQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQVVUSEVEO1xuICAgICAgICAgICAgdGhpcy5kaWRfYmluZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBiaW5kRWwgPSBzdGFuemEuZ2V0Q2hpbGQoJ2JpbmQnLCBOU19YTVBQX0JJTkQpO1xuICAgICAgICAgICAgaWYgKGJpbmRFbCAmJiBiaW5kRWwuZ2V0Q2hpbGQoJ2ppZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaWQgPSBuZXcgSklEKGJpbmRFbC5nZXRDaGlsZCgnamlkJykuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogbm8gc3RyZWFtIHJlc3RhcnQsIGJ1dCBuZXh0IGZlYXR1cmUgKi9cbiAgICAgICAgICAgIHRoaXMudXNlRmVhdHVyZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnQ2Fubm90IGJpbmQgcmVzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9TRVNTSU9OICYmXG4gICAgICAgICAgICAgICBzdGFuemEuaXMoJ2lxJykgJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5hdHRycy5pZCA9PSBJUUlEX1NFU1NJT04pIHtcbiAgICAgICAgaWYgKHN0YW56YS5hdHRycy50eXBlID09ICdyZXN1bHQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQVVUSEVEO1xuICAgICAgICAgICAgdGhpcy5kaWRfc2Vzc2lvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qIG5vIHN0cmVhbSByZXN0YXJ0LCBidXQgbmV4dCBmZWF0dXJlIChtb3N0IHByb2JhYmx5XG4gICAgICAgICAgICAgICB3ZSdsbCBnbyBvbmxpbmUgbmV4dCkgKi9cbiAgICAgICAgICAgIHRoaXMudXNlRmVhdHVyZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnQ2Fubm90IGJpbmQgcmVzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhbnphLm5hbWUgPT0gJ3N0cmVhbTplcnJvcicpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHN0YW56YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX09OTElORSkge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YW56YScsIHN0YW56YSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFaXRoZXIgd2UganVzdCByZWNlaXZlZCA8c3RyZWFtOmZlYXR1cmVzLz4sIG9yIHdlIGp1c3QgZW5hYmxlZCBhXG4gKiBmZWF0dXJlIGFuZCBhcmUgbG9va2luZyBmb3IgdGhlIG5leHQuXG4gKi9cbkNsaWVudC5wcm90b3R5cGUudXNlRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9QUkVBVVRIICYmXG4gICAgICAgIHRoaXMucmVnaXN0ZXIpIHtcblx0ZGVsZXRlIHRoaXMucmVnaXN0ZXI7XG5cdHRoaXMuZG9SZWdpc3RlcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9QUkVBVVRIICYmXG4gICAgICAgIHRoaXMuc3RyZWFtRmVhdHVyZXMuZ2V0Q2hpbGQoJ21lY2hhbmlzbXMnLCBOU19YTVBQX1NBU0wpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9BVVRIO1xuXHR2YXIgb2ZmZXJlZE1lY2hzID0gdGhpcy5zdHJlYW1GZWF0dXJlcy5cbiAgICAgICAgICAgIGdldENoaWxkKCdtZWNoYW5pc21zJywgTlNfWE1QUF9TQVNMKS5cbiAgICAgICAgICAgIGdldENoaWxkcmVuKCdtZWNoYW5pc20nLCBOU19YTVBQX1NBU0wpLlxuICAgICAgICAgICAgbWFwKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5nZXRUZXh0KCk7IH0pO1xuICAgICAgICB0aGlzLm1lY2ggPSBzYXNsLnNlbGVjdE1lY2hhbmlzbShcbiAgICAgICAgICAgIG9mZmVyZWRNZWNocyxcbiAgICAgICAgICAgIHRoaXMucHJlZmVycmVkU2FzbE1lY2hhbmlzbSxcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlU2FzbE1lY2hhbmlzbXMpO1xuICAgICAgICBpZiAodGhpcy5tZWNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lY2guYXV0aHppZCA9IHRoaXMuamlkLmJhcmUoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5tZWNoLmF1dGhjaWQgPSB0aGlzLmppZC51c2VyO1xuICAgICAgICAgICAgdGhpcy5tZWNoLnBhc3N3b3JkID0gdGhpcy5wYXNzd29yZDtcbiAgICAgICAgICAgIHRoaXMubWVjaC5hcGlfa2V5ID0gdGhpcy5hcGlfa2V5O1xuICAgICAgICAgICAgdGhpcy5tZWNoLmFjY2Vzc190b2tlbiA9IHRoaXMuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgdGhpcy5tZWNoLm9hdXRoMl90b2tlbiA9IHRoaXMub2F1dGgyX3Rva2VuO1xuICAgICAgICAgICAgdGhpcy5tZWNoLm9hdXRoMl9hdXRoID0gdGhpcy5vYXV0aDJfYXV0aDtcbiAgICAgICAgICAgIHRoaXMubWVjaC5yZWFsbSA9IHRoaXMuamlkLmRvbWFpbjsgIC8vIGFueXRoaW5nP1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0QXMpIHRoaXMubWVjaC5hY3RBcyA9IHRoaXMuYWN0QXMudXNlcjtcbiAgICAgICAgICAgIHRoaXMubWVjaC5kaWdlc3RfdXJpID0gXCJ4bXBwL1wiICsgdGhpcy5qaWQuZG9tYWluO1xuICAgICAgICAgICAgdmFyIGF1dGhNc2cgPSBlbmNvZGU2NCh0aGlzLm1lY2guYXV0aCgpKTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMubWVjaC5hdXRoQXR0cnMoKTtcbiAgICAgICAgICAgIGF0dHJzLnhtbG5zID0gTlNfWE1QUF9TQVNMO1xuICAgICAgICAgICAgYXR0cnMubWVjaGFuaXNtID0gdGhpcy5tZWNoLm5hbWU7XG4gICAgICAgICAgICB0aGlzLnNlbmQobmV3IGx0eC5FbGVtZW50KCdhdXRoJywgYXR0cnMpLlxuXHRcdCAgICAgIHQoYXV0aE1zZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdObyB1c2FibGUgU0FTTCBtZWNoYW5pc20nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9BVVRIRUQgJiZcbiAgICAgICAgICAgICAgICF0aGlzLmRpZF9iaW5kICYmXG4gICAgICAgICAgICAgICB0aGlzLnN0cmVhbUZlYXR1cmVzLmdldENoaWxkKCdiaW5kJywgTlNfWE1QUF9CSU5EKSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQklORDtcbiAgICAgICAgdmFyIGJpbmRFbCA9IG5ldyBsdHguRWxlbWVudCgnaXEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogSVFJRF9CSU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYygnYmluZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHhtbG5zOiBOU19YTVBQX0JJTkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5qaWQucmVzb3VyY2UpXG4gICAgICAgICAgICBiaW5kRWwuYygncmVzb3VyY2UnKS50KHRoaXMuamlkLnJlc291cmNlKTtcbiAgICAgICAgdGhpcy5zZW5kKGJpbmRFbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX0FVVEhFRCAmJlxuICAgICAgICAgICAgICAgIXRoaXMuZGlkX3Nlc3Npb24gJiZcbiAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRmVhdHVyZXMuZ2V0Q2hpbGQoJ3Nlc3Npb24nLCBOU19YTVBQX1NFU1NJT04pKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9TRVNTSU9OO1xuICAgICAgICB0aGlzLnNlbmQobmV3IGx0eC5FbGVtZW50KCdpcScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmppZC5kb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogSVFJRF9TRVNTSU9OXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYygnc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHhtbG5zOiBOU19YTVBQX1NFU1NJT05cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfQVVUSEVEKSB7XG4gICAgICAgIC8qIE9rLCB3ZSdyZSBhdXRoZW50aWNhdGVkIGFuZCBhbGwgZmVhdHVyZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgIHByb2Nlc3NlZCAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfT05MSU5FO1xuICAgICAgICB0aGlzLmVtaXQoJ29ubGluZScpO1xuICAgIH1cbn07XG5cbkNsaWVudC5wcm90b3R5cGUuZG9SZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9IFwicmVnaXN0ZXJcIiArIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogOTk5OTkpO1xuICAgIHZhciBpcSA9IG5ldyBsdHguRWxlbWVudCgnaXEnLCB7IHR5cGU6ICdzZXQnLFxuXHRcdFx0XHQgICAgIGlkOiBpZCxcblx0XHRcdFx0ICAgICB0bzogdGhpcy5qaWQuZG9tYWluXG5cdFx0XHRcdCAgIH0pLlxuXHRjKCdxdWVyeScsIHsgeG1sbnM6IE5TX1JFR0lTVEVSIH0pLlxuXHRjKCd1c2VybmFtZScpLnQodGhpcy5qaWQudXNlcikudXAoKS5cblx0YygncGFzc3dvcmQnKS50KHRoaXMucGFzc3dvcmQpO1xuICAgIHRoaXMuc2VuZChpcSk7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIG9uUmVwbHkgPSBmdW5jdGlvbihyZXBseSkge1xuXHRpZiAocmVwbHkuaXMoJ2lxJykgJiYgcmVwbHkuYXR0cnMuaWQgPT09IGlkKSB7XG5cdCAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdzdGFuemEnLCBvblJlcGx5KTtcblxuXHQgICAgaWYgKHJlcGx5LmF0dHJzLnR5cGUgPT09ICdyZXN1bHQnKSB7XG5cdFx0LyogUmVnaXN0cmF0aW9uIHN1Y2Nlc3NmdWwsIHByb2NlZWQgdG8gYXV0aCAqL1xuXHRcdHRoYXQudXNlRmVhdHVyZXMoKTtcblx0ICAgIH0gZWxzZSB7XG5cdFx0dGhhdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihcIlJlZ2lzdHJhdGlvbiBlcnJvclwiKSk7XG5cdCAgICB9XG5cdH1cbiAgICB9O1xuICAgIHRoaXMub24oJ3N0YW56YScsIG9uUmVwbHkpO1xufTtcblxuQ2xpZW50LnByb3RvdHlwZS5yZWdpc3RlclNhc2xNZWNoYW5pc20gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOiBbXTtcbiAgICB0aGlzLmF2YWlsYWJsZVNhc2xNZWNoYW5pc21zID0gdGhpcy5hdmFpbGFibGVTYXNsTWVjaGFuaXNtcy5jb25jYXQoYXJncyk7XG59O1xuXG52YXIgZGVjb2RlNjQsIGVuY29kZTY0LCBCdWZmZXI7XG5pZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkZWNvZGU2NCA9IGZ1bmN0aW9uKGVuY29kZWQpIHtcblx0cmV0dXJuIGF0b2IoZW5jb2RlZCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIGRlY29kZTY0ID0gZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRyZXR1cm4gKG5ldyBCdWZmZXIoZW5jb2RlZCwgJ2Jhc2U2NCcpKS50b1N0cmluZygndXRmOCcpO1xuICAgIH07XG59XG5pZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlbmNvZGU2NCA9IGZ1bmN0aW9uKGRlY29kZWQpIHtcblx0cmV0dXJuIGJ0b2EoZGVjb2RlZCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIGVuY29kZTY0ID0gZnVuY3Rpb24oZGVjb2RlZCkge1xuXHRyZXR1cm4gKG5ldyBCdWZmZXIoZGVjb2RlZCwgJ3V0ZjgnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH07XG59XG5cbn0pKCkiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBsdHggPSByZXF1aXJlKCdsdHgnKTtcblxuZnVuY3Rpb24gU3RhbnphKG5hbWUsIGF0dHJzKSB7XG4gICAgbHR4LkVsZW1lbnQuY2FsbCh0aGlzLCBuYW1lLCBhdHRycyk7XG59XG51dGlsLmluaGVyaXRzKFN0YW56YSwgbHR4LkVsZW1lbnQpO1xuXG4vKipcbiAqIENvbW1vbiBhdHRyaWJ1dGUgZ2V0dGVycy9zZXR0ZXJzIGZvciBhbGwgc3Rhbnphc1xuICovXG5cblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygnZnJvbScsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLmZyb207XG59KTtcblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXygnZnJvbScsIGZ1bmN0aW9uKGZyb20pIHtcbiAgICB0aGlzLmF0dHJzLmZyb20gPSBmcm9tO1xufSk7XG5cblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygndG8nLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy50bztcbn0pO1xuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKCd0bycsIGZ1bmN0aW9uKHRvKSB7XG4gICAgdGhpcy5hdHRycy50byA9IHRvO1xufSk7XG5cblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygnaWQnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5pZDtcbn0pO1xuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKCdpZCcsIGZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy5hdHRycy5pZCA9IGlkO1xufSk7XG5cblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygndHlwZScsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLnR5cGU7XG59KTtcblN0YW56YS5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXygndHlwZScsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLmF0dHJzLnR5cGUgPSB0eXBlO1xufSk7XG5cblxuLyoqXG4gKiBTdGFuemEga2luZHNcbiAqL1xuXG5mdW5jdGlvbiBNZXNzYWdlKGF0dHJzKSB7XG4gICAgU3RhbnphLmNhbGwodGhpcywgJ21lc3NhZ2UnLCBhdHRycyk7XG59XG51dGlsLmluaGVyaXRzKE1lc3NhZ2UsIFN0YW56YSk7XG5cbmZ1bmN0aW9uIFByZXNlbmNlKGF0dHJzKSB7XG4gICAgU3RhbnphLmNhbGwodGhpcywgJ3ByZXNlbmNlJywgYXR0cnMpO1xufVxudXRpbC5pbmhlcml0cyhQcmVzZW5jZSwgU3RhbnphKTtcblxuZnVuY3Rpb24gSXEoYXR0cnMpIHtcbiAgICBTdGFuemEuY2FsbCh0aGlzLCAnaXEnLCBhdHRycyk7XG59XG51dGlsLmluaGVyaXRzKElxLCBTdGFuemEpO1xuXG5leHBvcnRzLlN0YW56YSA9IFN0YW56YTtcbmV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2U7XG5leHBvcnRzLlByZXNlbmNlID0gUHJlc2VuY2U7XG5leHBvcnRzLklxID0gSXE7XG4iLCIoZnVuY3Rpb24oQnVmZmVyKXt2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIENvbmNhdFN0cmVhbShjYikge1xuICBzdHJlYW0uU3RyZWFtLmNhbGwodGhpcylcbiAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgaWYgKGNiKSB0aGlzLmNiID0gY2JcbiAgdGhpcy5ib2R5ID0gW11cbiAgaWYgKHRoaXMuY2IpIHRoaXMub24oJ2Vycm9yJywgY2IpXG59XG5cbnV0aWwuaW5oZXJpdHMoQ29uY2F0U3RyZWFtLCBzdHJlYW0uU3RyZWFtKVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdGhpcy5ib2R5LnB1c2goY2h1bmspXG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuYXJyYXlDb25jYXQgPSBmdW5jdGlvbihhcnJzKSB7XG4gIGlmIChhcnJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdXG4gIGlmIChhcnJzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGFycnNbMF1cbiAgcmV0dXJuIGFycnMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKSB9KVxufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmlzQXJyYXkgPSBmdW5jdGlvbihhcnIpIHtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGFycilcbiAgdmFyIGlzVHlwZWRBcnJheSA9IGFyci50b1N0cmluZygpLm1hdGNoKC9BcnJheS8pXG4gIHJldHVybiBpc0FycmF5IHx8IGlzVHlwZWRBcnJheVxufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmJvZHkubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgaWYgKHR5cGVvZih0aGlzLmJvZHlbMF0pID09PSBcInN0cmluZ1wiKSByZXR1cm4gdGhpcy5ib2R5LmpvaW4oJycpXG4gIGlmICh0aGlzLmlzQXJyYXkodGhpcy5ib2R5WzBdKSkgcmV0dXJuIHRoaXMuYXJyYXlDb25jYXQodGhpcy5ib2R5KVxuICBpZiAodHlwZW9mKEJ1ZmZlcikgIT09IFwidW5kZWZpbmVkXCIgJiYgQnVmZmVyLmlzQnVmZmVyKHRoaXMuYm9keVswXSkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdCh0aGlzLmJvZHkpXG4gIH1cbiAgcmV0dXJuIHRoaXMuYm9keVxufVxuXG5Db25jYXRTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jYikgdGhpcy5jYihmYWxzZSwgdGhpcy5nZXRCb2R5KCkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIG5ldyBDb25jYXRTdHJlYW0oY2IpXG59XG5cbm1vZHVsZS5leHBvcnRzLkNvbmNhdFN0cmVhbSA9IENvbmNhdFN0cmVhbVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwidmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuL2VsZW1lbnQnKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxuLyoqXG4gKiBUaGUgb25seSAocmVsZXZhbnQpIGRhdGEgc3RydWN0dXJlXG4gKi9cbmV4cG9ydHMuRWxlbWVudCA9IGVsZW1lbnQuRWxlbWVudDtcbi8qKlxuICogSGVscGVyXG4gKi9cbmV4cG9ydHMuZXNjYXBlWG1sID0gZWxlbWVudC5lc2NhcGVYbWw7XG5cbi8qKlxuICogRE9NIHBhcnNlciBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlLnBhcnNlO1xuZXhwb3J0cy5QYXJzZXIgPSBwYXJzZS5QYXJzZXI7XG4vKipcbiAqIFNBWCBwYXJzZXIgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydHMuYXZhaWxhYmxlU2F4UGFyc2VycyA9IHBhcnNlLmF2YWlsYWJsZVNheFBhcnNlcnM7XG5leHBvcnRzLmJlc3RTYXhQYXJzZXIgPSBwYXJzZS5iZXN0U2F4UGFyc2VyO1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3MsQnVmZmVyKXt2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgbWltZSA9IHJlcXVpcmUoJ21pbWUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybURhdGE7XG5mdW5jdGlvbiBGb3JtRGF0YSgpIHtcbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZUxlbmd0aCA9IDA7XG4gIHRoaXMuX2xlbmd0aFJldHJpZXZlcnMgPSBbXTtcblxuICBDb21iaW5lZFN0cmVhbS5jYWxsKHRoaXMpO1xufVxudXRpbC5pbmhlcml0cyhGb3JtRGF0YSwgQ29tYmluZWRTdHJlYW0pO1xuXG5Gb3JtRGF0YS5MSU5FX0JSRUFLID0gJ1xcclxcbic7XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGFwcGVuZCA9IENvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQuYmluZCh0aGlzKTtcblxuICAvLyBhbGwgdGhhdCBzdHJlYW15IGJ1c2luZXNzIGNhbid0IGhhbmRsZSBudW1iZXJzXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHZhbHVlID0gJycrdmFsdWU7XG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuX211bHRpUGFydEhlYWRlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgYXBwZW5kKGhlYWRlcik7XG4gIGFwcGVuZCh2YWx1ZSk7XG4gIGFwcGVuZChmb290ZXIpO1xuXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB2YWx1ZUxlbmd0aCA9IDA7XG5cbiAgLy8gdXNlZCB3LyB0cmFja0xlbmd0aFN5bmMoKSwgd2hlbiBsZW5ndGggaXMga25vd24uXG4gIC8vIGUuZy4gZm9yIHN0cmVhbWluZyBkaXJlY3RseSBmcm9tIGEgcmVtb3RlIHNlcnZlcixcbiAgLy8gdy8gYSBrbm93biBmaWxlIGEgc2l6ZSwgYW5kIG5vdCB3YW50aW5nIHRvIHdhaXQgZm9yXG4gIC8vIGluY29taW5nIGZpbGUgdG8gZmluaXNoIHRvIGdldCBpdHMgc2l6ZS5cbiAgaWYgKG9wdGlvbnMua25vd25MZW5ndGggIT0gbnVsbCkge1xuICAgIHZhbHVlTGVuZ3RoICs9ICtvcHRpb25zLmtub3duTGVuZ3RoO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH1cblxuICB0aGlzLl92YWx1ZUxlbmd0aCArPSB2YWx1ZUxlbmd0aDtcblxuICAvLyBAY2hlY2sgd2h5IGFkZCBDUkxGPyBkb2VzIHRoaXMgYWNjb3VudCBmb3IgY3VzdG9tL211bHRpcGxlIENSTEZzP1xuICB0aGlzLl9vdmVyaGVhZExlbmd0aCArPVxuICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGhlYWRlcikgK1xuICAgICsgRm9ybURhdGEuTElORV9CUkVBSy5sZW5ndGg7XG5cbiAgLy8gZW1wdHkgb3IgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBwYXRoIG9yIG5vdCBhbiBodHRwIHJlc3BvbnNlXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSApKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbGVuZ3RoUmV0cmlldmVycy5wdXNoKGZ1bmN0aW9uKG5leHQpIHtcblxuICAgIC8vIGRvIHdlIGFscmVhZHkga25vdyB0aGUgc2l6ZT9cbiAgICAvLyAwIGFkZGl0aW9uYWwgbGVhdmVzIHZhbHVlIGZyb20gZ2V0U3luY0xlbmd0aCgpXG4gICAgaWYgKG9wdGlvbnMua25vd25MZW5ndGggIT0gbnVsbCkge1xuICAgICAgbmV4dChudWxsLCAwKTtcblxuICAgIC8vIGNoZWNrIGlmIGl0J3MgbG9jYWwgZmlsZVxuICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2ZkJykpIHtcbiAgICAgIGZzLnN0YXQodmFsdWUucGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBuZXh0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChudWxsLCBzdGF0LnNpemUpO1xuICAgICAgfSk7XG5cbiAgICAvLyBvciBodHRwIHJlc3BvbnNlXG4gICAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgICAgbmV4dChudWxsLCArdmFsdWUuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG5cbiAgICAvLyBvciByZXF1ZXN0IHN0cmVhbSBodHRwOi8vZ2l0aHViLmNvbS9taWtlYWwvcmVxdWVzdFxuICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBNb2R1bGUnKSkge1xuICAgICAgLy8gd2FpdCB0aWxsIHJlc3BvbnNlIGNvbWUgYmFja1xuICAgICAgdmFsdWUub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgdmFsdWUucGF1c2UoKTtcbiAgICAgICAgbmV4dChudWxsLCArcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG4gICAgICB9KTtcbiAgICAgIHZhbHVlLnJlc3VtZSgpO1xuXG4gICAgLy8gc29tZXRoaW5nIGVsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCgnVW5rbm93biBzdHJlYW0nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRIZWFkZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRCb3VuZGFyeSgpO1xuICB2YXIgaGVhZGVyID0gJyc7XG5cbiAgLy8gY3VzdG9tIGhlYWRlciBzcGVjaWZpZWQgKGFzIHN0cmluZyk/XG4gIC8vIGl0IGJlY29tZXMgcmVzcG9uc2libGUgZm9yIGJvdW5kYXJ5XG4gIC8vIChlLmcuIHRvIGhhbmRsZSBleHRyYSBDUkxGcyBvbiAuTkVUIHNlcnZlcnMpXG4gIGlmIChvcHRpb25zLmhlYWRlciAhPSBudWxsKSB7XG4gICAgaGVhZGVyID0gb3B0aW9ucy5oZWFkZXI7XG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9ICctLScgKyBib3VuZGFyeSArIEZvcm1EYXRhLkxJTkVfQlJFQUsgK1xuICAgICAgJ0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIicgKyBmaWVsZCArICdcIic7XG5cbiAgICAvLyBmcy0gYW5kIHJlcXVlc3QtIHN0cmVhbXMgaGF2ZSBwYXRoIHByb3BlcnR5XG4gICAgLy8gb3IgdXNlIGN1c3RvbSBmaWxlbmFtZSBhbmQvb3IgY29udGVudFR5cGVcbiAgICAvLyBUT0RPOiBVc2UgcmVxdWVzdCdzIHJlc3BvbnNlIG1pbWUtdHlwZVxuICAgIGlmIChvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLnBhdGgpIHtcbiAgICAgIGhlYWRlciArPVxuICAgICAgICAnOyBmaWxlbmFtZT1cIicgKyBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUucGF0aCkgKyAnXCInICsgRm9ybURhdGEuTElORV9CUkVBSyArXG4gICAgICAgICdDb250ZW50LVR5cGU6ICcgKyAgKG9wdGlvbnMuY29udGVudFR5cGUgfHwgbWltZS5sb29rdXAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5wYXRoKSk7XG5cbiAgICAvLyBodHRwIHJlc3BvbnNlIGhhcyBub3RcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgICBoZWFkZXIgKz1cbiAgICAgICAgJzsgZmlsZW5hbWU9XCInICsgcGF0aC5iYXNlbmFtZSh2YWx1ZS5jbGllbnQuX2h0dHBNZXNzYWdlLnBhdGgpICsgJ1wiJyArIEZvcm1EYXRhLkxJTkVfQlJFQUsgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiAnICsgdmFsdWUuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgfVxuXG4gICAgaGVhZGVyICs9IEZvcm1EYXRhLkxJTkVfQlJFQUsgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XG5cbiAgICB2YXIgbGFzdFBhcnQgPSAodGhpcy5fc3RyZWFtcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChsYXN0UGFydCkge1xuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xuICAgIH1cblxuICAgIG5leHQoZm9vdGVyKTtcbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sYXN0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbih1c2VySGVhZGVycykge1xuICB2YXIgZm9ybUhlYWRlcnMgPSB7XG4gICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgdGhpcy5nZXRCb3VuZGFyeSgpXG4gIH07XG5cbiAgZm9yICh2YXIgaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XG4gICAgZm9ybUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdXNlckhlYWRlcnNbaGVhZGVyXTtcbiAgfVxuXG4gIHJldHVybiBmb3JtSGVhZGVycztcbn1cblxuRm9ybURhdGEucHJvdG90eXBlLmdldEN1c3RvbUhlYWRlcnMgPSBmdW5jdGlvbihjb250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZSA6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJztcblxuICAgIHZhciBmb3JtSGVhZGVycyA9IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6IGNvbnRlbnRUeXBlICsgJzsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKSxcbiAgICAgICAgJ2NvbnRlbnQtbGVuZ3RoJzogdGhpcy5nZXRMZW5ndGhTeW5jKClcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1IZWFkZXJzO1xufVxuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9ib3VuZGFyeSkge1xuICAgIHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9ib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvIHRob3NlIHVzZWQgYnkgRmlyZWZveC5cbiAgLy8gVGhleSBhcmUgb3B0aW1pemVkIGZvciBib3llci1tb29yZSBwYXJzaW5nLlxuICB2YXIgYm91bmRhcnkgPSAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICBib3VuZGFyeSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGhTeW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcblxuICAgIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICBrbm93bkxlbmd0aCArPSB0aGlzLl9sYXN0Qm91bmRhcnkoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duTGVuZ3RoO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9sZW5ndGhSZXRyaWV2ZXJzLmxlbmd0aCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZCh0aGlzLCBudWxsLCBrbm93bkxlbmd0aCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5jLnBhcmFsbGVsKHRoaXMuX2xlbmd0aFJldHJpZXZlcnMsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGtub3duTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNiKG51bGwsIGtub3duTGVuZ3RoKTtcbiAgfSk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuICB0aGlzLmdldExlbmd0aChmdW5jdGlvbihlcnIsIGxlbmd0aCkge1xuXG4gICAgdmFyIHJlcXVlc3RcbiAgICAgICwgb3B0aW9uc1xuICAgICAgLCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBtZXRob2QgOiAncG9zdCcsXG4gICAgICAgICAgcG9ydCAgIDogODAsXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKHsnQ29udGVudC1MZW5ndGgnOiBsZW5ndGh9KVxuICAgICAgfTtcblxuICAgIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xuICAgIC8vIG9yIHRyZWF0IGl0IGFzIG9wdGlvbnMgb2JqZWN0XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcyA9IHBhcnNlVXJsKHBhcmFtcyk7XG5cbiAgICAgIG9wdGlvbnMgPSBwb3B1bGF0ZSh7XG4gICAgICAgIHBvcnQ6IHBhcmFtcy5wb3J0LFxuICAgICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXG4gICAgICAgIGhvc3Q6IHBhcmFtcy5ob3N0bmFtZVxuICAgICAgfSwgZGVmYXVsdHMpO1xuICAgIH1cbiAgICBlbHNlIC8vIHVzZSBjdXN0b20gcGFyYW1zXG4gICAge1xuICAgICAgb3B0aW9ucyA9IHBvcHVsYXRlKHBhcmFtcywgZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIC8vIGh0dHBzIGlmIHNwZWNpZmllZCwgZmFsbGJhY2sgdG8gaHR0cCBpbiBhbnkgb3RoZXIgY2FzZVxuICAgIGlmIChwYXJhbXMucHJvdG9jb2wgPT0gJ2h0dHBzOicpIHtcbiAgICAgIC8vIG92ZXJyaWRlIGRlZmF1bHQgcG9ydFxuICAgICAgaWYgKCFwYXJhbXMucG9ydCkgb3B0aW9ucy5wb3J0ID0gNDQzO1xuICAgICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5waXBlKHJlcXVlc3QpO1xuICAgIGlmIChjYikge1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCBjYik7XG4gICAgICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIGNiLmJpbmQodGhpcywgbnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0O1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLypcbiAqIFNhbnRhJ3MgbGl0dGxlIGhlbHBlcnNcbiAqL1xuXG4vLyBwb3B1bGF0ZXMgbWlzc2luZyB2YWx1ZXNcbmZ1bmN0aW9uIHBvcHVsYXRlKGRzdCwgc3JjKSB7XG4gIGZvciAodmFyIHByb3AgaW4gc3JjKSB7XG4gICAgaWYgKCFkc3RbcHJvcF0pIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgfVxuICByZXR1cm4gZHN0O1xufVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihwcm9jZXNzKXsvKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF9rZXlzKHJlc3VsdHMpLmxlbmd0aCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSAodGFza3Nba10gaW5zdGFuY2VvZiBGdW5jdGlvbikgPyBbdGFza3Nba11dOiB0YXNrc1trXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKHRhc2tzLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBjb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4pIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBOb2RlLmpzXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBUaGlzIGNoZWFwIHJlcGxpY2Egb2YgRE9NL0J1aWxkZXIgcHV0cyBtZSB0byBzaGFtZSA6LSlcbiAqXG4gKiBBdHRyaWJ1dGVzIGFyZSBpbiB0aGUgZWxlbWVudC5hdHRycyBvYmplY3QuIENoaWxkcmVuIGlzIGEgbGlzdCBvZlxuICogZWl0aGVyIG90aGVyIEVsZW1lbnRzIG9yIFN0cmluZ3MgZm9yIHRleHQgY29udGVudC5cbiAqKi9cbmZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cnMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmF0dHJzID0gYXR0cnMgfHwge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xufVxuXG4vKioqIEFjY2Vzc29ycyAqKiovXG5cbi8qKlxuICogaWYgKGVsZW1lbnQuaXMoJ21lc3NhZ2UnLCAnamFiYmVyOmNsaWVudCcpKSAuLi5cbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmlzID0gZnVuY3Rpb24obmFtZSwgeG1sbnMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYW1lKCkgPT0gbmFtZSAmJlxuICAgICAgICAoIXhtbG5zIHx8IHRoaXMuZ2V0TlMoKSA9PSB4bWxucyk7XG59O1xuXG4vKiB3aXRob3V0IHByZWZpeCAqL1xuRWxlbWVudC5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm5hbWUuaW5kZXhPZihcIjpcIikgPj0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZS5zdWJzdHIodGhpcy5uYW1lLmluZGV4T2YoXCI6XCIpICsgMSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xufTtcblxuLyoqXG4gKiByZXRyaWV2ZXMgdGhlIG5hbWVzcGFjZSBvZiB0aGUgY3VycmVudCBlbGVtZW50LCB1cHdhcmRzIHJlY3Vyc2l2ZWx5XG4gKiovXG5FbGVtZW50LnByb3RvdHlwZS5nZXROUyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm5hbWUuaW5kZXhPZihcIjpcIikgPj0gMCkge1xuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5uYW1lLnN1YnN0cigwLCB0aGlzLm5hbWUuaW5kZXhPZihcIjpcIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kTlMocHJlZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kTlMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGZpbmQgdGhlIG5hbWVzcGFjZSB0byB0aGUgZ2l2ZW4gcHJlZml4LCB1cHdhcmRzIHJlY3Vyc2l2ZWx5XG4gKiovXG5FbGVtZW50LnByb3RvdHlwZS5maW5kTlMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAvKiBkZWZhdWx0IG5hbWVzcGFjZSAqL1xuICAgICAgICBpZiAodGhpcy5hdHRycy54bWxucylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLnhtbG5zO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5maW5kTlMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvKiBwcmVmaXhlZCBuYW1lc3BhY2UgKi9cbiAgICAgICAgdmFyIGF0dHIgPSAneG1sbnM6JyArIHByZWZpeDtcbiAgICAgICAgaWYgKHRoaXMuYXR0cnNbYXR0cl0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyc1thdHRyXTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZmluZE5TKHByZWZpeCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB4bWxucyBjYW4gYmUgbnVsbFxuICoqL1xuRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbihuYW1lLCB4bWxucykge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuKG5hbWUsIHhtbG5zKVswXTtcbn07XG5cbi8qKlxuICogeG1sbnMgY2FuIGJlIG51bGxcbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24obmFtZSwgeG1sbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmdldE5hbWUgJiZcbiAgICAgICAgICAgIGNoaWxkLmdldE5hbWUoKSA9PSBuYW1lICYmXG4gICAgICAgICAgICAoIXhtbG5zIHx8IGNoaWxkLmdldE5TKCkgPT0geG1sbnMpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiB4bWxucyBhbmQgcmVjdXJzaXZlIGNhbiBiZSBudWxsXG4gKiovXG5FbGVtZW50LnByb3RvdHlwZS5nZXRDaGlsZEJ5QXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbCwgeG1sbnMsIHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuQnlBdHRyKGF0dHIsIHZhbCwgeG1sbnMsIHJlY3Vyc2l2ZSlbMF07XG59O1xuXG4vKipcbiAqIHhtbG5zIGFuZCByZWN1cnNpdmUgY2FuIGJlIG51bGxcbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmdldENoaWxkcmVuQnlBdHRyID0gZnVuY3Rpb24oYXR0ciwgdmFsLCB4bWxucywgcmVjdXJzaXZlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5hdHRycyAmJlxuICAgICAgICAgICAgY2hpbGQuYXR0cnNbYXR0cl0gPT0gdmFsICYmXG4gICAgICAgICAgICAoIXhtbG5zIHx8IGNoaWxkLmdldE5TKCkgPT0geG1sbnMpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICBpZiAocmVjdXJzaXZlICYmIGNoaWxkLmdldENoaWxkcmVuQnlBdHRyKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuZ2V0Q2hpbGRyZW5CeUF0dHIoYXR0ciwgdmFsLCB4bWxucywgdHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAocmVjdXJzaXZlKSByZXN1bHQgPSBbXS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlLmdldENoaWxkcmVuQnlGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIsIHJlY3Vyc2l2ZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZmlsdGVyKGNoaWxkKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSAmJiBjaGlsZC5nZXRDaGlsZHJlbkJ5RmlsdGVyKXtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLmdldENoaWxkcmVuQnlGaWx0ZXIoZmlsdGVyLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3Vyc2l2ZSl7XG4gICAgICByZXN1bHQgPSBbXS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRleHQgPSBcIlwiO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0ZXh0ICs9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlLmdldENoaWxkVGV4dCA9IGZ1bmN0aW9uKG5hbWUsIHhtbG5zKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5nZXRDaGlsZChuYW1lLCB4bWxucyk7XG4gICAgcmV0dXJuIGNoaWxkID8gY2hpbGQuZ2V0VGV4dCgpIDogbnVsbDtcbn07XG5cbi8qKiogQnVpbGRlciAqKiovXG5cbi8qKiByZXR1cm5zIHVwcGVybW9zdCBwYXJlbnQgKi9cbkVsZW1lbnQucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yb290KCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGhpcztcbn07XG5FbGVtZW50LnByb3RvdHlwZS50cmVlID0gRWxlbWVudC5wcm90b3R5cGUucm9vdDtcblxuLyoqIGp1c3QgcGFyZW50IG9yIGl0c2VsZiAqL1xuRWxlbWVudC5wcm90b3R5cGUudXAgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIGNyZWF0ZSBjaGlsZCBub2RlIGFuZCByZXR1cm4gaXQgKi9cbkVsZW1lbnQucHJvdG90eXBlLmMgPSBmdW5jdGlvbihuYW1lLCBhdHRycykge1xuICAgIHJldHVybiB0aGlzLmNub2RlKG5ldyBFbGVtZW50KG5hbWUsIGF0dHJzKSk7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZS5jbm9kZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKiBhZGQgdGV4dCBub2RlIGFuZCByZXR1cm4gZWxlbWVudCAqL1xuRWxlbWVudC5wcm90b3R5cGUudCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2godGV4dCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKioqIE1hbmlwdWxhdGlvbiAqKiovXG5cbi8qKlxuICogRWl0aGVyOlxuICogICBlbC5yZW1vdmUoY2hpbGRFbCk7XG4gKiAgIGVsLnJlbW92ZSgnYXV0aG9yJywgJ3VybjouLi4nKTtcbiAqL1xuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZWwsIHhtbG5zKSB7XG4gICAgdmFyIGZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuXHQvKiAxc3QgcGFyYW1ldGVyIGlzIHRhZyBuYW1lICovXG5cdGZpbHRlciA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdCAgICByZXR1cm4gIShjaGlsZC5pcyAmJlxuXHRcdCAgICAgY2hpbGQuaXMoZWwsIHhtbG5zKSk7XG5cdH07XG4gICAgfSBlbHNlIHtcblx0LyogMXN0IHBhcmFtZXRlciBpcyBlbGVtZW50ICovXG5cdGZpbHRlciA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdCAgICByZXR1cm4gY2hpbGQgIT09IGVsO1xuXHR9O1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihmaWx0ZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRvIHVzZSBpbiBjYXNlIHlvdSB3YW50IHRoZSBzYW1lIFhNTCBkYXRhIGZvciBzZXBhcmF0ZSB1c2VzLlxuICogUGxlYXNlIHJlZnJhaW4gZnJvbSB0aGlzIHByYWN0aXNlIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmVcbiAqIGRvaW5nLiBCdWlsZGluZyBYTUwgd2l0aCBsdHggaXMgZWFzeSFcbiAqL1xuRWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgRWxlbWVudCh0aGlzLm5hbWUsIHt9KTtcbiAgICBmb3IodmFyIGsgaW4gdGhpcy5hdHRycykge1xuXHRpZiAodGhpcy5hdHRycy5oYXNPd25Qcm9wZXJ0eShrKSlcblx0ICAgIGNsb25lLmF0dHJzW2tdID0gdGhpcy5hdHRyc1trXTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0Y2xvbmUuY25vZGUoY2hpbGQuY2xvbmUgPyBjaGlsZC5jbG9uZSgpIDogY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgaWYodmFsICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDEpe1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdID0gdmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgIGlmICghKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8IHZhbCA9PT0gbnVsbCkpIHtcbiAgICAgICAgaWYoIXRoaXMuYXR0cnMpe1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF0dHJzW2F0dHJdID0gdmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXR0cnNbYXR0cl07XG59O1xuXG4vKioqIFNlcmlhbGl6YXRpb24gKioqL1xuXG5FbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzID0gXCJcIjtcbiAgICB0aGlzLndyaXRlKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcyArPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiBzO1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgICB3cml0ZXIoXCI8XCIpO1xuICAgIHdyaXRlcih0aGlzLm5hbWUpO1xuICAgIGZvcih2YXIgayBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5hdHRyc1trXTtcblx0aWYgKHYgfHwgdiA9PT0gJycgfHwgdiA9PT0gMCkge1xuXHQgICAgd3JpdGVyKFwiIFwiKTtcbiAgICAgICAgICAgIHdyaXRlcihrKTtcbiAgICAgICAgICAgIHdyaXRlcihcIj1cXFwiXCIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ICE9ICdzdHJpbmcnKVxuXHRcdHYgPSB2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB3cml0ZXIoZXNjYXBlWG1sKHYpKTtcbiAgICAgICAgICAgIHdyaXRlcihcIlxcXCJcIik7XG5cdH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgd3JpdGVyKFwiLz5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVyKFwiPlwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cdCAgICAvKiBTa2lwIG51bGwvdW5kZWZpbmVkICovXG5cdCAgICBpZiAoY2hpbGQgfHwgY2hpbGQgPT09IDApIHtcblx0XHRpZiAoY2hpbGQud3JpdGUpXG5cdFx0ICAgIGNoaWxkLndyaXRlKHdyaXRlcik7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJylcblx0XHRcdHdyaXRlcihlc2NhcGVYbWxUZXh0KGNoaWxkKSk7XG5cdFx0ZWxzZSBpZiAoY2hpbGQudG9TdHJpbmcpXG5cdFx0XHR3cml0ZXIoZXNjYXBlWG1sVGV4dChjaGlsZC50b1N0cmluZygpKSk7XG5cdCAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyKFwiPC9cIik7XG4gICAgICAgIHdyaXRlcih0aGlzLm5hbWUpO1xuICAgICAgICB3cml0ZXIoXCI+XCIpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGVzY2FwZVhtbChzKSB7XG4gICAgcmV0dXJuIHMuXG4gICAgICAgIHJlcGxhY2UoL1xcJi9nLCAnJmFtcDsnKS5cbiAgICAgICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgICAgICByZXBsYWNlKC8+L2csICcmZ3Q7JykuXG4gICAgICAgIHJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5cbiAgICAgICAgcmVwbGFjZSgvJy9nLCAnJmFwb3M7Jyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVhtbFRleHQocykge1xuICAgIHJldHVybiBzLlxuICAgICAgICByZXBsYWNlKC9cXCYvZywgJyZhbXA7JykuXG4gICAgICAgIHJlcGxhY2UoLzwvZywgJyZsdDsnKS5cbiAgICAgICAgcmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuXG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5lc2NhcGVYbWwgPSBlc2NhcGVYbWw7XG4iLCIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgQWxnb3JpdGhtcyA9IHtcbiAgJ3JzYS1zaGExJzogdHJ1ZSxcbiAgJ3JzYS1zaGEyNTYnOiB0cnVlLFxuICAncnNhLXNoYTUxMic6IHRydWUsXG4gICdkc2Etc2hhMSc6IHRydWUsXG4gICdobWFjLXNoYTEnOiB0cnVlLFxuICAnaG1hYy1zaGEyNTYnOiB0cnVlLFxuICAnaG1hYy1zaGE1MTInOiB0cnVlXG59O1xuXG52YXIgU3RhdGUgPSB7XG4gIE5ldzogMCxcbiAgUGFyYW1zOiAxXG59O1xuXG52YXIgUGFyYW1zU3RhdGUgPSB7XG4gIE5hbWU6IDAsXG4gIFF1b3RlOiAxLFxuICBWYWx1ZTogMixcbiAgQ29tbWE6IDNcbn07XG5cblxuXG4vLy8tLS0gU3BlY2lmaWMgRXJyb3JzXG5cbmZ1bmN0aW9uIEh0dHBTaWduYXR1cmVFcnJvcihtZXNzYWdlLCBjYWxsZXIpIHtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGNhbGxlciB8fCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9IGNhbGxlci5uYW1lO1xufVxudXRpbC5pbmhlcml0cyhIdHRwU2lnbmF0dXJlRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gRXhwaXJlZFJlcXVlc3RFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEV4cGlyZWRSZXF1ZXN0RXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhFeHBpcmVkUmVxdWVzdEVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIEludmFsaWRIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEludmFsaWRIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkUGFyYW1zRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkUGFyYW1zRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkUGFyYW1zRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gTWlzc2luZ0hlYWRlckVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgTWlzc2luZ0hlYWRlckVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWlzc2luZ0hlYWRlckVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSAnQXV0aG9yaXphdGlvbicgaGVhZGVyIG91dCBvZiBhbiBodHRwLlNlcnZlclJlcXVlc3Qgb2JqZWN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBBUEkgd2lsbCBmdWxseSB2YWxpZGF0ZSB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXIsIGFuZCB0aHJvd1xuICAgKiBvbiBhbnkgZXJyb3IuICBJdCB3aWxsIG5vdCBob3dldmVyIGNoZWNrIHRoZSBzaWduYXR1cmUsIG9yIHRoZSBrZXlJZCBmb3JtYXRcbiAgICogYXMgdGhvc2UgYXJlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQuICBZb3UgY2FuIHVzZSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICogdG8gcGFzcyBpbiBleHRyYSBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQXMgYSByZXNwb25zZSBvYmplY3QgeW91IGNhbiBleHBlY3QgdGhpczpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgXCJzY2hlbWVcIjogXCJTaWduYXR1cmVcIixcbiAgICogICAgICAgXCJwYXJhbXNcIjoge1xuICAgKiAgICAgICAgIFwia2V5SWRcIjogXCJmb29cIixcbiAgICogICAgICAgICBcImFsZ29yaXRobVwiOiBcInJzYS1zaGEyNTZcIixcbiAgICogICAgICAgICBcImhlYWRlcnNcIjogW1xuICAgKiAgICAgICAgICAgXCJkYXRlXCIgb3IgXCJ4LWRhdGVcIixcbiAgICogICAgICAgICAgIFwiY29udGVudC1tZDVcIlxuICAgKiAgICAgICAgIF0sXG4gICAqICAgICAgICAgXCJzaWduYXR1cmVcIjogXCJiYXNlNjRcIlxuICAgKiAgICAgICB9LFxuICAgKiAgICAgICBcInNpZ25pbmdTdHJpbmdcIjogXCJyZWFkeSB0byBiZSBwYXNzZWQgdG8gY3J5cHRvLnZlcmlmeSgpXCJcbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYW4gaHR0cC5TZXJ2ZXJSZXF1ZXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIGNsb2NrU2tldzogYWxsb3dlZCBjbG9jayBza2V3IGluIHNlY29uZHMgKGRlZmF1bHQgMzAwKS5cbiAgICogICAgICAgICAgICAgICAgICAgLSBoZWFkZXJzOiByZXF1aXJlZCBoZWFkZXIgbmFtZXMgKGRlZjogZGF0ZSBvciB4LWRhdGUpXG4gICAqICAgICAgICAgICAgICAgICAgIC0gYWxnb3JpdGhtczogYWxnb3JpdGhtcyB0byBzdXBwb3J0IChkZWZhdWx0OiBhbGwpLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhcnNlZCBvdXQgb2JqZWN0IChzZWUgYWJvdmUpLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGludmFsaWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRIZWFkZXJFcnJvcn0gb24gYW4gaW52YWxpZCBBdXRob3JpemF0aW9uIGhlYWRlciBlcnJvci5cbiAgICogQHRocm93cyB7SW52YWxpZFBhcmFtc0Vycm9yfSBpZiB0aGUgcGFyYW1zIGluIHRoZSBzY2hlbWUgYXJlIGludmFsaWQuXG4gICAqIEB0aHJvd3Mge01pc3NpbmdIZWFkZXJFcnJvcn0gaWYgdGhlIHBhcmFtcyBpbmRpY2F0ZSBhIGhlYWRlciBub3QgcHJlc2VudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXIgaW4gdGhlIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoZSBwYXJhbXMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Igbm90IGluIHRoZSBwYXJhbXMgZnJvbSBhIHJlcXVpcmVkIGhlYWRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9wdGlvbnMuXG4gICAqIEB0aHJvd3Mge0V4cGlyZWRSZXF1ZXN0RXJyb3J9IGlmIHRoZSB2YWx1ZSBvZiBkYXRlIG9yIHgtZGF0ZSBleGNlZWRzIHNrZXcuXG4gICAqL1xuICBwYXJzZVJlcXVlc3Q6IGZ1bmN0aW9uIHBhcnNlUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LCAncmVxdWVzdCcpO1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdC5oZWFkZXJzLCAncmVxdWVzdC5oZWFkZXJzJyk7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IFtyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddID8gJ3gtZGF0ZScgOiAnZGF0ZSddO1xuICAgIH1cbiAgICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgYXNzZXJ0LmFycmF5T2ZTdHJpbmcob3B0aW9ucy5oZWFkZXJzLCAnb3B0aW9ucy5oZWFkZXJzJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsTnVtYmVyKG9wdGlvbnMuY2xvY2tTa2V3LCAnb3B0aW9ucy5jbG9ja1NrZXcnKTtcblxuICAgIGlmICghcmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb24pXG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKCdubyBhdXRob3JpemF0aW9uIGhlYWRlciBwcmVzZW50IGluICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGhlIHJlcXVlc3QnKTtcblxuICAgIG9wdGlvbnMuY2xvY2tTa2V3ID0gb3B0aW9ucy5jbG9ja1NrZXcgfHwgMzAwO1xuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0YXRlID0gU3RhdGUuTmV3O1xuICAgIHZhciBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgdmFyIHRtcE5hbWUgPSAnJztcbiAgICB2YXIgdG1wVmFsdWUgPSAnJztcblxuICAgIHZhciBwYXJzZWQgPSB7XG4gICAgICBzY2hlbWU6ICcnLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHNpZ25pbmdTdHJpbmc6ICcnLFxuXG4gICAgICBnZXQgYWxnb3JpdGhtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9LFxuXG4gICAgICBnZXQga2V5SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5rZXlJZDtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgYXV0aHogPSByZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXV0aHoubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gYXV0aHouY2hhckF0KGkpO1xuXG4gICAgICBzd2l0Y2ggKE51bWJlcihzdGF0ZSkpIHtcblxuICAgICAgY2FzZSBTdGF0ZS5OZXc6XG4gICAgICAgIGlmIChjICE9PSAnICcpIHBhcnNlZC5zY2hlbWUgKz0gYztcbiAgICAgICAgZWxzZSBzdGF0ZSA9IFN0YXRlLlBhcmFtcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RhdGUuUGFyYW1zOlxuICAgICAgICBzd2l0Y2ggKE51bWJlcihzdWJzdGF0ZSkpIHtcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLk5hbWU6XG4gICAgICAgICAgdmFyIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgLy8gcmVzdHJpY3RlZCBuYW1lIG9mIEEtWiAvIGEtelxuICAgICAgICAgIGlmICgoY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1YSkgfHwgLy8gQS1aXG4gICAgICAgICAgICAgIChjb2RlID49IDB4NjEgJiYgY29kZSA8PSAweDdhKSkgeyAvLyBhLXpcbiAgICAgICAgICAgIHRtcE5hbWUgKz0gYztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgaWYgKHRtcE5hbWUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLlF1b3RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuUXVvdGU6XG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHRtcFZhbHVlID0gJyc7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLlZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuVmFsdWU6XG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXJhbXNbdG1wTmFtZV0gPSB0bXBWYWx1ZTtcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuQ29tbWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcFZhbHVlICs9IGM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuQ29tbWE6XG4gICAgICAgICAgaWYgKGMgPT09ICcsJykge1xuICAgICAgICAgICAgdG1wTmFtZSA9ICcnO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5OYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmhlYWRlcnMgfHwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID09PSAnJykge1xuICAgICAgaWYgKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gWyd4LWRhdGUnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IFsnZGF0ZSddO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBwYXJzZWQucGFyYW1zLmhlYWRlcnMuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICAvLyBNaW5pbWFsbHkgdmFsaWRhdGUgdGhlIHBhcnNlZCBvYmplY3RcbiAgICBpZiAoIXBhcnNlZC5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSAhPT0gJ1NpZ25hdHVyZScpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdzY2hlbWUgd2FzIG5vdCBcIlNpZ25hdHVyZVwiJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMua2V5SWQpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdrZXlJZCB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmFsZ29yaXRobSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2FsZ29yaXRobSB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLnNpZ25hdHVyZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ3NpZ25hdHVyZSB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGFsZ29yaXRobSBhZ2FpbnN0IHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gPSBwYXJzZWQucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghQWxnb3JpdGhtc1twYXJzZWQucGFyYW1zLmFsZ29yaXRobV0pXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtc0Vycm9yKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICAvLyBCdWlsZCB0aGUgc2lnbmluZ1N0cmluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZWQucGFyYW1zLmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoID0gcGFyc2VkLnBhcmFtcy5oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnNbaV0gPSBoO1xuXG4gICAgICBpZiAoaCAhPT0gJ3JlcXVlc3QtbGluZScpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVxdWVzdC5oZWFkZXJzW2hdO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaCArICcgd2FzIG5vdCBpbiB0aGUgcmVxdWVzdCcpO1xuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPSBoICsgJzogJyArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz1cbiAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsICsgJyBIVFRQLycgKyByZXF1ZXN0Lmh0dHBWZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgKyAxKSA8IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5sZW5ndGgpXG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFnYWluc3QgdGhlIGNvbnN0cmFpbnRzXG4gICAgdmFyIGRhdGU7XG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycy5kYXRlIHx8IHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlcXVlc3QuaGVhZGVycy5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICB2YXIgc2tldyA9IE1hdGguYWJzKG5vdy5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSk7XG5cbiAgICAgIGlmIChza2V3ID4gb3B0aW9ucy5jbG9ja1NrZXcgKiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFeHBpcmVkUmVxdWVzdEVycm9yKCdjbG9jayBza2V3IG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2tldyAvIDEwMDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Mgd2FzIGdyZWF0ZXIgdGhhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jbG9ja1NrZXcgKyAncycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZHIpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoYXQgd2UgYWxyZWFkeSBjaGVja2VkIGFueSBoZWFkZXJzIGluIHRoZSBwYXJhbXNcbiAgICAgIC8vIHdlcmUgaW4gdGhlIHJlcXVlc3QsIHNvIGlmIHRoaXMgcGFzc2VzIHdlJ3JlIGdvb2QuXG4gICAgICBpZiAocGFyc2VkLnBhcmFtcy5oZWFkZXJzLmluZGV4T2YoaGRyKSA8IDApXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaGRyICsgJyB3YXMgbm90IGEgc2lnbmVkIGhlYWRlcicpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtcy5pbmRleE9mKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgbm90IGEgc3VwcG9ydGVkIGFsZ29yaXRobScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxufTtcbiIsIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIHNwcmludGYgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIEFsZ29yaXRobXMgPSB7XG4gICdyc2Etc2hhMSc6IHRydWUsXG4gICdyc2Etc2hhMjU2JzogdHJ1ZSxcbiAgJ3JzYS1zaGE1MTInOiB0cnVlLFxuICAnZHNhLXNoYTEnOiB0cnVlLFxuICAnaG1hYy1zaGExJzogdHJ1ZSxcbiAgJ2htYWMtc2hhMjU2JzogdHJ1ZSxcbiAgJ2htYWMtc2hhNTEyJzogdHJ1ZVxufTtcblxudmFyIEF1dGhvcml6YXRpb24gPVxuICAnU2lnbmF0dXJlIGtleUlkPVwiJXNcIixhbGdvcml0aG09XCIlc1wiLGhlYWRlcnM9XCIlc1wiLHNpZ25hdHVyZT1cIiVzXCInO1xuXG5cblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5mdW5jdGlvbiBNaXNzaW5nSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nSGVhZGVyRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5NaXNzaW5nSGVhZGVyRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cblxuZnVuY3Rpb24gSW52YWxpZEFsZ29yaXRobUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFsZ29yaXRobUVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuSW52YWxpZEFsZ29yaXRobUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5cblxuLy8vLS0tIEludGVybmFsIEZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfcGFkKHZhbCkge1xuICBpZiAocGFyc2VJbnQodmFsLCAxMCkgPCAxMCkge1xuICAgIHZhbCA9ICcwJyArIHZhbDtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG5cbmZ1bmN0aW9uIF9yZmMxMTIzKCkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgdmFyIG1vbnRocyA9IFsnSmFuJyxcbiAgICAgICAgICAgICAgICAnRmViJyxcbiAgICAgICAgICAgICAgICAnTWFyJyxcbiAgICAgICAgICAgICAgICAnQXByJyxcbiAgICAgICAgICAgICAgICAnTWF5JyxcbiAgICAgICAgICAgICAgICAnSnVuJyxcbiAgICAgICAgICAgICAgICAnSnVsJyxcbiAgICAgICAgICAgICAgICAnQXVnJyxcbiAgICAgICAgICAgICAgICAnU2VwJyxcbiAgICAgICAgICAgICAgICAnT2N0JyxcbiAgICAgICAgICAgICAgICAnTm92JyxcbiAgICAgICAgICAgICAgICAnRGVjJ107XG4gIHZhciBkYXlzID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgcmV0dXJuIGRheXNbZGF0ZS5nZXRVVENEYXkoKV0gKyAnLCAnICtcbiAgICBfcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpKSArICcgJyArXG4gICAgbW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV0gKyAnICcgK1xuICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArICcgJyArXG4gICAgX3BhZChkYXRlLmdldFVUQ0hvdXJzKCkpICsgJzonICtcbiAgICBfcGFkKGRhdGUuZ2V0VVRDTWludXRlcygpKSArICc6JyArXG4gICAgX3BhZChkYXRlLmdldFVUQ1NlY29uZHMoKSkgK1xuICAgICcgR01UJztcbn1cblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gJ0F1dGhvcml6YXRpb24nIGhlYWRlciB0byBhbiBodHRwLkNsaWVudFJlcXVlc3Qgb2JqZWN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBBUEkgd2lsbCBhZGQgYSBEYXRlIGhlYWRlciBpZiBpdCdzIG5vdCBhbHJlYWR5IHNldC4gQW55XG4gICAqIG90aGVyIGhlYWRlcnMgaW4gdGhlIG9wdGlvbnMuaGVhZGVycyBhcnJheSBNVVNUIGJlIHByZXNlbnQsIG9yIHRoaXNcbiAgICogd2lsbCB0aHJvdy5cbiAgICpcbiAgICogWW91IHNob3VsZG4ndCBuZWVkIHRvIGNoZWNrIHRoZSByZXR1cm4gdHlwZTsgaXQncyBqdXN0IHRoZXJlIGlmIHlvdSB3YW50XG4gICAqIHRvIGJlIHBlZGFudGljLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBhbiBpbnN0YW5jZSBvZiBodHRwLkNsaWVudFJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNpZ25pbmcgcGFyYW1ldGVycyBvYmplY3Q6XG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5SWQgcmVxdWlyZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30ga2V5IHJlcXVpcmVkIChlaXRoZXIgYSBQRU0gb3IgSE1BQyBrZXkpLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtBcnJheX0gaGVhZGVycyBvcHRpb25hbDsgZGVmYXVsdHMgdG8gWydkYXRlJ10uXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gYWxnb3JpdGhtIG9wdGlvbmFsOyBkZWZhdWx0cyB0byAncnNhLXNoYTI1NicuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gaHR0cFZlcnNpb24gb3B0aW9uYWw7IGRlZmF1bHRzIHRvICcxLjEnLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIEF1dGhvcml6YXRpb24gKGFuZCBvcHRpb25hbGx5IERhdGUpIHdlcmUgYWRkZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gb24gYmFkIHBhcmFtZXRlciB0eXBlcyAoaW5wdXQpLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkQWxnb3JpdGhtRXJyb3J9IGlmIGFsZ29yaXRobSB3YXMgYmFkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIGEgaGVhZGVyIHRvIGJlIHNpZ25lZCB3YXMgc3BlY2lmaWVkIGJ1dFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBub3QgcHJlc2VudC5cbiAgICovXG4gIHNpZ25SZXF1ZXN0OiBmdW5jdGlvbiBzaWduUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LCAncmVxdWVzdCcpO1xuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5rZXlJZCwgJ29wdGlvbnMua2V5SWQnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxBcnJheU9mU3RyaW5nKG9wdGlvbnMuaGVhZGVycywgJ29wdGlvbnMuaGVhZGVycycpO1xuICAgIGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmh0dHBWZXJzaW9uLCAnb3B0aW9ucy5odHRwVmVyc2lvbicpO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmdldEhlYWRlcignRGF0ZScpKVxuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0RhdGUnLCBfcmZjMTEyMygpKTtcbiAgICBpZiAoIW9wdGlvbnMuaGVhZGVycylcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IFsnZGF0ZSddO1xuICAgIGlmICghb3B0aW9ucy5hbGdvcml0aG0pXG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9ICdyc2Etc2hhMjU2JztcbiAgICBpZiAoIW9wdGlvbnMuaHR0cFZlcnNpb24pXG4gICAgICBvcHRpb25zLmh0dHBWZXJzaW9uID0gJzEuMSc7XG5cbiAgICBvcHRpb25zLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIUFsZ29yaXRobXNbb3B0aW9ucy5hbGdvcml0aG1dKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihvcHRpb25zLmFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIHN0cmluZ1RvU2lnbiA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuaGVhZGVyc1tpXSkgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmhlYWRlcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBTdHJpbmdzJyk7XG5cbiAgICAgIHZhciBoID0gb3B0aW9ucy5oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChoICE9PSAncmVxdWVzdC1saW5lJykge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LmdldEhlYWRlcihoKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaCArICcgd2FzIG5vdCBpbiB0aGUgcmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmluZ1RvU2lnbiArPSBoICsgJzogJyArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz1cbiAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QucGF0aCArICcgSFRUUC8nICsgb3B0aW9ucy5odHRwVmVyc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgdmFyIGFsZyA9IG9wdGlvbnMuYWxnb3JpdGhtLm1hdGNoKC8oaG1hY3xyc2EpLShcXHcrKS8pO1xuICAgIHZhciBzaWduYXR1cmU7XG4gICAgaWYgKGFsZ1sxXSA9PT0gJ2htYWMnKSB7XG4gICAgICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1syXS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLmtleSk7XG4gICAgICBobWFjLnVwZGF0ZShzdHJpbmdUb1NpZ24pO1xuICAgICAgc2lnbmF0dXJlID0gaG1hYy5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24ob3B0aW9ucy5hbGdvcml0aG0udG9VcHBlckNhc2UoKSk7XG4gICAgICBzaWduZXIudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgICBzaWduYXR1cmUgPSBzaWduZXIuc2lnbihvcHRpb25zLmtleSwgJ2Jhc2U2NCcpO1xuICAgIH1cblxuICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgc3ByaW50ZihBdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmtleUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFsZ29yaXRobSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTEgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIFNpbXBseSB3cmFwcyB1cCB0aGUgbm9kZSBjcnlwdG8gb3BlcmF0aW9ucyBmb3IgeW91LCBhbmQgcmV0dXJuc1xuICAgKiB0cnVlIG9yIGZhbHNlLiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluIGFuIG9iamVjdCB0aGF0IHdhc1xuICAgKiByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGVpdGhlciBhbiBSU0EgcHJpdmF0ZSBrZXkgUEVNIG9yIEhNQUMgc2VjcmV0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgeW91IHBhc3MgaW4gYmFkIGFyZ3VtZW50cy5cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZTogZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBhcnNlZFNpZ25hdHVyZSwga2V5KSB7XG4gICAgYXNzZXJ0Lm9iamVjdChwYXJzZWRTaWduYXR1cmUsICdwYXJzZWRTaWduYXR1cmUnKTtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ2tleScpO1xuXG4gICAgdmFyIGFsZyA9IHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0ubWF0Y2goLyhITUFDfFJTQXxEU0EpLShcXHcrKS8pO1xuICAgIGlmICghYWxnIHx8IGFsZy5sZW5ndGggIT09IDMpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZWRTaWduYXR1cmU6IHVuc3VwcG9ydGVkIGFsZ29yaXRobSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkU2lnbmF0dXJlLmFsZ29yaXRobSk7XG5cbiAgICBpZiAoYWxnWzFdID09PSAnSE1BQycpIHtcbiAgICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoYWxnWzJdLnRvVXBwZXJDYXNlKCksIGtleSk7XG4gICAgICBobWFjLnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgICByZXR1cm4gKGhtYWMuZGlnZXN0KCdiYXNlNjQnKSA9PT0gcGFyc2VkU2lnbmF0dXJlLnBhcmFtcy5zaWduYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmVyaWZ5ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShhbGdbMF0pO1xuICAgICAgdmVyaWZ5LnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgICByZXR1cm4gdmVyaWZ5LnZlcmlmeShrZXksIHBhcnNlZFNpZ25hdHVyZS5wYXJhbXMuc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gICAgfVxuICB9XG5cbn07XG4iLCIoZnVuY3Rpb24oQnVmZmVyKXsvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBjdHlwZSA9IHJlcXVpcmUoJ2N0eXBlJyk7XG5cblxuXG4vLy8tLS0gSGVscGVyc1xuXG5mdW5jdGlvbiByZWFkTmV4dChidWZmZXIsIG9mZnNldCkge1xuICB2YXIgbGVuID0gY3R5cGUucnVpbnQzMihidWZmZXIsICdiaWcnLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcblxuICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgbGVuO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YTogYnVmZmVyLnNsaWNlKG9mZnNldCwgbmV3T2Zmc2V0KSxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHdyaXRlSW50KHdyaXRlciwgYnVmZmVyKSB7XG4gIHdyaXRlci53cml0ZUJ5dGUoMHgwMik7IC8vIEFTTjEuSW50ZWdlclxuICB3cml0ZXIud3JpdGVMZW5ndGgoYnVmZmVyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgd3JpdGVyLndyaXRlQnl0ZShidWZmZXJbaV0pO1xuXG4gIHJldHVybiB3cml0ZXI7XG59XG5cblxuZnVuY3Rpb24gcnNhVG9QRU0oa2V5KSB7XG4gIHZhciBidWZmZXI7XG4gIHZhciBkZXI7XG4gIHZhciBleHBvbmVudDtcbiAgdmFyIGk7XG4gIHZhciBtb2R1bHVzO1xuICB2YXIgbmV3S2V5ID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgdHlwZTtcbiAgdmFyIHRtcDtcblxuICB0cnkge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoa2V5LnNwbGl0KCcgJylbMV0sICdiYXNlNjQnKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB0eXBlID0gdG1wLmRhdGEudG9TdHJpbmcoKTtcbiAgICBvZmZzZXQgPSB0bXAub2Zmc2V0O1xuXG4gICAgaWYgKHR5cGUgIT09ICdzc2gtcnNhJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBleHBvbmVudCA9IHRtcC5kYXRhO1xuICAgIG9mZnNldCA9IHRtcC5vZmZzZXQ7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgbW9kdWx1cyA9IHRtcC5kYXRhO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNzaCBrZXk6ICcgKyBrZXkpO1xuICB9XG5cbiAgLy8gREVSIGlzIGEgc3Vic2V0IG9mIEJFUlxuICBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMTM1NDkuMS4xLjEnKTtcbiAgZGVyLndyaXRlTnVsbCgpO1xuICBkZXIuZW5kU2VxdWVuY2UoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgweDAzKTsgLy8gYml0IHN0cmluZ1xuICBkZXIud3JpdGVCeXRlKDB4MDApO1xuXG4gIC8vIEFjdHVhbCBrZXlcbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgd3JpdGVJbnQoZGVyLCBtb2R1bHVzKTtcbiAgd3JpdGVJbnQoZGVyLCBleHBvbmVudCk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIC8vIGJpdCBzdHJpbmdcbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgdG1wID0gZGVyLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgJSA2NCkgPT09IDApXG4gICAgICBuZXdLZXkgKz0gJ1xcbic7XG4gICAgbmV3S2V5ICs9IHRtcC5jaGFyQXQoaSk7XG4gIH1cblxuICBpZiAoIS9cXFxcbiQvLnRlc3QobmV3S2V5KSlcbiAgICBuZXdLZXkgKz0gJ1xcbic7XG5cbiAgcmV0dXJuICctLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLScgKyBuZXdLZXkgKyAnLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXFxuJztcbn1cblxuXG5mdW5jdGlvbiBkc2FUb1BFTShrZXkpIHtcbiAgdmFyIGJ1ZmZlcjtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciB0bXA7XG4gIHZhciBkZXI7XG4gIHZhciBuZXdLZXkgPSAnJztcblxuICB2YXIgdHlwZTtcbiAgdmFyIHA7XG4gIHZhciBxO1xuICB2YXIgZztcbiAgdmFyIHk7XG5cbiAgdHJ5IHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGtleS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0Jyk7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgdHlwZSA9IHRtcC5kYXRhLnRvU3RyaW5nKCk7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKCEvXnNzaC1kc1thc10uKi8udGVzdCh0eXBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBwID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBxID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBnID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB5ID0gdG1wLmRhdGE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3NoIGtleTogJyArIGtleSk7XG4gIH1cblxuICAvLyBERVIgaXMgYSBzdWJzZXQgb2YgQkVSXG4gIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG5cbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQwLjQuMScpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIHdyaXRlSW50KGRlciwgcCk7XG4gIHdyaXRlSW50KGRlciwgcSk7XG4gIHdyaXRlSW50KGRlciwgZyk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKDB4MDMpOyAvLyBiaXQgc3RyaW5nXG4gIGRlci53cml0ZUJ5dGUoMHgwMCk7XG4gIHdyaXRlSW50KGRlciwgeSk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIHRtcCA9IGRlci5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSAlIDY0KSA9PT0gMClcbiAgICAgIG5ld0tleSArPSAnXFxuJztcbiAgICBuZXdLZXkgKz0gdG1wLmNoYXJBdChpKTtcbiAgfVxuXG4gIGlmICghL1xcXFxuJC8udGVzdChuZXdLZXkpKVxuICAgIG5ld0tleSArPSAnXFxuJztcblxuICByZXR1cm4gJy0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tJyArIG5ld0tleSArICctLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cXG4nO1xufVxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhIG9ubHkpIHRvIGEgUEtDUyM4IFBFTSBmaWxlLlxuICAgKlxuICAgKiBUaGUgaW50ZW50IG9mIHRoaXMgbW9kdWxlIGlzIHRvIGludGVyb3BlcmF0ZSB3aXRoIE9wZW5TU0wgb25seSxcbiAgICogc3BlY2lmaWNhbGx5IHRoZSBub2RlIGNyeXB0byBtb2R1bGUncyBgdmVyaWZ5YCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBFTSBlbmNvZGVkIGZvcm0gb2YgdGhlIFJTQSBwdWJsaWMga2V5LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBpbnB1dC5cbiAgICogQHRocm93cyB7RXJyb3J9IG9uIGludmFsaWQgc3NoIGtleSBmb3JtYXR0ZWQgZGF0YS5cbiAgICovXG4gIHNzaEtleVRvUEVNOiBmdW5jdGlvbiBzc2hLZXlUb1BFTShrZXkpIHtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ3NzaF9rZXknKTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLXJzYS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gcnNhVG9QRU0oa2V5KTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLWRzW2FzXS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gZHNhVG9QRU0oa2V5KTtcblxuICAgIHRocm93IG5ldyBFcnJvcignT25seSBSU0EgYW5kIERTQSBwdWJsaWMga2V5cyBhcmUgYWxsb3dlZCcpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPcGVuU1NIIGZpbmdlcnByaW50IGZyb20gYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGtleSBmaW5nZXJwcmludC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB3aGF0IHlvdSBwYXNzZWQgZG9lc24ndCBsb29rIGxpa2UgYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqL1xuICBmaW5nZXJwcmludDogZnVuY3Rpb24gZmluZ2VycHJpbnQoa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KCcgJyk7XG4gICAgaWYgKCFwaWVjZXMgfHwgIXBpZWNlcy5sZW5ndGggfHwgcGllY2VzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3NoIGtleScpO1xuXG4gICAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKHBpZWNlc1sxXSwgJ2Jhc2U2NCcpO1xuXG4gICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgdmFyIGRpZ2VzdCA9IGhhc2guZGlnZXN0KCdoZXgnKTtcblxuICAgIHZhciBmcCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAmJiBpICUgMiA9PT0gMClcbiAgICAgICAgZnAgKz0gJzonO1xuXG4gICAgICBmcCArPSBkaWdlc3RbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZwO1xuICB9XG5cblxufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBsdHggPSByZXF1aXJlKCdsdHgnKTtcbnZhciBTdGFuemEgPSByZXF1aXJlKCcuL3N0YW56YScpLlN0YW56YTtcblxuLyoqXG4gKiBSZWNvZ25pemVzIDxzdHJlYW06c3RyZWFtPiBhbmQgY29sbGVjdHMgc3RhbnphczsgdXNlZCBmb3Igb3JkaW5hcnlcbiAqIFRDUCBzdHJlYW1zIGFuZCBXZWJzb2NrZXRzLlxuICpcbiAqIEFQSTogd3JpdGUoZGF0YSkgJiBlbmQoZGF0YSlcbiAqIEV2ZW50czogc3RyZWFtU3RhcnQsIHN0YW56YSwgZW5kLCBlcnJvclxuICovXG5mdW5jdGlvbiBTdHJlYW1QYXJzZXIobWF4U3RhbnphU2l6ZSkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IGx0eC5iZXN0U2F4UGFyc2VyKCk7XG5cbiAgICAvKiBDb3VudCB0cmFmZmljIGZvciBlbnRpcmUgbGlmZS10aW1lICovXG4gICAgdGhpcy5ieXRlc1BhcnNlZCA9IDA7XG4gICAgdGhpcy5tYXhTdGFuemFTaXplID0gbWF4U3RhbnphU2l6ZTtcbiAgICAvKiBXaWxsIGJlIHJlc2V0IHVwb24gZmlyc3Qgc3RhbnphLCBidXQgZW5mb3JjZSBtYXhTdGFuemFTaXplIHVudGlsIGl0IGlzIHBhcnNlZCAqL1xuICAgIHRoaXMuYnl0ZXNQYXJzZWRPblN0YW56YUJlZ2luID0gMDtcblxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdzdGFydEVsZW1lbnQnLCBmdW5jdGlvbihuYW1lLCBhdHRycykge1xuICAgICAgICAvLyBUT0RPOiByZWZ1c2UgYW55dGhpbmcgYnV0IDxzdHJlYW06c3RyZWFtPlxuICAgICAgICBpZiAoIXNlbGYuZWxlbWVudCAmJiBuYW1lID09ICdzdHJlYW06c3RyZWFtJykge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdzdHJlYW1TdGFydCcsIGF0dHJzKTtcbiAgICAgICAgfSBlbHNlIHtcblx0ICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGlmICghc2VsZi5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLyogQSBuZXcgc3RhbnphICovXG5cdFx0Y2hpbGQgPSBuZXcgU3RhbnphKG5hbWUsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQgPSBjaGlsZDtcblx0XHQvKiBGb3IgbWF4U3RhbnphU2l6ZSBlbmZvcmNlbWVudCAqL1xuICAgICAgICAgICAgICAgIHNlbGYuYnl0ZXNQYXJzZWRPblN0YW56YUJlZ2luID0gc2VsZi5ieXRlc1BhcnNlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQSBjaGlsZCBlbGVtZW50IG9mIGEgc3RhbnphICovXG5cdFx0Y2hpbGQgPSBuZXcgbHR4LkVsZW1lbnQobmFtZSwgYXR0cnMpO1xuICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudCA9IHNlbGYuZWxlbWVudC5jbm9kZShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlbmRFbGVtZW50JywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIXNlbGYuZWxlbWVudCAmJiBuYW1lID09ICdzdHJlYW06c3RyZWFtJykge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmVsZW1lbnQgJiYgbmFtZSA9PSBzZWxmLmVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZWxlbWVudC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5lbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIFN0YW56YSBjb21wbGV0ZSAqL1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnc3RhbnphJywgc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5lbGVtZW50O1xuXHRcdC8qIG1heFN0YW56YVNpemUgZG9lc24ndCBhcHBseSB1bnRpbCBuZXh0IHN0YXJ0RWxlbWVudCAqL1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmJ5dGVzUGFyc2VkT25TdGFuemFCZWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZXJyb3IoJ3htbC1ub3Qtd2VsbC1mb3JtZWQnLCAnWE1MIHBhcnNlIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcigndGV4dCcsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc2VsZi5lbGVtZW50KVxuICAgICAgICAgICAgc2VsZi5lbGVtZW50LnQoc3RyKTtcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignZW50aXR5RGVjbCcsIGZ1bmN0aW9uKCkge1xuXHQvKiBFbnRpdHkgZGVjbGFyYXRpb25zIGFyZSBmb3JiaWRkZW4gaW4gWE1QUC4gV2UgbXVzdCBhYm9ydCB0b1xuXHQgKiBhdm9pZCBhIGJpbGxpb24gbGF1Z2hzLlxuXHQgKi9cblx0c2VsZi5lcnJvcigneG1sLW5vdC13ZWxsLWZvcm1lZCcsICdObyBlbnRpdHkgZGVjbGFyYXRpb25zIGFsbG93ZWQnKTtcblx0c2VsZi5lbmQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG5cdHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG59XG51dGlsLmluaGVyaXRzKFN0cmVhbVBhcnNlciwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuU3RyZWFtUGFyc2VyID0gU3RyZWFtUGFyc2VyO1xuXG5TdHJlYW1QYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIC8qaWYgKC9ePHN0cmVhbTpzdHJlYW0gW14+XStcXC8+JC8udGVzdChkYXRhKSkge1xuXHRkYXRhID0gZGF0YS5yZXBsYWNlKC9cXC8+JC8sIFwiPlwiKTtcbiAgICB9Ki9cbiAgICBpZiAodGhpcy5wYXJzZXIpIHtcblx0LyogSWYgYSBtYXhTdGFuemFTaXplIGlzIGNvbmZpZ3VyZWQsIHRoZSBjdXJyZW50IHN0YW56YSBtdXN0IGNvbnNpc3Qgb25seSBvZiB0aGlzIG1hbnkgYnl0ZXMgKi9cbiAgICAgICAgaWYgKHRoaXMuYnl0ZXNQYXJzZWRPblN0YW56YUJlZ2luICYmIHRoaXMubWF4U3RhbnphU2l6ZSAmJlxuICAgICAgICAgICAgdGhpcy5ieXRlc1BhcnNlZCA+IHRoaXMuYnl0ZXNQYXJzZWRPblN0YW56YUJlZ2luICsgdGhpcy5tYXhTdGFuemFTaXplKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3BvbGljeS12aW9sYXRpb24nLCAnTWF4aW11bSBzdGFuemEgc2l6ZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnl0ZXNQYXJzZWQgKz0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5wYXJzZXIud3JpdGUoZGF0YSk7XG4gICAgfVxufTtcblxuU3RyZWFtUGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhpcy53cml0ZShkYXRhKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5wYXJzZXI7XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbn07XG5cblN0cmVhbVBhcnNlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG59O1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogV2hhdCdzIGF2YWlsYWJsZSBmb3IgY2xpZW50LXNpZGUgYXV0aGVudGljYXRpb24gKENsaWVudClcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBtZWNocyBTZXJ2ZXItb2ZmZXJlZCBTQVNMIG1lY2hhbmlzbSBuYW1lc1xuICovXG5mdW5jdGlvbiBzZWxlY3RNZWNoYW5pc20ob2ZmZXJlZE1lY2hzLCBwcmVmZXJyZWRNZWNoLCBhdmFpbGFibGVNZWNoKSB7XG4gICAgdmFyIG1lY2hDbGFzc2VzID0gW1hPQXV0aDIsIFhGYWNlYm9va1BsYXRmb3JtLCBEaWdlc3RNRDUsXG5cdFx0ICAgICAgIFBsYWluLCBBbm9ueW1vdXNdO1xuICAgIHZhciBieU5hbWUgPSB7fTtcbiAgICB2YXIgbWVjaDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdmFpbGFibGVNZWNoKSkge1xuICAgICAgICBtZWNoQ2xhc3NlcyA9IG1lY2hDbGFzc2VzLmNvbmNhdChhdmFpbGFibGVNZWNoKTtcbiAgICB9XG4gICAgbWVjaENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbihtZWNoQ2xhc3MpIHtcblx0YnlOYW1lW21lY2hDbGFzcy5wcm90b3R5cGUubmFtZV0gPSBtZWNoQ2xhc3M7XG4gICAgfSk7XG4gICAgLyogQW55IHByZWZlcnJlZD8gKi9cbiAgICBpZiAoYnlOYW1lW3ByZWZlcnJlZE1lY2hdKSB7XG5cdG1lY2ggPSBieU5hbWVbcHJlZmVycmVkTWVjaF07XG4gICAgfVxuICAgIC8qIEJ5IHByaW9yaXR5ICovXG4gICAgbWVjaENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbihtZWNoQ2xhc3MpIHtcblx0aWYgKCFtZWNoICYmXG5cdCAgICBvZmZlcmVkTWVjaHMuaW5kZXhPZihtZWNoQ2xhc3MucHJvdG90eXBlLm5hbWUpID49IDApXG5cdCAgICBtZWNoID0gbWVjaENsYXNzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1lY2ggPyBuZXcgbWVjaCgpIDogbnVsbDtcbn1cblxuZXhwb3J0cy5zZWxlY3RNZWNoYW5pc20gPSBzZWxlY3RNZWNoYW5pc207XG5cbi8qKlxuICogV2hhdCdzIGF2YWlsYWJsZSBmb3Igc2VydmVyLXNpZGUgYXV0aGVudGljYXRpb24gKEMyUylcbiAqL1xuZnVuY3Rpb24gYXZhaWxhYmxlTWVjaGFuaXNtcyhhdmFpbGFibGVNZWNoKSB7XG4gICAgdmFyIG1lY2hhbmlzbXMgPSBbbmV3IFBsYWluKCldO1xuICAgIGlmIChhdmFpbGFibGVNZWNoKSB7XG4gICAgICAgIG1lY2hhbmlzbXMgPSBtZWNoYW5pc21zLmNvbmNhdChhdmFpbGFibGVNZWNoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lY2hhbmlzbXM7XG59XG5leHBvcnRzLmF2YWlsYWJsZU1lY2hhbmlzbXMgPSBhdmFpbGFibGVNZWNoYW5pc21zO1xuXG4vLyBNZWNoYW5pc21zXG5mdW5jdGlvbiBNZWNoYW5pc20oKSB7XG59XG51dGlsLmluaGVyaXRzKE1lY2hhbmlzbSwgRXZlbnRFbWl0dGVyKTtcbk1lY2hhbmlzbS5wcm90b3R5cGUuYXV0aEF0dHJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt9O1xufTtcblxuZnVuY3Rpb24gUGxhaW4oKSB7XG59XG51dGlsLmluaGVyaXRzKFBsYWluLCBNZWNoYW5pc20pO1xuUGxhaW4ucHJvdG90eXBlLm5hbWUgPSBcIlBMQUlOXCI7XG5QbGFpbi5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF1dGh6aWQgKyBcIlxcMFwiICtcbiAgICAgICAgdGhpcy5hdXRoY2lkICsgXCJcXDBcIiArXG4gICAgICAgIHRoaXMucGFzc3dvcmQ7XG59O1xuUGxhaW4ucHJvdG90eXBlLmF1dGhTZXJ2ZXIgPSBmdW5jdGlvbihhdXRoLCBjbGllbnQpIHtcbiAgICB2YXIgcGFyYW1zID0gYXV0aC5zcGxpdChcIlxceDAwXCIpO1xuICAgIHRoaXMudXNlcm5hbWUgPSBwYXJhbXNbMV07XG4gICAgY2xpZW50LmF1dGhlbnRpY2F0ZSh0aGlzLnVzZXJuYW1lLCBwYXJhbXNbMl0pO1xufTtcblxuZnVuY3Rpb24gWE9BdXRoMigpIHtcbn1cbnV0aWwuaW5oZXJpdHMoWE9BdXRoMiwgTWVjaGFuaXNtKTtcblhPQXV0aDIucHJvdG90eXBlLm5hbWUgPSBcIlgtT0FVVEgyXCI7XG5YT0F1dGgyLnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiXFwwXCIgKyB0aGlzLmF1dGh6aWQgKyBcIlxcMFwiICsgdGhpcy5vYXV0aDJfdG9rZW47XG59O1xuWE9BdXRoMi5wcm90b3R5cGUuYXV0aFNlcnZlciA9IGZ1bmN0aW9uKGF1dGgsIGNsaWVudCkge1xuICAgIHZhciBwYXJhbXMgPSBhdXRoLnNwbGl0KFwiXFx4MDBcIik7XG4gICAgdGhpcy51c2VybmFtZSA9IHBhcmFtc1sxXTtcbiAgICBjbGllbnQuYXV0aGVudGljYXRlKHRoaXMudXNlcm5hbWUsIHBhcmFtc1syXSk7XG59O1xuWE9BdXRoMi5wcm90b3R5cGUuYXV0aEF0dHJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgXCJhdXRoOnNlcnZpY2VcIjogXCJvYXV0aDJcIixcblx0ICAgICBcInhtbG5zOmF1dGhcIjogdGhpcy5vYXV0aDJfYXV0aFxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBYRmFjZWJvb2tQbGF0Zm9ybSgpIHtcbn1cbnV0aWwuaW5oZXJpdHMoWEZhY2Vib29rUGxhdGZvcm0sIE1lY2hhbmlzbSk7XG5YRmFjZWJvb2tQbGF0Zm9ybS5wcm90b3R5cGUubmFtZSA9IFwiWC1GQUNFQk9PSy1QTEFURk9STVwiO1xuWEZhY2Vib29rUGxhdGZvcm0ucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcIjtcbn07XG5YRmFjZWJvb2tQbGF0Zm9ybS5wcm90b3R5cGUuY2hhbGxlbmdlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBkaWN0ID0gcXVlcnlzdHJpbmcucGFyc2Uocyk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpX2tleSxcbiAgICAgICAgY2FsbF9pZDogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgIG1ldGhvZDogZGljdC5tZXRob2QsXG4gICAgICAgIG5vbmNlOiBkaWN0Lm5vbmNlLFxuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuYWNjZXNzX3Rva2VuLFxuICAgICAgICB2OiBcIjEuMFwiXG4gICAgfTtcblxuICAgIHJldHVybiBxdWVyeXN0cmluZy5zdHJpbmdpZnkocmVzcG9uc2UpO1xufTtcblxuZnVuY3Rpb24gQW5vbnltb3VzKCkge1xufVxudXRpbC5pbmhlcml0cyhBbm9ueW1vdXMsIE1lY2hhbmlzbSk7XG5Bbm9ueW1vdXMucHJvdG90eXBlLm5hbWUgPSBcIkFOT05ZTU9VU1wiO1xuQW5vbnltb3VzLnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aHppZDtcbn07XG5cbmZ1bmN0aW9uIEV4dGVybmFsKCkge1xufVxudXRpbC5pbmhlcml0cyhFeHRlcm5hbCwgTWVjaGFuaXNtKTtcbkV4dGVybmFsLnByb3RvdHlwZS5uYW1lID0gXCJFWFRFUk5BTFwiO1xuRXh0ZXJuYWwucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4odGhpcy5hdXRoemlkKTtcbn07XG5cbmV4cG9ydHMuRXh0ZXJuYWwgPSBFeHRlcm5hbDtcblxuZnVuY3Rpb24gRGlnZXN0TUQ1KCkge1xuICAgIHRoaXMubm9uY2VfY291bnQgPSAwO1xuICAgIHRoaXMuY25vbmNlID0gZ2VuZXJhdGVOb25jZSgpO1xufVxudXRpbC5pbmhlcml0cyhEaWdlc3RNRDUsIE1lY2hhbmlzbSk7XG5EaWdlc3RNRDUucHJvdG90eXBlLm5hbWUgPSBcIkRJR0VTVC1NRDVcIjtcbkRpZ2VzdE1ENS5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiO1xufTtcbkRpZ2VzdE1ENS5wcm90b3R5cGUuZ2V0TkMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmp1c3QodGhpcy5ub25jZV9jb3VudC50b1N0cmluZygpLCA4LCAnMCcpO1xufTtcbkRpZ2VzdE1ENS5wcm90b3R5cGUucmVzcG9uc2VWYWx1ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlRGljdChzKTtcbiAgICBpZiAoZGljdC5yZWFsbSlcbiAgICAgICAgdGhpcy5yZWFsbSA9IGRpY3QucmVhbG07XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGRpY3Qubm9uY2UgJiYgZGljdC5xb3ApIHtcbiAgICAgICAgdGhpcy5ub25jZV9jb3VudCsrO1xuICAgICAgICB2YXIgYTEgPSBtZDUodGhpcy5hdXRoY2lkICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbG0gKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXNzd29yZCkgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgZGljdC5ub25jZSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmNub25jZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0QXMpIGExICs9IFwiOlwiICsgdGhpcy5hY3RBc1xuXG4gICAgICAgIHZhciBhMiA9IFwiQVVUSEVOVElDQVRFOlwiICsgdGhpcy5kaWdlc3RfdXJpO1xuICAgICAgICBpZiAoZGljdC5xb3AgPT0gJ2F1dGgtaW50JyB8fCBkaWN0LnFvcCA9PSAnYXV0aC1jb25mJylcbiAgICAgICAgICAgIGEyICs9IFwiOjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cbiAgICAgICAgdmFsdWUgPSBtZDVfaGV4KG1kNV9oZXgoYTEpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpY3Qubm9uY2UgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXROQygpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY25vbmNlICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpY3QucW9wICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1kNV9oZXgoYTIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuRGlnZXN0TUQ1LnByb3RvdHlwZS5jaGFsbGVuZ2UgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZURpY3Qocyk7XG4gICAgaWYgKGRpY3QucmVhbG0pXG4gICAgICAgIHRoaXMucmVhbG0gPSBkaWN0LnJlYWxtO1xuXG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIGlmIChkaWN0Lm5vbmNlICYmIGRpY3QucW9wKSB7XG4gICAgICAgIHZhciByZXNwb25zZVZhbHVlID0gdGhpcy5yZXNwb25zZVZhbHVlKHMpO1xuICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLmF1dGhjaWQsXG4gICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbSxcbiAgICAgICAgICAgIG5vbmNlOiBkaWN0Lm5vbmNlLFxuICAgICAgICAgICAgY25vbmNlOiB0aGlzLmNub25jZSxcbiAgICAgICAgICAgIG5jOiB0aGlzLmdldE5DKCksXG4gICAgICAgICAgICBxb3A6IGRpY3QucW9wLFxuICAgICAgICAgICAgJ2RpZ2VzdC11cmknOiB0aGlzLmRpZ2VzdF91cmksXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VWYWx1ZSxcbiAgICAgICAgICAgIGNoYXJzZXQ6ICd1dGYtOCdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYWN0QXMpIHJlc3BvbnNlWydhdXRoemlkJ10gPSB0aGlzLmFjdEFzXG4gICAgfSBlbHNlIGlmIChkaWN0LnJzcGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVEaWN0KHJlc3BvbnNlKTtcbn07XG5EaWdlc3RNRDUucHJvdG90eXBlLnNlcnZlckNoYWxsZW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWN0ID0ge307XG4gICAgZGljdC5yZWFsbSA9IFwiXCI7XG4gICAgdGhpcy5ub25jZSA9IGRpY3Qubm9uY2UgPSBnZW5lcmF0ZU5vbmNlKCk7XG4gICAgZGljdC5xb3AgPSBcImF1dGhcIjtcbiAgICB0aGlzLmNoYXJzZXQgPSBkaWN0LmNoYXJzZXQgPSBcInV0Zi04XCI7XG4gICAgZGljdC5hbGdvcml0aG0gPSBcIm1kNS1zZXNzXCI7XG4gICAgcmV0dXJuIGVuY29kZURpY3QoZGljdCk7XG59O1xuXG4vLyBVc2VkIG9uIHRoZSBzZXJ2ZXIgdG8gY2hlY2sgZm9yIGF1dGghXG5EaWdlc3RNRDUucHJvdG90eXBlLnJlc3BvbnNlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VEaWN0KHMpO1xuICAgIHRoaXMuYXV0aGNpZCA9IGRpY3QudXNlcm5hbWU7XG4gICAgaWYoZGljdC5ub25jZSAhPSB0aGlzLm5vbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYoIWRpY3QuY25vbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jbm9uY2UgPSBkaWN0LmNub25jZTtcbiAgICBpZih0aGlzLmNoYXJzZXQgIT0gZGljdC5jaGFyc2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZSA9IGRpY3QucmVzcG9uc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFBhcnNlIFNBU0wgc2VyaWFsaXphdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZURpY3Qocykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB3aGlsZSAocykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgaWYoKG0gPSAvXiguKz8pPSguKj9bXlxcXFxdKSwoLiopLy5leGVjKHMpKSkge1xuICAgICAgICAgICAgcmVzdWx0W21bMV1dID0gbVsyXS5yZXBsYWNlKC9cXFwiL2csICcnKTtcbiAgICAgICAgICAgIHMgPSBtWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14oLis/KT0oLis/KSwoLiopLy5leGVjKHMpKSkge1xuICAgICAgICAgICAgcmVzdWx0W21bMV1dID0gbVsyXTtcbiAgICAgICAgICAgIHMgPSBtWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14oLis/KT1cIiguKj9bXlxcXFxdKVwiJC8uZXhlYyhzKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFttWzFdXSA9IG1bMl07XG4gICAgICAgICAgICBzID0gbVszXTtcbiAgICAgICAgfSBlbHNlIGlmICgobSA9IC9eKC4rPyk9KC4rPykkLy5leGVjKHMpKSkge1xuICAgICAgICAgICAgcmVzdWx0W21bMV1dID0gbVsyXTtcbiAgICAgICAgICAgIHMgPSBtWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBTQVNMIHNlcmlhbGl6YXRpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGljdChkaWN0KSB7XG4gICAgdmFyIHMgPSBcIlwiO1xuICAgIGZvcihrIGluIGRpY3QpIHtcbiAgICAgICAgdmFyIHYgPSBkaWN0W2tdO1xuICAgICAgICBpZiAodilcbiAgICAgICAgICAgIHMgKz0gJywnICsgayArICc9XCInICsgdiArICdcIic7XG4gICAgfVxuICAgIHJldHVybiBzLnN1YnN0cigxKTsgIC8vIHdpdGhvdXQgZmlyc3QgJywnXG59XG5cbi8qKlxuICogUmlnaHQtanVzdGlmeSBhIHN0cmluZyxcbiAqIGVnLiBwYWQgd2l0aCAwc1xuICovXG5mdW5jdGlvbiByanVzdChzLCB0YXJnZXRMZW4sIHBhZGRpbmcpIHtcbiAgICB3aGlsZShzLmxlbmd0aCA8IHRhcmdldExlbilcbiAgICAgICAgcyA9IHBhZGRpbmcgKyBzO1xuICAgIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEhhc2ggYSBzdHJpbmdcbiAqL1xudmFyIG1kNSwgbWQ1X2hleDtcbmlmIChwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3NlcicpIHtcbiAgICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgbWQ1ID0gZnVuY3Rpb24ocywgZW5jb2RpbmcpIHtcblx0dmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XG5cdGhhc2gudXBkYXRlKHMpO1xuXHRyZXR1cm4gaGFzaC5kaWdlc3QoZW5jb2RpbmcgfHwgJ2JpbmFyeScpO1xuICAgIH07XG4gICAgbWQ1X2hleCA9IGZ1bmN0aW9uKHMpIHtcblx0cmV0dXJuIG1kNShzLCAnaGV4Jyk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgdmFyIG1kNWxpYiA9IHJlcXVpcmUoJ2JsdWVpbXAtbWQ1JykubWQ1O1xuICAgIGNvbnNvbGUubG9nKFwibWQ1bGliXCIsbWQ1bGliKTtcbiAgICBtZDUgPSBmdW5jdGlvbihzKSB7XG5cdGNvbnNvbGUubG9nKFwibWQ1XCIsIHMsIG1kNWxpYihzLCBudWxsLCB0cnVlKSk7XG5cdHJldHVybiBtZDVsaWIocywgbnVsbCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBtZDVfaGV4ID0gZnVuY3Rpb24ocykge1xuXHRjb25zb2xlLmxvZyhcIm1kNV9oZXhcIiwgcywgbWQ1bGliKHMpKTtcblx0cmV0dXJuIG1kNWxpYihzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIG9mIDggZGlnaXRzXG4gKiAobnVtYmVyIHVzZWQgb25jZSlcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVOb25jZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg0OCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogMTApKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLy8gTG9hZCBtb2R1bGVzXHJcblxyXG52YXIgQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbnZhciBVcmwgPSByZXF1aXJlKCd1cmwnKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuXHJcbi8vIERlY2xhcmUgaW50ZXJuYWxzXHJcblxyXG52YXIgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxuLy8gTUFDIG5vcm1hbGl6YXRpb24gZm9ybWF0IHZlcnNpb25cclxuXHJcbmV4cG9ydHMuaGVhZGVyVmVyc2lvbiA9ICcxJzsgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGNvbXBhcmlzb24gb2YgbWFjIHZhbHVlcyBnZW5lcmF0ZWQgd2l0aCBkaWZmZXJlbnQgbm9ybWFsaXplZCBzdHJpbmcgZm9ybWF0c1xyXG5cclxuXHJcbi8vIFN1cHBvcnRlZCBITUFDIGFsZ29yaXRobXNcclxuXHJcbmV4cG9ydHMuYWxnb3JpdGhtcyA9IFsnc2hhMScsICdzaGEyNTYnXTtcclxuXHJcblxyXG4vLyBDYWxjdWxhdGUgdGhlIHJlcXVlc3QgTUFDXHJcblxyXG4vKlxyXG4gICAgdHlwZTogJ2hlYWRlcicsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2hlYWRlcicsICdiZXdpdCcsICdyZXNwb25zZSdcclxuICAgIGNyZWRlbnRpYWxzOiB7XHJcbiAgICAgICAga2V5OiAnYW9pamVkb2FpanNkbGFrc2pkbCcsXHJcbiAgICAgICAgYWxnb3JpdGhtOiAnc2hhMjU2JyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc2hhMScsICdzaGEyNTYnXHJcbiAgICB9LFxyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgcmVzb3VyY2U6ICcvcmVzb3VyY2U/YT0xJmI9MicsXHJcbiAgICAgICAgaG9zdDogJ2V4YW1wbGUuY29tJyxcclxuICAgICAgICBwb3J0OiA4MDgwLFxyXG4gICAgICAgIHRzOiAxMzU3NzE4MzgxMDM0LFxyXG4gICAgICAgIG5vbmNlOiAnZDNkMzQ1ZicsXHJcbiAgICAgICAgaGFzaDogJ1U0TUtLU21pVnhrMzdKQ0NyQVZJalYvT2hCM3krTmR3b0NyNlJTaGJWa0U9JyxcclxuICAgICAgICBleHQ6ICdhcHAtc3BlY2lmaWMtZGF0YScsXHJcbiAgICAgICAgYXBwOiAnaGY0OGhkODNxd2tqJywgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsaWNhdGlvbiBpZCAoT3opXHJcbiAgICAgICAgZGxnOiAnZDhkandla2RzOWNqJyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxlZ2F0ZWQgYnkgYXBwbGljYXRpb24gaWQgKE96KSwgcmVxdWlyZXMgb3B0aW9ucy5hcHBcclxuICAgIH1cclxuKi9cclxuXHJcbmV4cG9ydHMuY2FsY3VsYXRlTWFjID0gZnVuY3Rpb24gKHR5cGUsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBleHBvcnRzLmdlbmVyYXRlTm9ybWFsaXplZFN0cmluZyh0eXBlLCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgaG1hYyA9IENyeXB0by5jcmVhdGVIbWFjKGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY3JlZGVudGlhbHMua2V5KS51cGRhdGUobm9ybWFsaXplZCk7XHJcbiAgICB2YXIgZGlnZXN0ID0gaG1hYy5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG4gICAgcmV0dXJuIGRpZ2VzdDtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmdlbmVyYXRlTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSAnaGF3ay4nICsgZXhwb3J0cy5oZWFkZXJWZXJzaW9uICsgJy4nICsgdHlwZSArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50cyArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ub25jZSArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNvdXJjZSArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ob3N0LnRvTG93ZXJDYXNlKCkgKyAnXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucG9ydCArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuaGFzaCB8fCAnJykgKyAnXFxuJztcclxuXHJcbiAgICBpZiAob3B0aW9ucy5leHQpIHtcclxuICAgICAgICBub3JtYWxpemVkICs9IG9wdGlvbnMuZXh0LnJlcGxhY2UoJ1xcXFwnLCAnXFxcXFxcXFwnKS5yZXBsYWNlKCdcXG4nLCAnXFxcXG4nKTtcclxuICAgIH1cclxuXHJcbiAgICBub3JtYWxpemVkICs9ICdcXG4nO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmFwcCkge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQgKz0gb3B0aW9ucy5hcHAgKyAnXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5kbGcgfHwgJycpICsgJ1xcbic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5jYWxjdWxhdGVQYXlsb2FkSGFzaCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBhbGdvcml0aG0sIGNvbnRlbnRUeXBlKSB7XHJcblxyXG4gICAgdmFyIGhhc2ggPSBleHBvcnRzLmluaXRpYWxpemVQYXlsb2FkSGFzaChhbGdvcml0aG0sIGNvbnRlbnRUeXBlKTtcclxuICAgIGhhc2gudXBkYXRlKHBheWxvYWQgfHwgJycpO1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuZmluYWxpemVQYXlsb2FkSGFzaChoYXNoKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmluaXRpYWxpemVQYXlsb2FkSGFzaCA9IGZ1bmN0aW9uIChhbGdvcml0aG0sIGNvbnRlbnRUeXBlKSB7XHJcblxyXG4gICAgdmFyIGhhc2ggPSBDcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pO1xyXG4gICAgaGFzaC51cGRhdGUoJ2hhd2suJyArIGV4cG9ydHMuaGVhZGVyVmVyc2lvbiArICcucGF5bG9hZFxcbicpO1xyXG4gICAgaGFzaC51cGRhdGUoVXRpbHMucGFyc2VDb250ZW50VHlwZShjb250ZW50VHlwZSkgKyAnXFxuJyk7XHJcbiAgICByZXR1cm4gaGFzaDtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmZpbmFsaXplUGF5bG9hZEhhc2ggPSBmdW5jdGlvbiAoaGFzaCkge1xyXG5cclxuICAgIGhhc2gudXBkYXRlKCdcXG4nKTtcclxuICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jyk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5jYWxjdWxhdGVUc01hYyA9IGZ1bmN0aW9uICh0cywgY3JlZGVudGlhbHMpIHtcclxuXHJcbiAgICB2YXIgaG1hYyA9IENyeXB0by5jcmVhdGVIbWFjKGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY3JlZGVudGlhbHMua2V5KTtcclxuICAgIGhtYWMudXBkYXRlKCdoYXdrLicgKyBleHBvcnRzLmhlYWRlclZlcnNpb24gKyAnLnRzXFxuJyArIHRzICsgJ1xcbicpO1xyXG4gICAgcmV0dXJuIGhtYWMuZGlnZXN0KCdiYXNlNjQnKTtcclxufTtcclxuXHJcbiIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gQ29weXJpZ2h0IChjKSAyMDEyLCBNYXJrIENhdmFnZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIE5ERUJVRyA9IHByb2Nlc3MuZW52Lk5PREVfTkRFQlVHIHx8IGZhbHNlO1xuXG5cblxuLy8vLS0tIE1lc3NhZ2VzXG5cbnZhciBBUlJBWV9UWVBFX1JFUVVJUkVEID0gJyVzIChbJXNdKSByZXF1aXJlZCc7XG52YXIgVFlQRV9SRVFVSVJFRCA9ICclcyAoJXMpIGlzIHJlcXVpcmVkJztcblxuXG5cbi8vLy0tLSBJbnRlcm5hbFxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gKHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIHVuY2FwaXRhbGl6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIChzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xufVxuXG5mdW5jdGlvbiBfKCkge1xuICAgICAgICByZXR1cm4gKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykpO1xufVxuXG5cbmZ1bmN0aW9uIF9hc3NlcnQoYXJnLCB0eXBlLCBuYW1lLCBzdGFja0Z1bmMpIHtcbiAgICAgICAgaWYgKCFOREVCVUcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIHN0YWNrRnVuYyA9IHN0YWNrRnVuYyB8fCBfYXNzZXJ0LmNhbGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHR5cGVvZiAoYXJnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhUWVBFX1JFUVVJUkVELCBuYW1lLCB0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9PT0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrRnVuY1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG59XG5cblxuXG4vLy8tLS0gQVBJXG5cbmZ1bmN0aW9uIGFycmF5KGFyciwgdHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAoIU5ERUJVRykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8oQVJSQVlfVFlQRV9SRVFVSVJFRCwgbmFtZSwgdHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIChhcnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdBcnJheS5pc0FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBhcnJheS5jYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGFycltpXSwgdHlwZSwgbmFtZSwgYXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuXG5cbmZ1bmN0aW9uIGJvb2woYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnYm9vbGVhbicsIG5hbWUsIGJvb2wpO1xufVxuXG5cbmZ1bmN0aW9uIGJ1ZmZlcihhcmcsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhUWVBFX1JFUVVJUkVELCBuYW1lLCB0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIChhcmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdidWZmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdCdWZmZXIuaXNCdWZmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBidWZmZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxufVxuXG5cbmZ1bmN0aW9uIGZ1bmMoYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnZnVuY3Rpb24nLCBuYW1lKTtcbn1cblxuXG5mdW5jdGlvbiBudW1iZXIoYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnbnVtYmVyJywgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gb2JqZWN0KGFyZywgbmFtZSkge1xuICAgICAgICBfYXNzZXJ0KGFyZywgJ29iamVjdCcsIG5hbWUpO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmVhbShhcmcsIG5hbWUpIHtcbiAgICAgICAgaWYgKCEoYXJnIGluc3RhbmNlb2YgU3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhUWVBFX1JFUVVJUkVELCBuYW1lLCB0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIChhcmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdTdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdpbnN0YW5jZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogYnVmZmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbn1cblxuXG5mdW5jdGlvbiBzdHJpbmcoYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnc3RyaW5nJywgbmFtZSk7XG59XG5cblxuXG4vLy8tLS0gRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgYm9vbDogYm9vbCxcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG59O1xuXG5cbk9iamVjdC5rZXlzKG1vZHVsZS5leHBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrID09PSAnYnVmZmVyJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG5hbWUgPSAnYXJyYXlPZicgKyBjYXBpdGFsaXplKGspO1xuXG4gICAgICAgIGlmIChrID09PSAnYm9vbCcpXG4gICAgICAgICAgICAgICAgayA9ICdib29sZWFuJztcbiAgICAgICAgaWYgKGsgPT09ICdmdW5jJylcbiAgICAgICAgICAgICAgICBrID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkoYXJnLCBrLCBuYW1lKTtcbiAgICAgICAgfTtcbn0pO1xuXG5PYmplY3Qua2V5cyhtb2R1bGUuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgX25hbWUgPSAnb3B0aW9uYWwnICsgY2FwaXRhbGl6ZShrKTtcbiAgICAgICAgdmFyIHMgPSB1bmNhcGl0YWxpemUoay5yZXBsYWNlKCdhcnJheU9mJywgJycpKTtcbiAgICAgICAgaWYgKHMgPT09ICdib29sJylcbiAgICAgICAgICAgICAgICBzID0gJ2Jvb2xlYW4nO1xuICAgICAgICBpZiAocyA9PT0gJ2Z1bmMnKVxuICAgICAgICAgICAgICAgIHMgPSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIGlmIChrLmluZGV4T2YoJ2FycmF5T2YnKSAhPT0gLTEpIHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0c1tfbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIU5ERUJVRyAmJiBhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheShhcmcsIHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHNbX25hbWVdID0gZnVuY3Rpb24gKGFyZywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFOREVCVUcgJiYgYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2Fzc2VydChhcmcsIHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbn0pO1xuXG5cbi8vIFJlZXhwb3J0IGJ1aWx0LWluIGFzc2VydGlvbnNcbk9iamVjdC5rZXlzKGFzc2VydCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayA9PT0gJ0Fzc2VydGlvbkVycm9yJykge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gYXNzZXJ0W2tdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghTkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRba10uYXBwbHkoYXNzZXJ0W2tdLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn0pO1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIi8vIEV4cG9ydCBzdWItbW9kdWxlc1xyXG5cclxuZXhwb3J0cy5lcnJvciA9IGV4cG9ydHMuRXJyb3IgPSByZXF1aXJlKCdib29tJyk7XHJcbmV4cG9ydHMuc250cCA9IHJlcXVpcmUoJ3NudHAnKTtcclxuZXhwb3J0cy5zZXJ2ZXIgPSByZXF1aXJlKCcuL3NlcnZlcicpO1xyXG5leHBvcnRzLmNsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50Jyk7XHJcbmV4cG9ydHMuY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcclxuZXhwb3J0cy51dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbmV4cG9ydHMudXJpID0ge1xyXG4gICAgYXV0aGVudGljYXRlOiBleHBvcnRzLnNlcnZlci5hdXRoZW50aWNhdGVCZXdpdCxcclxuICAgIGdldEJld2l0OiBleHBvcnRzLmNsaWVudC5nZXRCZXdpdFxyXG59O1xyXG5cclxuXHJcbiIsIihmdW5jdGlvbigpey8qXG4gKiBKYXZhU2NyaXB0IE1ENSAxLjAuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKiBcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuLypnbG9iYWwgdW5lc2NhcGUsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCQpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKlxuICAgICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICAgICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpIHtcbiAgICAgICAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKSxcbiAgICAgICAgICAgIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAgICAgICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICAgICovXG4gICAgZnVuY3Rpb24gYml0X3JvbChudW0sIGNudCkge1xuICAgICAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksIGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICAgICovXG4gICAgZnVuY3Rpb24gYmlubF9tZDUoeCwgbGVuKSB7XG4gICAgICAgIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gICAgICAgIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKGxlbiAlIDMyKTtcbiAgICAgICAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gICAgICAgIHZhciBpLCBvbGRhLCBvbGRiLCBvbGRjLCBvbGRkLFxuICAgICAgICAgICAgYSA9ICAxNzMyNTg0MTkzLFxuICAgICAgICAgICAgYiA9IC0yNzE3MzM4NzksXG4gICAgICAgICAgICBjID0gLTE3MzI1ODQxOTQsXG4gICAgICAgICAgICBkID0gIDI3MTczMzg3ODtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIG9sZGEgPSBhO1xuICAgICAgICAgICAgb2xkYiA9IGI7XG4gICAgICAgICAgICBvbGRjID0gYztcbiAgICAgICAgICAgIG9sZGQgPSBkO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaV0sICAgICAgIDcsIC02ODA4NzY5MzYpO1xuICAgICAgICAgICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyAgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICAgICAgICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgICAgICAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArICAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpICsgIDRdLCAgNywgLTE3NjQxODg5Nyk7XG4gICAgICAgICAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICAgICAgICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgICAgICAgICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyAgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgICAgICAgICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAgOF0sICA3LCAgMTc3MDAzNTQxNik7XG4gICAgICAgICAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICAgICAgICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICAgICAgICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgICAgICAgICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sICA3LCAgMTgwNDYwMzY4Mik7XG4gICAgICAgICAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgICAgICAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICAgICAgICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArICAxXSwgIDUsIC0xNjU3OTY1MTApO1xuICAgICAgICAgICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAgNl0sICA5LCAtMTA2OTUwMTYzMik7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgICAgICAgICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2ldLCAgICAgIDIwLCAtMzczODk3MzAyKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDVdLCAgNSwgLTcwMTU1ODY5MSk7XG4gICAgICAgICAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgIDksICAzODAxNjA4Myk7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgICAgICAgICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2kgKyAgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICAgICAgICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDldLCAgNSwgIDU2ODQ0NjQzOCk7XG4gICAgICAgICAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgIDksIC0xMDE5ODAzNjkwKTtcbiAgICAgICAgICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgICAgICAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArICA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICAgICAgICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCAgNSwgLTE0NDQ2ODE0NjcpO1xuICAgICAgICAgICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAgMl0sICA5LCAtNTE0MDM3ODQpO1xuICAgICAgICAgICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyAgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgICAgICAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgICAgICAgICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAgNV0sICA0LCAtMzc4NTU4KTtcbiAgICAgICAgICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgICAgICAgICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgICAgICAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgICAgICAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArICAxXSwgIDQsIC0xNTMwOTkyMDYwKTtcbiAgICAgICAgICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgICAgICAgICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICAgICAgICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgICAgICAgICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sICA0LCAgNjgxMjc5MTc0KTtcbiAgICAgICAgICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpXSwgICAgICAxMSwgLTM1ODUzNzIyMik7XG4gICAgICAgICAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArICAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgICAgICAgICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAgOV0sICA0LCAtNjQwMzY0NDg3KTtcbiAgICAgICAgICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgICAgICAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgICAgICAgICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2ldLCAgICAgICA2LCAtMTk4NjMwODQ0KTtcbiAgICAgICAgICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgICAgICAgICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgICAgICAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArICA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgICAgICAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgIDYsICAxNzAwNDg1NTcxKTtcbiAgICAgICAgICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgICAgICAgICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgICAgICAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArICAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgIDhdLCAgNiwgIDE4NzMzMTMzNTkpO1xuICAgICAgICAgICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgICAgICAgICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgICAgICAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgIDRdLCAgNiwgLTE0NTUyMzA3MCk7XG4gICAgICAgICAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICAgICAgICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgICAgICAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArICA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgICAgICAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgICAgICAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgICAgICAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgICAgICAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gICAgKi9cbiAgICBmdW5jdGlvbiBiaW5sMnJzdHIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXRwdXQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAgKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICBvdXRwdXRbKGlucHV0Lmxlbmd0aCA+PiAyKSAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiA4OyBpICs9IDgpIHtcbiAgICAgICAgICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4RkYpIDw8IChpICUgMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGEgcmF3IHN0cmluZ1xuICAgICovXG4gICAgZnVuY3Rpb24gcnN0cl9tZDUocykge1xuICAgICAgICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICAgICovXG4gICAgZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBia2V5ID0gcnN0cjJiaW5sKGtleSksXG4gICAgICAgICAgICBpcGFkID0gW10sXG4gICAgICAgICAgICBvcGFkID0gW10sXG4gICAgICAgICAgICBoYXNoO1xuICAgICAgICBpcGFkWzE1XSA9IG9wYWRbMTVdID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYmtleS5sZW5ndGggPiAxNikge1xuICAgICAgICAgICAgYmtleSA9IGJpbmxfbWQ1KGJrZXksIGtleS5sZW5ndGggKiA4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgICAgICAgICAgb3BhZFtpXSA9IGJrZXlbaV0gXiAweDVDNUM1QzVDO1xuICAgICAgICB9XG4gICAgICAgIGhhc2ggPSBiaW5sX21kNShpcGFkLmNvbmNhdChyc3RyMmJpbmwoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xuICAgICAgICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxMjgpKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gICAgKi9cbiAgICBmdW5jdGlvbiByc3RyMmhleChpbnB1dCkge1xuICAgICAgICB2YXIgaGV4X3RhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJyxcbiAgICAgICAgICAgIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaGV4X3RhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwRikgK1xuICAgICAgICAgICAgICAgIGhleF90YWIuY2hhckF0KHggJiAweDBGKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLThcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBUYWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgcmF3IG9yIGhleCBlbmNvZGVkIHN0cmluZ3NcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJhd19tZDUocykge1xuICAgICAgICByZXR1cm4gcnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhleF9tZDUocykge1xuICAgICAgICByZXR1cm4gcnN0cjJoZXgocmF3X21kNShzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhd19obWFjX21kNShrLCBkKSB7XG4gICAgICAgIHJldHVybiByc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZCkge1xuICAgICAgICByZXR1cm4gcnN0cjJoZXgocmF3X2htYWNfbWQ1KGssIGQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZDUoc3RyaW5nLCBrZXksIHJhdykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgaWYgKCFyYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4X21kNShzdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhd19tZDUoc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGhleF9obWFjX21kNShrZXksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhd19obWFjX21kNShrZXksIHN0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1kNTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJC5tZDUgPSBtZDU7XG4gICAgfVxufSh0aGlzKSk7XG5cbn0pKCkiLCJ2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZXhwb3J0cy5hdmFpbGFibGVTYXhQYXJzZXJzID0gW107XG5leHBvcnRzLmJlc3RTYXhQYXJzZXIgPSBudWxsO1xuWycuL3NheF9leHBhdC5qcycsICcuL3NheF9sdHguanMnLCAvKicuL3NheF9lYXN5c2F4LmpzJywgJy4vc2F4X25vZGUteG1sLmpzJywqLyAnLi9zYXhfc2F4anMuanMnXS5mb3JFYWNoKGZ1bmN0aW9uKG1vZE5hbWUpIHtcbiAgICB2YXIgbW9kO1xuICAgIHRyeSB7XG5cdG1vZCA9IHJlcXVpcmUobW9kTmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuXHQvKiBTaWxlbnRseSBtaXNzaW5nIGxpYnJhcmllcyBkcm9wOyBmb3IgZGVidWc6XG5cdGNvbnNvbGUuZXJyb3IoZS5zdGFjayB8fCBlKTtcblx0ICovXG4gICAgfVxuICAgIGlmIChtb2QpIHtcblx0ZXhwb3J0cy5hdmFpbGFibGVTYXhQYXJzZXJzLnB1c2gobW9kKTtcblx0aWYgKCFleHBvcnRzLmJlc3RTYXhQYXJzZXIpXG5cdCAgICBleHBvcnRzLmJlc3RTYXhQYXJzZXIgPSBtb2Q7XG4gICAgfVxufSk7XG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4vZWxlbWVudCcpO1xuXG5leHBvcnRzLlBhcnNlciA9IGZ1bmN0aW9uKHNheFBhcnNlcikge1xuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB2YXIgcGFyc2VyTW9kID0gc2F4UGFyc2VyIHx8IGV4cG9ydHMuYmVzdFNheFBhcnNlcjtcbiAgICBpZiAoIXBhcnNlck1vZClcblx0dGhyb3cgbmV3IEVycm9yKFwiTm8gU0FYIHBhcnNlciBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgcGFyc2VyTW9kKCk7XG5cbiAgICB2YXIgZWw7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ3N0YXJ0RWxlbWVudCcsIGZ1bmN0aW9uKG5hbWUsIGF0dHJzKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ldyBlbGVtZW50LkVsZW1lbnQobmFtZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBlbCA9IGNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwgPSBlbC5jbm9kZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignZW5kRWxlbWVudCcsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgLyogRXJyICovXG4gICAgICAgIH0gZWxzZSBpZiAoZWwgJiYgbmFtZSA9PSBlbC5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50KVxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50O1xuICAgICAgICAgICAgZWxzZSBpZiAoIXRoYXQudHJlZSkge1xuICAgICAgICAgICAgICAgIHRoYXQudHJlZSA9IGVsO1xuICAgICAgICAgICAgICAgIGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ3RleHQnLCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgaWYgKGVsKVxuICAgICAgICAgICAgZWwudChzdHIpO1xuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcblx0dGhhdC5lcnJvciA9IGU7XG5cdHRoYXQuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KTtcbn07XG51dGlsLmluaGVyaXRzKGV4cG9ydHMuUGFyc2VyLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuZXhwb3J0cy5QYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMucGFyc2VyLndyaXRlKGRhdGEpO1xufTtcblxuZXhwb3J0cy5QYXJzZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLnBhcnNlci5lbmQoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMuZXJyb3IpIHtcblx0aWYgKHRoaXMudHJlZSlcblx0ICAgIHRoaXMuZW1pdCgndHJlZScsIHRoaXMudHJlZSk7XG5cdGVsc2Vcblx0ICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0luY29tcGxldGUgZG9jdW1lbnQnKSk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIHNheFBhcnNlcikge1xuICAgIHZhciBwID0gbmV3IGV4cG9ydHMuUGFyc2VyKHNheFBhcnNlcik7XG4gICAgdmFyIHJlc3VsdCA9IG51bGwsIGVycm9yID0gbnVsbDtcblxuICAgIHAub24oJ3RyZWUnLCBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJlc3VsdCA9IHRyZWU7XG4gICAgfSk7XG4gICAgcC5vbignZXJyb3InLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICB9KTtcblxuICAgIHAud3JpdGUoZGF0YSk7XG4gICAgcC5lbmQoKTtcblxuICAgIGlmIChlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIihmdW5jdGlvbihCdWZmZXIpey8qXG4gKiBybSAtIEZlYiAyMDExXG4gKiBjdHlwZS5qc1xuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgc2ltcGxlIGFic3RyYWN0aW9uIHRvd2FyZHMgcmVhZGluZyBhbmQgd3JpdGluZ1xuICogZGlmZmVyZW50IHR5cGVzIG9mIGJpbmFyeSBkYXRhLiBJdCBpcyBkZXNpZ25lZCB0byB1c2UgY3Rpby5qcyBhbmQgcHJvdmlkZSBhXG4gKiByaWNoZXIgYW5kIG1vcmUgZXhwcmVzc2l2ZSBBUEkgb24gdG9wIG9mIGl0LlxuICpcbiAqIEJ5IGRlZmF1bHQgd2Ugc3VwcG9ydCB0aGUgZm9sbG93aW5nIGFzIGJ1aWx0IGluIGJhc2ljIHR5cGVzOlxuICpcdGludDhfdFxuICpcdGludDE2X3RcbiAqXHRpbnQzMl90XG4gKlx0dWludDhfdFxuICpcdHVpbnQxNl90XG4gKlx0dWludDMyX3RcbiAqXHR1aW50NjRfdFxuICpcdGZsb2F0XG4gKlx0ZG91YmxlXG4gKlx0Y2hhclxuICpcdGNoYXJbXVxuICpcbiAqIEVhY2ggdHlwZSBpcyByZXR1cm5lZCBhcyBhIE51bWJlciwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNoYXIgYW5kIGNoYXJbXVxuICogd2hpY2ggYXJlIHJldHVybmVkIGFzIE5vZGUgQnVmZmVycy4gQSBjaGFyIGlzIGNvbnNpZGVyZWQgYSB1aW50OF90LlxuICpcbiAqIFJlcXVlc3RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgYXJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBKU09OIG9iamVjdHMuXG4gKiBUaGlzIGlzIGFsc28gdGhlIHNhbWUgd2F5IHRoYXQgb25lIGRlY2xhcmVzIHN0cnVjdHMuIEV2ZW4gaWYganVzdCBhIHNpbmdsZVxuICogdmFsdWUgaXMgcmVxdWVzdGVkLCBpdCBtdXN0IGJlIGRvbmUgYXMgYSBzdHJ1Y3QuIFRoZSBhcnJheSBvcmRlciBkZXRlcm1pbmVzXG4gKiB0aGUgb3JkZXIgdGhhdCB3ZSB0cnkgYW5kIHJlYWQgdmFsdWVzLiBFYWNoIGVudHJ5IGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdFxuICogd2l0aCB2YWx1ZXMgbWFya2VkIHdpdGggYSAqIGJlaW5nIG9wdGlvbmFsLlxuICpcbiAqIHsga2V5OiB7IHR5cGU6IC90eXBlLywgdmFsdWUqOiAvdmFsdWUvLCBvZmZzZXQqOiAvb2Zmc2V0LyB9XG4gKlxuICogSWYgb2Zmc2V0IGlzIGRlZmluZWQsIHdlIGxzZWVrKG9mZnNldCwgU0VFS19TRVQpIGJlZm9yZSByZWFkaW5nIHRoZSBuZXh0XG4gKiB2YWx1ZS4gVmFsdWUgaXMgZGVmaW5lZCB3aGVuIHdlJ3JlIHdyaXRpbmcgb3V0IGRhdGEsIG90aGVyd2lzZSBpdCdzIGlnbm9yZWQuXG4gKlxuICovXG5cbnZhciBtb2RfY3RmID0gcmVxdWlyZSgnLi9jdGYuanMnKTtcbnZhciBtb2RfY3RpbyA9IHJlcXVpcmUoJy4vY3Rpby5qcycpO1xudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLypcbiAqIFRoaXMgaXMgdGhlIHNldCBvZiBiYXNpYyB0eXBlcyB0aGF0IHdlIHN1cHBvcnQuXG4gKlxuICpcdHJlYWRcdFx0VGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcmVhZCBpbiBhIHZhbHVlIGZyb20gYSBidWZmZXJcbiAqXG4gKlx0d3JpdGVcdFx0VGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gd3JpdGUgYSB2YWx1ZSB0byBhIGJ1ZmZlclxuICpcbiAqL1xudmFyIGRlZnR5cGVzID0ge1xuICAgICd1aW50OF90JzogIHsgcmVhZDogY3RSZWFkVWludDgsIHdyaXRlOiBjdFdyaXRlVWludDggfSxcbiAgICAndWludDE2X3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQxNiwgd3JpdGU6IGN0V3JpdGVVaW50MTYgfSxcbiAgICAndWludDMyX3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQzMiwgd3JpdGU6IGN0V3JpdGVVaW50MzIgfSxcbiAgICAndWludDY0X3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQ2NCwgd3JpdGU6IGN0V3JpdGVVaW50NjQgfSxcbiAgICAnaW50OF90JzogeyByZWFkOiBjdFJlYWRTaW50OCwgd3JpdGU6IGN0V3JpdGVTaW50OCB9LFxuICAgICdpbnQxNl90JzogeyByZWFkOiBjdFJlYWRTaW50MTYsIHdyaXRlOiBjdFdyaXRlU2ludDE2IH0sXG4gICAgJ2ludDMyX3QnOiB7IHJlYWQ6IGN0UmVhZFNpbnQzMiwgd3JpdGU6IGN0V3JpdGVTaW50MzIgfSxcbiAgICAnaW50NjRfdCc6IHsgcmVhZDogY3RSZWFkU2ludDY0LCB3cml0ZTogY3RXcml0ZVNpbnQ2NCB9LFxuICAgICdmbG9hdCc6IHsgcmVhZDogY3RSZWFkRmxvYXQsIHdyaXRlOiBjdFdyaXRlRmxvYXQgfSxcbiAgICAnZG91YmxlJzogeyByZWFkOiBjdFJlYWREb3VibGUsIHdyaXRlOiBjdFdyaXRlRG91YmxlIH0sXG4gICAgJ2NoYXInOiB7IHJlYWQ6IGN0UmVhZENoYXIsIHdyaXRlOiBjdFdyaXRlQ2hhciB9LFxuICAgICdjaGFyW10nOiB7IHJlYWQ6IGN0UmVhZENoYXJBcnJheSwgd3JpdGU6IGN0V3JpdGVDaGFyQXJyYXkgfVxufTtcblxuLypcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIHdyYXBwZXJzIGFyb3VuZCB0aGUgQ1R5cGUgSU8gbG93IGxldmVsIEFQSS4gVGhleSBlbmNvZGVcbiAqIGtub3dsZWRnZSBhYm91dCB0aGUgc2l6ZSBhbmQgcmV0dXJuIHNvbWV0aGluZyBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjdFJlYWRVaW50OChlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnVpbnQ4KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMSB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDE2KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMiB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDMyKGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogNCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDY0KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogOCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkU2ludDgoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJzaW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDEgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQxNihlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDIgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQzMihlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDQgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQ2NChlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDggfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZEZsb2F0KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5yZmxvYXQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA0IH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWREb3VibGUoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJkb3VibGUoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA4IH0pO1xufVxuXG4vKlxuICogUmVhZHMgYSBzaW5nbGUgY2hhcmFjdGVyIGludG8gYSBub2RlIGJ1ZmZlclxuICovXG5mdW5jdGlvbiBjdFJlYWRDaGFyKGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciByZXMgPSBuZXcgQnVmZmVyKDEpO1xuXHRyZXNbMF0gPSBtb2RfY3Rpby5ydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogcmVzLCBzaXplOiAxIH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRDaGFyQXJyYXkobGVuZ3RoLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWk7XG5cdHZhciByZXMgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKVxuXHRcdHJlc1tpaV0gPSBtb2RfY3Rpby5ydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCArIGlpKTtcblxuXHRyZXR1cm4gKHsgdmFsdWU6IHJlcywgc2l6ZTogbGVuZ3RoIH0pO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlVWludDgodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLnd1aW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMSk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVVaW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLnd1aW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDIpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlVWludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53dWludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg0KTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVVpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3VpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoOCk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVTaW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3NpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICgxKTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVNpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3NpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMik7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVTaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLndzaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDQpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlU2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53c2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg4KTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZUZsb2F0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53ZmxvYXQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDQpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlRG91YmxlKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53ZG91YmxlKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg4KTtcbn1cblxuLypcbiAqIFdyaXRlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgaW50byBhIG5vZGUgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIGN0V3JpdGVDaGFyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpKTtcblxuXHRtb2RfY3Rpby5ydWludDgodmFsdWVbMF0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDEpO1xufVxuXG4vKlxuICogV2UncmUgZ29pbmcgdG8gd3JpdGUgMHMgaW50byB0aGUgYnVmZmVyIGlmIHRoZSBzdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY3RXcml0ZUNoYXJBcnJheSh2YWx1ZSwgbGVuZ3RoLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWk7XG5cblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBidWZmZXInKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBsZW5ndGggZ3JlYXRlciB0aGFuIGFycmF5IGxlbmd0aCcpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCB2YWx1ZS5sZW5ndGggJiYgaWkgPCBsZW5ndGg7IGlpKyspXG5cdFx0bW9kX2N0aW8ud3VpbnQ4KHZhbHVlW2lpXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCArIGlpKTtcblxuXHRmb3IgKDsgaWkgPCBsZW5ndGg7IGlpKyspXG5cdFx0bW9kX2N0aW8ud3VpbnQ4KDAsIGVuZGlhbiwgb2Zmc2V0ICsgaWkpO1xuXG5cblx0cmV0dXJuIChsZW5ndGgpO1xufVxuXG4vKlxuICogRWFjaCBwYXJzZXIgaGFzIHRoZWlyIG93biBzZXQgb2YgdHlwZXMuIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhleSBlYWNoXG4gKiBnZXQgdGhlaXIgb3duIGNvcHkgYXMgdGhleSBtYXkgbmVlZCB0byBtb2RpZnkgaXQuXG4gKi9cbmZ1bmN0aW9uIGN0R2V0QmFzaWNUeXBlcygpXG57XG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gZGVmdHlwZXMpXG5cdFx0cmV0W2tleV0gPSBkZWZ0eXBlc1trZXldO1xuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIEdpdmVuIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIHR5cGVbbGVuZ3RoXSB3ZSB3YW50IHRvIHNwbGl0IHRoaXMgaW50byBhblxuICogb2JqZWN0IHRoYXQgZXh0cmFjdHMgdGhhdCBpbmZvcm1hdGlvbi4gV2Ugd2FudCB0byBub3RlIHRoYXQgd2UgY291bGQgcG9zc2libHlcbiAqIGhhdmUgbmVzdGVkIGFycmF5cyBzbyB0aGlzIHNob3VsZCBvbmx5IGNoZWNrIHRoZSBmdXJ0aGVzdCBvbmUuIEl0IG1heSBhbHNvIGJlXG4gKiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgbm8gW10gcGllY2VzLCBpbiB3aGljaCBjYXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiB0eXBlLlxuICovXG5mdW5jdGlvbiBjdFBhcnNlVHlwZShzdHIpXG57XG5cdHZhciBiZWdJbmQsIGVuZEluZDtcblx0dmFyIHR5cGUsIGxlbjtcblx0aWYgKHR5cGVvZiAoc3RyKSAhPSAnc3RyaW5nJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlIG11c3QgYmUgYSBKYXZhc2NyaXB0IHN0cmluZycpKTtcblxuXHRlbmRJbmQgPSBzdHIubGFzdEluZGV4T2YoJ10nKTtcblx0aWYgKGVuZEluZCA9PSAtMSkge1xuXHRcdGlmIChzdHIubGFzdEluZGV4T2YoJ1snKSAhPSAtMSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2ZvdW5kIGludmFsaWQgdHlwZSB3aXRoIFxcJ1tcXCcgYnV0ICcgK1xuXHRcdFx0ICAgICdubyBjb3JyZXNwb25kaW5nIFxcJ11cXCcnKSk7XG5cblx0XHRyZXR1cm4gKHsgdHlwZTogc3RyIH0pO1xuXHR9XG5cblx0YmVnSW5kID0gc3RyLmxhc3RJbmRleE9mKCdbJyk7XG5cdGlmIChiZWdJbmQgPT0gLTEpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignZm91bmQgaW52YWxpZCB0eXBlIHdpdGggXFwnXVxcJyBidXQgJyArXG5cdFx0ICAgICdubyBjb3JyZXNwb25kaW5nIFxcJ1tcXCcnKSk7XG5cblx0aWYgKGJlZ0luZCA+PSBlbmRJbmQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWFsZm9ybWVkIHR5cGUsIFxcJ11cXCcgYXBwZWFycyBiZWZvcmUgXFwnW1xcJycpKTtcblxuXHR0eXBlID0gc3RyLnN1YnN0cmluZygwLCBiZWdJbmQpO1xuXHRsZW4gPSBzdHIuc3Vic3RyaW5nKGJlZ0luZCArIDEsIGVuZEluZCk7XG5cblx0cmV0dXJuICh7IHR5cGU6IHR5cGUsIGxlbjogbGVuIH0pO1xufVxuXG4vKlxuICogR2l2ZW4gYSByZXF1ZXN0IHZhbGlkYXRlIHRoYXQgYWxsIG9mIHRoZSBmaWVsZHMgZm9yIGl0IGFyZSB2YWxpZCBhbmQgbWFrZVxuICogc2Vuc2UuIFRoaXMgaW5jbHVkZXMgdmVyaWZ5aW5nIHRoZSBmb2xsb3dpbmcgbm90aW9uczpcbiAqICAtIEVhY2ggdHlwZSByZXF1ZXN0ZWQgaXMgcHJlc2VudCBpbiB0eXBlc1xuICogIC0gT25seSBhbGxvdyBhIG5hbWUgZm9yIGEgZmllbGQgdG8gYmUgc3BlY2lmaWVkIG9uY2VcbiAqICAtIElmIGFuIGFycmF5IGlzIHNwZWNpZmllZCwgdmFsaWRhdGUgdGhhdCB0aGUgcmVxdWVzdGVkIGZpZWxkIGV4aXN0cyBhbmRcbiAqICAgIGNvbWVzIGJlZm9yZSBpdC5cbiAqICAtIElmIGZpZWxkcyBpcyBkZWZpbmVkLCBjaGVjayB0aGF0IGVhY2ggZW50cnkgaGFzIHRoZSBvY2N1cnJlbmNlIG9mIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGN0Q2hlY2tSZXEoZGVmLCB0eXBlcywgZmllbGRzKVxue1xuXHR2YXIgaWksIGpqO1xuXHR2YXIgcmVxLCBrZXlzLCBrZXk7XG5cdHZhciBmb3VuZCA9IHt9O1xuXG5cdGlmICghKGRlZiBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdkZWZpbml0aW9uIGlzIG5vdCBhbiBhcnJheScpKTtcblxuXHRpZiAoZGVmLmxlbmd0aCA9PT0gMClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdkZWZpbml0aW9uIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCcpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBkZWYubGVuZ3RoOyBpaSsrKSB7XG5cdFx0cmVxID0gZGVmW2lpXTtcblx0XHRpZiAoIShyZXEgaW5zdGFuY2VvZiBPYmplY3QpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignZGVmaW5pdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mJyArXG5cdFx0XHQgICAgJ29iamVjdHMnKSk7XG5cblx0XHRrZXlzID0gT2JqZWN0LmtleXMocmVxKTtcblx0XHRpZiAoa2V5cy5sZW5ndGggIT0gMSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2RlZmluaXRpb24gZW50cnkgbXVzdCBvbmx5IGhhdmUgJyArXG5cdFx0XHQgICAgJ29uZSBrZXknKSk7XG5cblx0XHRpZiAoa2V5c1swXSBpbiBmb3VuZClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1NwZWNpZmllZCBuYW1lIGFscmVhZHkgJyArXG5cdFx0XHQgICAgJ3NwZWNpZmllZDogJyArIGtleXNbMF0pKTtcblxuXHRcdGlmICghKCd0eXBlJyBpbiByZXFba2V5c1swXV0pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eXBlIGRlZmluaXRpb24nKSk7XG5cblx0XHRrZXkgPSBjdFBhcnNlVHlwZShyZXFba2V5c1swXV1bJ3R5cGUnXSk7XG5cblx0XHQvKlxuXHRcdCAqIFdlIG1heSBoYXZlIG5lc3RlZCBhcnJheXMsIHdlIG5lZWQgdG8gY2hlY2sgdGhlIHZhbGlkaXR5IG9mXG5cdFx0ICogdGhlIHR5cGVzIHVudGlsIHRoZSBsZW4gZmllbGQgaXMgdW5kZWZpbmVkIGluIGtleS4gSG93ZXZlcixcblx0XHQgKiBlYWNoIHRpbWUgbGVuIGlzIGRlZmluZWQgd2UgbmVlZCB0byB2ZXJpZnkgaXQgaXMgZWl0aGVyIGFuXG5cdFx0ICogaW50ZWdlciBvciBjb3JyZXNwb25kcyB0byBhbiBhbHJlYWR5IHNlZW4ga2V5LlxuXHRcdCAqL1xuXHRcdHdoaWxlIChrZXlbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChpc05hTihwYXJzZUludChrZXlbJ2xlbiddLCAxMCkpKSB7XG5cdFx0XHRcdGlmICghKGtleVsnbGVuJ10gaW4gZm91bmQpKVxuXHRcdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0dpdmVuIGFuIGFycmF5ICcgK1xuXHRcdFx0XHRcdCAgICAnbGVuZ3RoIHdpdGhvdXQgYSBtYXRjaGluZyB0eXBlJykpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleSA9IGN0UGFyc2VUeXBlKGtleVsndHlwZSddKTtcblx0XHR9XG5cblx0XHQvKiBOb3cgd2UgY2FuIHZhbGlkYXRlIGlmIHRoZSB0eXBlIGlzIHZhbGlkICovXG5cdFx0aWYgKCEoa2V5Wyd0eXBlJ10gaW4gdHlwZXMpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndHlwZSBub3QgZm91bmQgb3IgdHlwZGVmZWQ6ICcgK1xuXHRcdFx0ICAgIGtleVsndHlwZSddKSk7XG5cblx0XHQvKiBDaGVjayBmb3IgYW55IHJlcXVpcmVkIGZpZWxkcyAqL1xuXHRcdGlmIChmaWVsZHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChqaiA9IDA7IGpqIDwgZmllbGRzLmxlbmd0aDsgamorKykge1xuXHRcdFx0XHRpZiAoIShmaWVsZHNbampdIGluIHJlcVtrZXlzWzBdXSkpXG5cdFx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCAnICtcblx0XHRcdFx0XHQgICAgJ2ZpZWxkOiAnICsgZmllbGRzW2pqXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvdW5kW2tleXNbMF1dID0gdHJ1ZTtcblx0fVxufVxuXG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHBhcnNlci4gRWFjaCBwYXJzZXIgaGFzIGl0cyBvd24gc3RvcmUgb2ZcbiAqIHR5cGVkZWZzIGFuZCBlbmRpYW5uZXNzLiBDb25mIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcmVxdWlyZWRcbiAqIHZhbHVlczpcbiAqXG4gKlx0ZW5kaWFuXHRcdEVpdGhlciAnYmlnJyBvciAnbGl0dGxlJyBkbyBkZXRlcm1pbmUgdGhlIGVuZGlhbm5lc3Mgd2VcbiAqXHRcdFx0d2FudCB0byByZWFkIGZyb20gb3Igd3JpdGUgdG8uXG4gKlxuICogQW5kIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgdmFsdWVzOlxuICpcbiAqIFx0Y2hhci10eXBlXHRWYWxpZCBvcHRpb25zIGhlcmUgYXJlIHVpbnQ4IGFuZCBpbnQ4LiBJZiB1aW50OCBpc1xuICogXHRcdFx0c3BlY2lmaWVkIHRoaXMgY2hhbmdlcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBhIHNpbmdsZVxuICogXHRcdFx0Y2hhciBmcm9tIGJlaW5nIGEgYnVmZmVyIG9mIGEgc2luZ2xlIGNoYXJhY3RlciB0byBiZWluZ1xuICogXHRcdFx0YSB1aW50OF90LiBJZiBpbnQ4LCBpdCBiZWNvbWVzIGFuIGludDhfdCBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBDVHlwZVBhcnNlcihjb25mKVxue1xuXHRpZiAoIWNvbmYpIHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQnKSk7XG5cblx0aWYgKCEoJ2VuZGlhbicgaW4gY29uZikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBlbmRpYW4gdmFsdWUnKSk7XG5cblx0aWYgKGNvbmZbJ2VuZGlhbiddICE9ICdiaWcnICYmIGNvbmZbJ2VuZGlhbiddICE9ICdsaXR0bGUnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgZW5kaWFuIHR5cGUnKSk7XG5cblx0aWYgKCdjaGFyLXR5cGUnIGluIGNvbmYgJiYgKGNvbmZbJ2NoYXItdHlwZSddICE9ICd1aW50OCcgJiZcblx0ICAgIGNvbmZbJ2NoYXItdHlwZSddICE9ICdpbnQ4JykpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignaW52YWxpZCBvcHRpb24gZm9yIGNoYXItdHlwZTogJyArXG5cdFx0ICAgIGNvbmZbJ2NoYXItdHlwZSddKSk7XG5cblx0dGhpcy5lbmRpYW4gPSBjb25mWydlbmRpYW4nXTtcblx0dGhpcy50eXBlcyA9IGN0R2V0QmFzaWNUeXBlcygpO1xuXG5cdC8qXG5cdCAqIFRoZXJlIG1heSBiZSBhIG1vcmUgZ3JhY2VmdWwgd2F5IHRvIGRvIHRoaXMsIGJ1dCB0aGlzIHdpbGwgaGF2ZSB0b1xuXHQgKiBzZXJ2ZS5cblx0ICovXG5cdGlmICgnY2hhci10eXBlJyBpbiBjb25mICYmIGNvbmZbJ2NoYXItdHlwZSddID09ICd1aW50OCcpXG5cdFx0dGhpcy50eXBlc1snY2hhciddID0gdGhpcy50eXBlc1sndWludDhfdCddO1xuXG5cdGlmICgnY2hhci10eXBlJyBpbiBjb25mICYmIGNvbmZbJ2NoYXItdHlwZSddID09ICdpbnQ4Jylcblx0XHR0aGlzLnR5cGVzWydjaGFyJ10gPSB0aGlzLnR5cGVzWydpbnQ4X3QnXTtcbn1cblxuLypcbiAqIFNldHMgdGhlIGN1cnJlbnQgZW5kaWFuIHZhbHVlIGZvciB0aGUgUGFyc2VyLiBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLFxuICogdGhyb3dzIGFuIEVycm9yLlxuICpcbiAqXHRlbmRpYW5cdFx0RWl0aGVyICdiaWcnIG9yICdsaXR0bGUnIGRvIGRldGVybWluZSB0aGUgZW5kaWFubmVzcyB3ZVxuICpcdFx0XHR3YW50IHRvIHJlYWQgZnJvbSBvciB3cml0ZSB0by5cbiAqXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5zZXRFbmRpYW4gPSBmdW5jdGlvbiAoZW5kaWFuKVxue1xuXHRpZiAoZW5kaWFuICE9ICdiaWcnICYmIGVuZGlhbiAhPSAnbGl0dGxlJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIGVuZGlhbiB0eXBlLCBtdXN0IGJlIGJpZyBvciAnICtcblx0XHQgICAgJ2xpdHRsZScpKTtcblxuXHR0aGlzLmVuZGlhbiA9IGVuZGlhbjtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbmRpYW4gdmFsdWUgZm9yIHRoZSBwYXJzZXIuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5nZXRFbmRpYW4gPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gKHRoaXMuZW5kaWFuKTtcbn07XG5cbi8qXG4gKiBBIHVzZXIgaGFzIHJlcXVlc3RlZCB0byBhZGQgYSB0eXBlLCBsZXQgdXMgaG9ub3IgdGhlaXIgcmVxdWVzdC4gWWV0LCBpZiB0aGVpclxuICogcmVxdWVzdCBkb3RoIHNwdXJuIHVzLCBzZW5kIHRoZW0gdW50byB0aGUgSGVsbHMgd2hpY2ggRGFudGUgZGVzY3JpYmVzLlxuICpcbiAqIFx0bmFtZVx0XHRUaGUgc3RyaW5nIGZvciB0aGUgdHlwZSBkZWZpbml0aW9uIHdlJ3JlIGFkZGluZ1xuICpcbiAqXHR2YWx1ZVx0XHRFaXRoZXIgYSBzdHJpbmcgdGhhdCBpcyBhIHR5cGUvYXJyYXkgbmFtZSBvciBhbiBvYmplY3RcbiAqXHRcdFx0dGhhdCBkZXNjcmliZXMgYSBzdHJ1Y3QuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS50eXBlZGVmID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKVxue1xuXHR2YXIgdHlwZTtcblxuXHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR5cGVkZWYgYXJndW1lbnQ6IG5hbWUnKSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR5cGVkZWYgYXJndW1lbnQ6IHZhbHVlJykpKTtcblxuXHRpZiAodHlwZW9mIChuYW1lKSAhPSAnc3RyaW5nJylcblx0XHR0aHJvdyAobmV3IChFcnJvcigndGhlIG5hbWUgb2YgYSB0eXBlIG11c3QgYmUgYSBzdHJpbmcnKSkpO1xuXG5cdHR5cGUgPSBjdFBhcnNlVHlwZShuYW1lKTtcblxuXHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBhbiBhcnJheSBpbiB0aGUgdHlwZWRlZiBuYW1lJykpO1xuXG5cdGlmIChuYW1lIGluIHRoaXMudHlwZXMpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndHlwZWRlZiBuYW1lIGFscmVhZHkgcHJlc2VudDogJyArIG5hbWUpKTtcblxuXHRpZiAodHlwZW9mICh2YWx1ZSkgIT0gJ3N0cmluZycgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlZGVmIHZhbHVlIG11c3QgZWl0aGVyIGJlIGEgc3RyaW5nIG9yICcgK1xuXHRcdCAgICAnc3RydWN0JykpO1xuXG5cdGlmICh0eXBlb2YgKHZhbHVlKSA9PSAnc3RyaW5nJykge1xuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZSh2YWx1ZSk7XG5cdFx0aWYgKHR5cGVbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChpc05hTihwYXJzZUludCh0eXBlWydsZW4nXSwgMTApKSlcblx0XHRcdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ3R5cGVkZWYgdmFsdWUgbXVzdCB1c2UgJyArXG5cdFx0XHRcdCAgICAnZml4ZWQgc2l6ZSBhcnJheSB3aGVuIG91dHNpZGUgb2YgYSAnICtcblx0XHRcdFx0ICAgICdzdHJ1Y3QnKSkpO1xuXHRcdH1cblxuXHRcdHRoaXMudHlwZXNbbmFtZV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvKiBXZSBoYXZlIGEgc3RydWN0LCB2YWxpZGF0ZSBpdCAqL1xuXHRcdGN0Q2hlY2tSZXEodmFsdWUsIHRoaXMudHlwZXMpO1xuXHRcdHRoaXMudHlwZXNbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxuLypcbiAqIEluY2x1ZGUgYWxsIG9mIHRoZSB0eXBlZGVmcywgYnV0IG5vbmUgb2YgdGhlIGJ1aWx0IGluIHR5cGVzLiBUaGlzIHNob3VsZCBiZVxuICogdHJlYXRlZCBhcyByZWFkLW9ubHkuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5sc3R5cGVzID0gZnVuY3Rpb24gKClcbntcblx0dmFyIGtleTtcblx0dmFyIHJldCA9IHt9O1xuXG5cdGZvciAoa2V5IGluIHRoaXMudHlwZXMpIHtcblx0XHRpZiAoa2V5IGluIGRlZnR5cGVzKVxuXHRcdFx0Y29udGludWU7XG5cdFx0cmV0W2tleV0gPSB0aGlzLnR5cGVzW2tleV07XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59O1xuXG4vKlxuICogR2l2ZW4gYSB0eXBlIHN0cmluZyB0aGF0IG1heSBoYXZlIGFycmF5IHR5cGVzIHRoYXQgYXJlbid0IG51bWJlcnMsIHRyeSBhbmRcbiAqIGZpbGwgdGhlbSBpbiBmcm9tIHRoZSB2YWx1ZXMgb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IHdoZXJlXG4gKiBpbmRleGluZyBpbnRvIGl0IHNob3VsZCByZXR1cm4gYSBudW1iZXIgZm9yIHRoYXQgdHlwZS5cbiAqXG4gKlx0c3RyXHRcdFRoZSB0eXBlIHN0cmluZ1xuICpcbiAqXHR2YWx1ZXNcdFx0QW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZnVsZmlsbCB0eXBlIGluZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGN0UmVzb2x2ZUFycmF5KHN0ciwgdmFsdWVzKVxue1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciB0eXBlID0gY3RQYXJzZVR5cGUoc3RyKTtcblxuXHR3aGlsZSAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChpc05hTihwYXJzZUludCh0eXBlWydsZW4nXSwgMTApKSkge1xuXHRcdFx0aWYgKHR5cGVvZiAodmFsdWVzW3R5cGVbJ2xlbiddXSkgIT0gJ251bWJlcicpXG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2Nhbm5vdCBzYXdwIGluIG5vbi1udW1iZXIgJyArXG5cdFx0XHRcdCAgICAnZm9yIGFycmF5IHZhbHVlJykpO1xuXHRcdFx0cmV0ID0gJ1snICsgdmFsdWVzW3R5cGVbJ2xlbiddXSArICddJyArIHJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gJ1snICsgdHlwZVsnbGVuJ10gKyAnXScgKyByZXQ7XG5cdFx0fVxuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZSh0eXBlWyd0eXBlJ10pO1xuXHR9XG5cblx0cmV0ID0gdHlwZVsndHlwZSddICsgcmV0O1xuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFtwcml2YXRlXSBFaXRoZXIgdGhlIHR5cGVkZWYgcmVzb2x2ZXMgdG8gYW5vdGhlciB0eXBlIHN0cmluZyBvciB0byBhIHN0cnVjdC5cbiAqIElmIGl0IHJlc29sdmVzIHRvIGEgc3RydWN0LCB3ZSBqdXN0IHBhc3MgaXQgb2ZmIHRvIHJlYWQgc3RydWN0LiBJZiBub3QsIHdlXG4gKiBjYW4ganVzdCBwYXNzIGl0IG9mZiB0byByZWFkIGVudHJ5LlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVzb2x2ZVR5cGVkZWYgPSBmdW5jdGlvbiAodHlwZSwgZGlzcGF0Y2gsIGJ1ZmZlcixcbiAgICBvZmZzZXQsIHZhbHVlKVxue1xuXHR2YXIgcHQ7XG5cblx0bW9kX2Fzc2VydC5vayh0eXBlIGluIHRoaXMudHlwZXMpO1xuXHRpZiAodHlwZW9mICh0aGlzLnR5cGVzW3R5cGVdKSA9PSAnc3RyaW5nJykge1xuXHRcdHB0ID0gY3RQYXJzZVR5cGUodGhpcy50eXBlc1t0eXBlXSk7XG5cdFx0aWYgKGRpc3BhdGNoID09ICdyZWFkJylcblx0XHRcdHJldHVybiAodGhpcy5yZWFkRW50cnkocHQsIGJ1ZmZlciwgb2Zmc2V0KSk7XG5cdFx0ZWxzZSBpZiAoZGlzcGF0Y2ggPT0gJ3dyaXRlJylcblx0XHRcdHJldHVybiAodGhpcy53cml0ZUVudHJ5KHZhbHVlLCBwdCwgYnVmZmVyLCBvZmZzZXQpKTtcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIGRpc3BhdGNoIHR5cGUgdG8gJyArXG5cdFx0XHQgICAgJ3Jlc29sdmVUeXBlZGVmJykpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChkaXNwYXRjaCA9PSAncmVhZCcpXG5cdFx0XHRyZXR1cm4gKHRoaXMucmVhZFN0cnVjdCh0aGlzLnR5cGVzW3R5cGVdLCBidWZmZXIsXG5cdFx0XHQgICAgb2Zmc2V0KSk7XG5cdFx0ZWxzZSBpZiAoZGlzcGF0Y2ggPT0gJ3dyaXRlJylcblx0XHRcdHJldHVybiAodGhpcy53cml0ZVN0cnVjdCh2YWx1ZSwgdGhpcy50eXBlc1t0eXBlXSxcblx0XHRcdCAgICBidWZmZXIsIG9mZnNldCkpO1xuXHRcdGVsc2Vcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2ludmFsaWQgZGlzcGF0Y2ggdHlwZSB0byAnICtcblx0XHRcdCAgICAncmVzb2x2ZVR5cGVkZWYnKSk7XG5cdH1cblxufTtcblxuLypcbiAqIFtwcml2YXRlXSBUcnkgYW5kIHJlYWQgaW4gdGhlIHNwZWNpZmljIGVudHJ5LlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZEVudHJ5ID0gZnVuY3Rpb24gKHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgcGFyc2UsIGxlbjtcblxuXHQvKlxuXHQgKiBCZWNhdXNlIHdlIHdhbnQgdG8gc3BlY2lhbCBjYXNlIGNoYXJbXXMgdGhpcyBpcyB1bmZvcnR1bmF0ZWx5XG5cdCAqIGEgYml0IHVnbGllciB0aGFuIGl0IHJlYWxseSBzaG91bGQgYmUuIFdlIHdhbnQgdG8gc3BlY2lhbFxuXHQgKiBjYXNlIGNoYXJbXXMgc28gdGhhdCB3ZSByZXR1cm4gYSBub2RlIGJ1ZmZlciwgdGh1cyB0aGV5IGFyZSBhXG5cdCAqIGZpcnN0IGNsYXNzIHR5cGUgd2hlcmUgYXMgYWxsIG90aGVyIGFycmF5cyBqdXN0IGNhbGwgaW50byBhXG5cdCAqIGdlbmVyaWMgYXJyYXkgcm91dGluZSB3aGljaCBjYWxscyB0aGVpciBkYXRhLXNwZWNpZmljIHJvdXRpbmVcblx0ICogdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG5cdCAqXG5cdCAqIFRoZSB2YWxpZCBkaXNwYXRjaCBvcHRpb25zIHdlIGhhdmUgYXJlOlxuXHQgKiAgLSBBcnJheSBhbmQgY2hhciA9PiBjaGFyW10gaGFuZGxlclxuXHQgKiAgLSBHZW5lcmljIGFycmF5IGhhbmRsZXJcblx0ICogIC0gR2VuZXJpYyB0eXBlZGVmIGhhbmRsZXJcblx0ICogIC0gQmFzaWMgdHlwZSBoYW5kbGVyXG5cdCAqL1xuXHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdGxlbiA9IHBhcnNlSW50KHR5cGVbJ2xlbiddLCAxMCk7XG5cdFx0aWYgKGlzTmFOKGxlbikpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdzb21laG93IGdvdCBhIG5vbi1udW1lcmljIGxlbmd0aCcpKTtcblxuXHRcdGlmICh0eXBlWyd0eXBlJ10gPT0gJ2NoYXInKVxuXHRcdFx0cGFyc2UgPSB0aGlzLnR5cGVzWydjaGFyW10nXVsncmVhZCddKGxlbixcblx0XHRcdCAgICB0aGlzLmVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdGVsc2Vcblx0XHRcdHBhcnNlID0gdGhpcy5yZWFkQXJyYXkodHlwZVsndHlwZSddLFxuXHRcdFx0ICAgIGxlbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0eXBlWyd0eXBlJ10gaW4gZGVmdHlwZXMpXG5cdFx0XHRwYXJzZSA9IHRoaXMudHlwZXNbdHlwZVsndHlwZSddXVsncmVhZCddKHRoaXMuZW5kaWFuLFxuXHRcdFx0ICAgIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRlbHNlXG5cdFx0XHRwYXJzZSA9IHRoaXMucmVzb2x2ZVR5cGVkZWYodHlwZVsndHlwZSddLCAncmVhZCcsXG5cdFx0XHQgICAgYnVmZmVyLCBvZmZzZXQpO1xuXHR9XG5cblx0cmV0dXJuIChwYXJzZSk7XG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFJlYWQgYW4gYXJyYXkgb2YgZGF0YVxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZEFycmF5ID0gZnVuY3Rpb24gKHR5cGUsIGxlbmd0aCwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBpaSwgZW50LCBwdDtcblx0dmFyIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG5cdHZhciByZXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0cHQgPSBjdFBhcnNlVHlwZSh0eXBlKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcblx0XHRlbnQgPSB0aGlzLnJlYWRFbnRyeShwdCwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBlbnRbJ3NpemUnXTtcblx0XHRyZXRbaWldID0gZW50Wyd2YWx1ZSddO1xuXHR9XG5cblx0cmV0dXJuICh7IHZhbHVlOiByZXQsIHNpemU6IG9mZnNldCAtIGJhc2VPZmZzZXQgfSk7XG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFJlYWQgYSBzaW5nbGUgc3RydWN0IGluLlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZFN0cnVjdCA9IGZ1bmN0aW9uIChkZWYsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgcGFyc2UsIGlpLCB0eXBlLCBlbnRyeSwga2V5O1xuXHR2YXIgYmFzZU9mZnNldCA9IG9mZnNldDtcblx0dmFyIHJldCA9IHt9O1xuXG5cdC8qIFdhbGsgaXQgYW5kIGhhbmRsZSBkb2luZyB3aGF0J3MgbmVjZXNzYXJ5ICovXG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRrZXkgPSBPYmplY3Qua2V5cyhkZWZbaWldKVswXTtcblx0XHRlbnRyeSA9IGRlZltpaV1ba2V5XTtcblxuXHRcdC8qIFJlc29sdmUgYWxsIGFycmF5IHZhbHVlcyAqL1xuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZShjdFJlc29sdmVBcnJheShlbnRyeVsndHlwZSddLCByZXQpKTtcblxuXHRcdGlmICgnb2Zmc2V0JyBpbiBlbnRyeSlcblx0XHRcdG9mZnNldCA9IGJhc2VPZmZzZXQgKyBlbnRyeVsnb2Zmc2V0J107XG5cblx0XHRwYXJzZSA9IHRoaXMucmVhZEVudHJ5KHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KTtcblxuXHRcdG9mZnNldCArPSBwYXJzZVsnc2l6ZSddO1xuXHRcdHJldFtrZXldID0gcGFyc2VbJ3ZhbHVlJ107XG5cdH1cblxuXHRyZXR1cm4gKHsgdmFsdWU6IHJldCwgc2l6ZTogKG9mZnNldC1iYXNlT2Zmc2V0KX0pO1xufTtcblxuLypcbiAqIFRoaXMgaXMgd2hhdCB3ZSB3ZXJlIGJvcm4gdG8gZG8uIFdlIHJlYWQgdGhlIGRhdGEgZnJvbSBhIGJ1ZmZlciBhbmQgcmV0dXJuIGl0XG4gKiBpbiBhbiBvYmplY3Qgd2hvc2Uga2V5cyBtYXRjaCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdC5cbiAqXG4gKlx0ZGVmXHRcdFRoZSBhcnJheSBkZWZpbml0aW9uIG9mIHRoZSBkYXRhIHRvIHJlYWQgaW5cbiAqXG4gKlx0YnVmZmVyXHRcdFRoZSBidWZmZXIgdG8gcmVhZCBkYXRhIGZyb21cbiAqXG4gKlx0b2Zmc2V0XHRcdFRoZSBvZmZzZXQgdG8gc3RhcnQgd3JpdGluZyB0b1xuICpcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGFuIGVudHJ5IGluIGRlZiBhbmQgdGhlIHZhbHVlXG4gKiBpcyB0aGUgcmVhZCB2YWx1ZS5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24gKGRlZiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdC8qIFNhbml0eSBjaGVjayBmb3IgYXJndW1lbnRzICovXG5cdGlmIChkZWYgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGRlZmluaXRpb24gZm9yIHdoYXQgd2Ugc2hvdWxkIGJlJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlciBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdC8qIFNhbml0eSBjaGVjayB0aGUgb2JqZWN0IGRlZmluaXRpb24gKi9cblx0Y3RDaGVja1JlcShkZWYsIHRoaXMudHlwZXMpO1xuXG5cdHJldHVybiAodGhpcy5yZWFkU3RydWN0KGRlZiwgYnVmZmVyLCBvZmZzZXQpWyd2YWx1ZSddKTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gV3JpdGUgb3V0IGFuIGFycmF5IG9mIGRhdGFcbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUsIGxlbmd0aCwgYnVmZmVyLFxuICAgIG9mZnNldClcbntcblx0dmFyIGlpLCBwdDtcblx0dmFyIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2Fza2VkIHRvIHdyaXRlIGFuIGFycmF5LCBidXQgdmFsdWUgaXMgbm90ICcgK1xuXHRcdCAgICAnYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCAhPSBsZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignYXNrZWQgdG8gd3JpdGUgYXJyYXkgb2YgbGVuZ3RoICcgKyBsZW5ndGggK1xuXHRcdCAgICAnIGJ1dCB0aGF0IGRvZXMgbm90IG1hdGNoIHZhbHVlIGxlbmd0aDogJyArIHZhbHVlLmxlbmd0aCkpO1xuXG5cdHB0ID0gY3RQYXJzZVR5cGUodHlwZSk7XG5cdGZvciAoaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKylcblx0XHRvZmZzZXQgKz0gdGhpcy53cml0ZUVudHJ5KHZhbHVlW2lpXSwgcHQsIGJ1ZmZlciwgb2Zmc2V0KTtcblxuXHRyZXR1cm4gKG9mZnNldCAtIGJhc2VPZmZzZXQpO1xufTtcblxuLypcbiAqIFtwcml2YXRlXSBXcml0ZSB0aGUgc3BlY2lmaWMgZW50cnlcbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlRW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgbGVuLCByZXQ7XG5cblx0aWYgKHR5cGVbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRsZW4gPSBwYXJzZUludCh0eXBlWydsZW4nXSwgMTApO1xuXHRcdGlmIChpc05hTihsZW4pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignc29tZWhvdyBnb3QgYSBub24tbnVtZXJpYyBsZW5ndGgnKSk7XG5cblx0XHRpZiAodHlwZVsndHlwZSddID09ICdjaGFyJylcblx0XHRcdHJldCA9IHRoaXMudHlwZXNbJ2NoYXJbXSddWyd3cml0ZSddKHZhbHVlLCBsZW4sXG5cdFx0XHQgICAgdGhpcy5lbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSB0aGlzLndyaXRlQXJyYXkodmFsdWUsIHR5cGVbJ3R5cGUnXSxcblx0XHRcdCAgICBsZW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0fSBlbHNlIHtcblx0XHRpZiAodHlwZVsndHlwZSddIGluIGRlZnR5cGVzKVxuXHRcdFx0cmV0ID0gdGhpcy50eXBlc1t0eXBlWyd0eXBlJ11dWyd3cml0ZSddKHZhbHVlLFxuXHRcdFx0ICAgIHRoaXMuZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0ID0gdGhpcy5yZXNvbHZlVHlwZWRlZih0eXBlWyd0eXBlJ10sICd3cml0ZScsXG5cdFx0XHQgICAgYnVmZmVyLCBvZmZzZXQsIHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gV3JpdGUgYSBzaW5nbGUgc3RydWN0IG91dC5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlU3RydWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWYsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWksIGVudHJ5LCB0eXBlLCBrZXk7XG5cdHZhciBiYXNlT2Zmc2V0ID0gb2Zmc2V0O1xuXHR2YXIgdmFscyA9IHt9O1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRrZXkgPSBPYmplY3Qua2V5cyhkZWZbaWldKVswXTtcblx0XHRlbnRyeSA9IGRlZltpaV1ba2V5XTtcblxuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZShjdFJlc29sdmVBcnJheShlbnRyeVsndHlwZSddLCB2YWxzKSk7XG5cblx0XHRpZiAoJ29mZnNldCcgaW4gZW50cnkpXG5cdFx0XHRvZmZzZXQgPSBiYXNlT2Zmc2V0ICsgZW50cnlbJ29mZnNldCddO1xuXG5cdFx0b2Zmc2V0ICs9IHRoaXMud3JpdGVFbnRyeSh2YWx1ZVtpaV0sIHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHQvKiBOb3cgdGhhdCB3ZSd2ZSB3cml0dGVuIGl0IG91dCwgd2UgY2FuIHVzZSBpdCBmb3IgYXJyYXlzICovXG5cdFx0dmFsc1trZXldID0gdmFsdWVbaWldO1xuXHR9XG5cblx0cmV0dXJuIChvZmZzZXQpO1xufTtcblxuLypcbiAqIFVuZm9ydHVuYXRlbHksIHdlJ3JlIHN0dWNrIHdpdGggdGhlIHNpbnMgb2YgYW4gaW5pdGlhbCBwb29yIGRlc2lnbi4gQmVjYXVzZVxuICogb2YgdGhhdCwgd2UgYXJlIGdvaW5nIHRvIGhhdmUgdG8gc3VwcG9ydCB0aGUgb2xkIHdheSBvZiB3cml0aW5nIGRhdGEgdmlhXG4gKiB3cml0ZURhdGEuIFRoZXJlIHdlIGluc2VydCB0aGUgdmFsdWVzIHRoYXQgeW91IHdhbnQgdG8gd3JpdGUgaW50byB0aGVcbiAqIGRlZmluaXRpb24uIEEgbGl0dGxlIGJhcm9xdWUuIEludGVybmFsbHksIHdlIHVzZSB0aGUgbmV3IG1vZGVsLiBTbyB3ZSBuZWVkIHRvXG4gKiBqdXN0IGdldCB0aG9zZSB2YWx1ZXMgb3V0IG9mIHRoZXJlLiBCdXQgdG8gbWFpbnRhaW4gdGhlIHByaW5jaXBsZSBvZiBsZWFzdFxuICogc3VycHJpc2UsIHdlJ3JlIG5vdCBnb2luZyB0byBtb2RpZnkgdGhlIGlucHV0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlcyhkZWYpXG57XG5cdHZhciBpaSwgb3V0LCBrZXk7XG5cdG91dCA9IFtdO1xuXHRmb3IgKGlpID0gMDsgaWkgPCBkZWYubGVuZ3RoOyBpaSsrKSB7XG5cdFx0a2V5ID0gT2JqZWN0LmtleXMoZGVmW2lpXSlbMF07XG5cdFx0bW9kX2Fzc2VydC5vaygndmFsdWUnIGluIGRlZltpaV1ba2V5XSk7XG5cdFx0b3V0LnB1c2goZGVmW2lpXVtrZXldWyd2YWx1ZSddKTtcblx0fVxuXG5cdHJldHVybiAob3V0KTtcbn1cblxuLypcbiAqIFRoaXMgaXMgdGhlIHNlY29uZCBoYWxmIG9mIHdoYXQgd2Ugd2VyZSBib3JuIHRvIGRvLCB3cml0ZSBvdXQgdGhlIGRhdGFcbiAqIGl0c2VsZi4gSGlzdG9yaWNhbGx5IHRoaXMgZnVuY3Rpb24gcmVxdWlyZWQgeW91IHRvIHB1dCB5b3VyIHZhbHVlcyBpbiB0aGVcbiAqIGRlZmluaXRpb24gc2VjdGlvbi4gVGhpcyB3YXMgbm90IHRoZSBzbWFydGVzdCB0aGluZyB0byBkbyBhbmQgYSBiaXQgb2YgYW5cbiAqIG92ZXJzaWdodCB0byBiZSBob25lc3QuIEFzIHN1Y2gsIHRoaXMgZnVuY3Rpb24gbm93IHRha2VzIGEgdmFsdWVzIGFyZ3VtZW50LlxuICogSWYgdmFsdWVzIGlzIG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogdmFsdWVzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG9sZCBtZXRob2QgaXMgc3RpbGwgc3VwcG9ydGVkLCBidXQgaXMgbm8gbG9uZ2VyXG4gKiBhY2NlcHRhYmxlLlxuICpcbiAqXHRkZWZcdFx0VGhlIGFycmF5IGRlZmluaXRpb24gb2YgdGhlIGRhdGEgdG8gd3JpdGUgb3V0IHdpdGhcbiAqXHRcdFx0dmFsdWVzXG4gKlxuICpcdGJ1ZmZlclx0XHRUaGUgYnVmZmVyIHRvIHdyaXRlIHRvXG4gKlxuICpcdG9mZnNldFx0XHRUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gd3JpdGUgdG9cbiAqXG4gKlx0dmFsdWVzXHRcdEFuIGFycmF5IG9mIHZhbHVlcyB0byB3cml0ZS5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlRGF0YSA9IGZ1bmN0aW9uIChkZWYsIGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZXMpXG57XG5cdHZhciBodjtcblxuXHRpZiAoZGVmID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBkZWZpbml0aW9uIGZvciB3aGF0IHdlIHNob3VsZCBiZScgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXIgZm9yIHdoYXQgd2Ugc2hvdWxkIGJlICcgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQgZm9yIHdoYXQgd2Ugc2hvdWxkIGJlICcgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRodiA9ICh2YWx1ZXMgIT0gbnVsbCAmJiB2YWx1ZXMgIT0gdW5kZWZpbmVkKTtcblx0aWYgKGh2KSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlcyBmb3Igd3JpdGluZycpKTtcblx0XHRjdENoZWNrUmVxKGRlZiwgdGhpcy50eXBlcyk7XG5cdH0gZWxzZSB7XG5cdFx0Y3RDaGVja1JlcShkZWYsIHRoaXMudHlwZXMsIFsgJ3ZhbHVlJyBdKTtcblx0fVxuXG5cdHRoaXMud3JpdGVTdHJ1Y3QoaHYgPyB2YWx1ZXMgOiBnZXRWYWx1ZXMoZGVmKSwgZGVmLCBidWZmZXIsIG9mZnNldCk7XG59O1xuXG4vKlxuICogRnVuY3Rpb25zIHRvIGdvIHRvIGFuZCBmcm9tIDY0IGJpdCBudW1iZXJzIGluIGEgd2F5IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoXG4gKiBKYXZhc2NyaXB0IGxpbWl0YXRpb25zLiBUaGVyZSBhcmUgdHdvIHNldHMuIE9uZSB3aGVyZSB0aGUgdXNlciBpcyBva2F5IHdpdGhcbiAqIGFuIGFwcHJveGltYXRpb24gYW5kIG9uZSB3aGVyZSB0aGV5IGFyZSBkZWZpbml0ZWx5IG5vdCBva2F5IHdpdGggYW5cbiAqIGFwcHJveGltYXRpb24uXG4gKi9cblxuLypcbiAqIEF0dGVtcHRzIHRvIGNvbnZlcnQgYW4gYXJyYXkgb2YgdHdvIGludGVnZXJzIHJldHVybmVkIGZyb20gcnNpbnQ2NCAvIHJ1aW50NjRcbiAqIGludG8gYW4gYWJzb2x1dGUgNjQgYml0IG51bWJlci4gSWYgaG93ZXZlciB0aGUgdmFsdWUgd291bGQgZXhjZWVkIDJeNTIgdGhpc1xuICogd2lsbCBpbnN0ZWFkIHRocm93IGFuIGVycm9yLiBUaGUgbWFudGlzc2EgaW4gYSBkb3VibGUgaXMgYSA1MiBiaXQgbnVtYmVyIGFuZFxuICogcmF0aGVyIHRoYW4gcG90ZW50aWFsbHkgZ2l2ZSB5b3UgYSB2YWx1ZSB0aGF0IGlzIGFuIGFwcHJveGltYXRpb24gdGhpcyB3aWxsXG4gKiBlcnJvci4gSWYgeW91IHdvdWxkIHJhdGhlciBhbiBhcHByb3hpbWF0aW9uLCBwbGVhc2Ugc2VlIHRvQXBwcm94NjQuXG4gKlxuICpcdHZhbFx0XHRBbiBhcnJheSBvZiB0d28gMzItYml0IGludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIHRvQWJzNjQodmFsKVxue1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBhcmc6IHZhbHVlJykpO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWwpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbC5sZW5ndGggIT0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJykpO1xuXG5cdC8qIFdlIGhhdmUgMjAgYml0cyB3b3J0aCBvZiBwcmVjaXNpb24gaW4gdGhpcyByYW5nZSAqL1xuXHRpZiAodmFsWzBdID49IDB4MTAwMDAwKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIHdvdWxkIGJlY29tZSBhcHByb3hpbWF0ZWQnKSk7XG5cblx0cmV0dXJuICh2YWxbMF0gKiBNYXRoLnBvdygyLCAzMikgKyB2YWxbMV0pO1xufVxuXG4vKlxuICogV2lsbCByZXR1cm4gdGhlIDY0IGJpdCB2YWx1ZSBhcyByZXR1cm5lZCBpbiBhbiBhcnJheSBmcm9tIHJzaW50NjQgLyBydWludDY0XG4gKiB0byBhIHZhbHVlIGFzIGNsb3NlIGFzIGl0IGNhbi4gTm90ZSB0aGF0IEphdmFzY3JpcHQgc3RvcmVzIGFsbCBudW1iZXJzIGFzIGFcbiAqIGRvdWJsZSBhbmQgdGhlIG1hbnRpc3NhIG9ubHkgaGFzIDUyIGJpdHMuIFRodXMgdGhpcyB2ZXJzaW9uIG1heSBhcHByb3hpbWF0ZVxuICogdGhlIHZhbHVlLlxuICpcbiAqXHR2YWxcdFx0QW4gYXJyYXkgb2YgdHdvIDMyLWJpdCBpbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiB0b0FwcHJveDY0KHZhbClcbntcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgYXJnOiB2YWx1ZScpKTtcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkodmFsKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5JykpO1xuXG5cdGlmICh2YWwubGVuZ3RoICE9IDIpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggMicpKTtcblxuXHRyZXR1cm4gKE1hdGgucG93KDIsIDMyKSAqIHZhbFswXSArIHZhbFsxXSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1RGKGpzb24sIGNvbmYpXG57XG5cdHZhciBjdHlwZSA9IG5ldyBDVHlwZVBhcnNlcihjb25mKTtcblx0bW9kX2N0Zi5jdGZQYXJzZUpzb24oanNvbiwgY3R5cGUpO1xuXG5cdHJldHVybiAoY3R5cGUpO1xufVxuXG4vKlxuICogRXhwb3J0IHRoZSBmZXcgdGhpbmdzIHdlIGFjdHVhbGx5IHdhbnQgdG8uIEN1cnJlbnRseSB0aGlzIGlzIGp1c3QgdGhlIENUeXBlXG4gKiBQYXJzZXIgYW5kIGN0aW8uXG4gKi9cbmV4cG9ydHMuUGFyc2VyID0gQ1R5cGVQYXJzZXI7XG5leHBvcnRzLnRvQWJzNjQgPSB0b0FiczY0O1xuZXhwb3J0cy50b0FwcHJveDY0ID0gdG9BcHByb3g2NDtcblxuZXhwb3J0cy5wYXJzZUNURiA9IHBhcnNlQ1RGO1xuXG5leHBvcnRzLnJ1aW50OCA9IG1vZF9jdGlvLnJ1aW50ODtcbmV4cG9ydHMucnVpbnQxNiA9IG1vZF9jdGlvLnJ1aW50MTY7XG5leHBvcnRzLnJ1aW50MzIgPSBtb2RfY3Rpby5ydWludDMyO1xuZXhwb3J0cy5ydWludDY0ID0gbW9kX2N0aW8ucnVpbnQ2NDtcbmV4cG9ydHMud3VpbnQ4ID0gbW9kX2N0aW8ud3VpbnQ4O1xuZXhwb3J0cy53dWludDE2ID0gbW9kX2N0aW8ud3VpbnQxNjtcbmV4cG9ydHMud3VpbnQzMiA9IG1vZF9jdGlvLnd1aW50MzI7XG5leHBvcnRzLnd1aW50NjQgPSBtb2RfY3Rpby53dWludDY0O1xuXG5leHBvcnRzLnJzaW50OCA9IG1vZF9jdGlvLnJzaW50ODtcbmV4cG9ydHMucnNpbnQxNiA9IG1vZF9jdGlvLnJzaW50MTY7XG5leHBvcnRzLnJzaW50MzIgPSBtb2RfY3Rpby5yc2ludDMyO1xuZXhwb3J0cy5yc2ludDY0ID0gbW9kX2N0aW8ucnNpbnQ2NDtcbmV4cG9ydHMud3NpbnQ4ID0gbW9kX2N0aW8ud3NpbnQ4O1xuZXhwb3J0cy53c2ludDE2ID0gbW9kX2N0aW8ud3NpbnQxNjtcbmV4cG9ydHMud3NpbnQzMiA9IG1vZF9jdGlvLndzaW50MzI7XG5leHBvcnRzLndzaW50NjQgPSBtb2RfY3Rpby53c2ludDY0O1xuXG5leHBvcnRzLnJmbG9hdCA9IG1vZF9jdGlvLnJmbG9hdDtcbmV4cG9ydHMucmRvdWJsZSA9IG1vZF9jdGlvLnJkb3VibGU7XG5leHBvcnRzLndmbG9hdCA9IG1vZF9jdGlvLndmbG9hdDtcbmV4cG9ydHMud2RvdWJsZSA9IG1vZF9jdGlvLndkb3VibGU7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbi8vIElmIHlvdSBoYXZlIG5vIGlkZWEgd2hhdCBBU04uMSBvciBCRVIgaXMsIHNlZSB0aGlzOlxuLy8gZnRwOi8vZnRwLnJzYS5jb20vcHViL3BrY3MvYXNjaWkvbGF5bWFuLmFzY1xuXG52YXIgQmVyID0gcmVxdWlyZSgnLi9iZXIvaW5kZXgnKTtcblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgQmVyOiBCZXIsXG5cbiAgQmVyUmVhZGVyOiBCZXIuUmVhZGVyLFxuXG4gIEJlcldyaXRlcjogQmVyLldyaXRlclxuXG59O1xuIiwiLypcbiAqIGN0Zi5qc1xuICpcbiAqIFVuZGVyc3RhbmQgYW5kIHBhcnNlIGFsbCBvZiB0aGUgZGlmZmVyZW50IEpTT04gZm9ybWF0cyBvZiBDVEYgZGF0YSBhbmRcbiAqIHRyYW5zbGF0ZSB0aGF0IGludG8gYSBzZXJpZXMgb2Ygbm9kZS1jdHlwZSBmcmllbmRseSBwaWVjZXMuIFRoZSByZWFzb24gZm9yXG4gKiB0aGUgYWJzdHJhY3Rpb24gaXMgdG8gaGFuZGxlIGRpZmZlcmVudCBjaGFuZ2VzIGluIHRoZSBmaWxlIGZvcm1hdC5cbiAqXG4gKiBXZSBoYXZlIHRvIGJlIGNhcmVmdWwgaGVyZSB0aGF0IHdlIGRvbid0IGVuZCB1cCB1c2luZyBhIG5hbWUgdGhhdCBpcyBhbHJlYWR5XG4gKiBhIGJ1aWx0IGluIHR5cGUuXG4gKi9cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQVNTRVJUID0gbW9kX2Fzc2VydC5vaztcblxudmFyIGN0Zl92ZXJzaW9ucyA9IFsgJzEuMCcgXTtcbnZhciBjdGZfZW50cmllcyA9IFsgJ2ludGVnZXInLCAnZmxvYXQnLCAndHlwZWRlZicsICdzdHJ1Y3QnIF07XG52YXIgY3RmX2RlZnR5cGVzID0gWyAnaW50OF90JywgJ3VpbnQ4X3QnLCAnaW50MTZfdCcsICd1aW50MTZfdCcsICdpbnQzMl90JyxcbiAgICAndWludDMyX3QnLCAnZmxvYXQnLCAnZG91YmxlJyBdO1xuXG5mdW5jdGlvbiBjdGZQYXJzZUludGVnZXIoZW50cnksIGN0eXBlKVxue1xuXHR2YXIgbmFtZSwgc2lnbiwgbGVuLCB0eXBlO1xuXG5cdG5hbWUgPSBlbnRyeVsnbmFtZSddO1xuXHRpZiAoISgnc2lnbmVkJyBpbiBlbnRyeVsnaW50ZWdlciddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGludGVnZXIgbWlzc2luZyAnICtcblx0XHQgICAgJ3NpZ25lZCB2YWx1ZScpKTtcblxuXG5cdGlmICghKCdsZW5ndGgnIGluIGVudHJ5WydpbnRlZ2VyJ10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogaW50ZWdlciBtaXNzaW5nICcgK1xuXHRcdCAgICAnbGVuZ3RoIHZhbHVlJykpO1xuXG5cdHNpZ24gPSBlbnRyeVsnaW50ZWdlciddWydzaWduZWQnXTtcblx0bGVuID0gZW50cnlbJ2ludGVnZXInXVsnbGVuZ3RoJ107XG5cdHR5cGUgPSBudWxsO1xuXG5cdGlmIChzaWduICYmIGxlbiA9PSAxKVxuXHRcdHR5cGUgPSAnaW50OF90Jztcblx0ZWxzZSBpZiAobGVuID09IDEpXG5cdFx0dHlwZSA9ICd1aW50OF90Jztcblx0ZWxzZSBpZiAoc2lnbiAmJiBsZW4gPT0gMilcblx0XHR0eXBlID0gJ2ludDE2X3QnO1xuXHRlbHNlIGlmIChsZW4gPT0gMilcblx0XHR0eXBlID0gJ3VpbnQxNl90Jztcblx0ZWxzZSBpZiAoc2lnbiAmJiBsZW4gPT0gNClcblx0XHR0eXBlID0gJ2ludDMyX3QnO1xuXHRlbHNlIGlmIChsZW4gPT0gNClcblx0XHR0eXBlID0gJ3VpbnQzMl90Jztcblx0ZWxzZSBpZiAoc2lnbiAmJiBsZW4gPT0gOClcblx0XHR0eXBlID0gJ2ludDY0X3QnO1xuXHRlbHNlIGlmIChsZW4gPT0gOClcblx0XHR0eXBlID0gJ3VpbnQ2NF90JztcblxuXHRpZiAodHlwZSA9PT0gbnVsbClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGludGVnZXIgaGFzICcgK1xuXHRcdCAgICAndW5zdXBwb3J0ZWQgbGVuZ3RoIGFuZCBzaWduIC0gJyArIGxlbiArICcvJyArIHNpZ24pKTtcblxuXHQvKlxuXHQgKiBUaGlzIG1lYW5zIHRoYXQgdGhpcyBpcyB0aGUgc2FtZSBhcyBvbmUgb2Ygb3VyIGJ1aWx0IGluIHR5cGVzLiBJZlxuXHQgKiB0aGF0J3MgdGhlIGNhc2UgZGVmaW5pbmcgaXQgd291bGQgYmUgYW4gZXJyb3IuIFNvIGluc3RlYWQgb2YgdHJ5aW5nXG5cdCAqIHRvIHR5cGVkZWYgaXQsIHdlJ2xsIHJldHVybiBoZXJlLlxuXHQgKi9cblx0aWYgKG5hbWUgPT0gdHlwZSlcblx0XHRyZXR1cm47XG5cblx0aWYgKG5hbWUgPT0gJ2NoYXInKSB7XG5cdFx0QVNTRVJUKHR5cGUgPT0gJ2ludDhfdCcpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGN0eXBlLnR5cGVkZWYobmFtZSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlRmxvYXQoZW50cnksIGN0eXBlKVxue1xuXHR2YXIgbmFtZSwgbGVuO1xuXG5cdG5hbWUgPSBlbnRyeVsnbmFtZSddO1xuXHRpZiAoISgnbGVuZ3RoJyBpbiBlbnRyeVsnZmxvYXQnXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBmbG9hdCBtaXNzaW5nICcgK1xuXHRcdCAgICAnbGVuZ3RoIHZhbHVlJykpO1xuXG5cdGxlbiA9IGVudHJ5WydmbG9hdCddWydsZW5ndGgnXTtcblx0aWYgKGxlbiAhPSA0ICYmIGxlbiAhPSA4KVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZmxvYXQgaGFzIGludmFsaWQgJyArXG5cdFx0ICAgICdsZW5ndGggdmFsdWUnKSk7XG5cblx0aWYgKGxlbiA9PSA0KSB7XG5cdFx0aWYgKG5hbWUgPT0gJ2Zsb2F0Jylcblx0XHRcdHJldHVybjtcblx0XHRjdHlwZS50eXBlZGVmKG5hbWUsICdmbG9hdCcpO1xuXHR9IGVsc2UgaWYgKGxlbiA9PSA4KSB7XG5cdFx0aWYgKG5hbWUgPT0gJ2RvdWJsZScpXG5cdFx0XHRyZXR1cm47XG5cdFx0Y3R5cGUudHlwZWRlZihuYW1lLCAnZG91YmxlJyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3RmUGFyc2VUeXBlZGVmKGVudHJ5LCBjdHlwZSlcbntcblx0dmFyIG5hbWUsIHR5cGUsIGlpO1xuXG5cdG5hbWUgPSBlbnRyeVsnbmFtZSddO1xuXHRpZiAodHlwZW9mIChlbnRyeVsndHlwZWRlZiddKSAhPSAnc3RyaW5nJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHR5cGVkZWYgdmFsdWUgaW4gbm90ICcgK1xuXHRcdCAgICAnYSBzdHJpbmcnKSk7XG5cblx0dHlwZSA9IGVudHJ5Wyd0eXBlZGVmJ107XG5cblx0Lypcblx0ICogV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3ZSdyZSBub3QgbG9va2luZyBhdCB0eXBlIHRoYXQncyBvbmUgb2Ygb3VyXG5cdCAqIGJ1aWx0IGluIHR5cGVzLiBUcmFkaXRpb25hbGx5IGluIEMgYSB1aW50MzJfdCB3b3VsZCBiZSBhIHR5cGVkZWYgdG9cblx0ICogc29tZSBraW5kIG9mIGludGVnZXIuIEhvd2V2ZXIsIHRob3NlIHNpemUgdHlwZXMgYXJlIGJ1aWx0IGlucy5cblx0ICovXG5cdGZvciAoaWkgPSAwOyBpaSA8IGN0Zl9kZWZ0eXBlcy5sZW5ndGg7IGlpKyspIHtcblx0XHRpZiAobmFtZSA9PSBjdGZfZGVmdHlwZXNbaWldKVxuXHRcdFx0cmV0dXJuO1xuXHR9XG5cblx0Y3R5cGUudHlwZWRlZihuYW1lLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gY3RmUGFyc2VTdHJ1Y3QoZW50cnksIGN0eXBlKVxue1xuXHR2YXIgbmFtZSwgdHlwZSwgaWksIHZhbCwgaW5kZXgsIG1lbWJlciwgcHVzaDtcblxuXHRtZW1iZXIgPSBbXTtcblx0aWYgKCFBcnJheS5pc0FycmF5KGVudHJ5WydzdHJ1Y3QnXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBzdHJ1Y3QgdmFsdWUgaXMgbm90ICcgK1xuXHRcdCAgICAnYW4gYXJyYXknKSk7XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwgZW50cnlbJ3N0cnVjdCddLmxlbmd0aDsgaWkrKykge1xuXHRcdHZhbCA9IGVudHJ5WydzdHJ1Y3QnXVtpaV07XG5cdFx0aWYgKCEoJ25hbWUnIGluIHZhbCkpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHN0cnVjdCBtZW1iZXIgJyArXG5cdFx0XHQgICAgJ21pc3NpbmcgbmFtZScpKTtcblxuXHRcdGlmICghKCd0eXBlJyBpbiB2YWwpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBzdHJ1Y3QgbWVtYmVyICcgK1xuXHRcdFx0ICAgICdtaXNzaW5nIHR5cGUnKSk7XG5cblx0XHRpZiAodHlwZW9mICh2YWxbJ25hbWUnXSkgIT0gJ3N0cmluZycpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHN0cnVjdCBtZW1iZXIgJyArXG5cdFx0XHQgICAgJ25hbWUgaXNuXFwndCBhIHN0cmluZycpKTtcblxuXHRcdGlmICh0eXBlb2YgKHZhbFsndHlwZSddKSAhPSAnc3RyaW5nJylcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogc3RydWN0IG1lbWJlciAnICtcblx0XHRcdCAgICAndHlwZSBpc25cXCd0IGEgc3RyaW5nJykpO1xuXG5cdFx0Lypcblx0XHQgKiBDVEYgdmVyc2lvbiAyIHNwZWNpZmllcyBhcnJheSBuYW1lcyBhcyA8dHlwZT4gWzxudW0+XSB3aGVyZVxuXHRcdCAqIGFzIG5vZGUtY3R5cGUgZG9lcyB0aGlzIGFzIDx0eXBlPls8bnVtPl0uXG5cdFx0ICovXG5cdFx0bmFtZSA9IHZhbFsnbmFtZSddO1xuXHRcdHR5cGUgPSB2YWxbJ3R5cGUnXTtcblx0XHRpbmRleCA9IHR5cGUuaW5kZXhPZignIFsnKTtcblx0XHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHRcdHR5cGUgPSB0eXBlLnN1YnN0cmluZygwLCBpbmRleCkgK1xuXHRcdFx0ICAgIHR5cGUuc3Vic3RyaW5nKGluZGV4ICsgMSwgdHlwZS5sZW5ndGgpO1xuXHRcdH1cblx0XHRwdXNoID0ge307XG5cdFx0cHVzaFtuYW1lXSA9IHsgJ3R5cGUnOiB0eXBlIH07XG5cdFx0bWVtYmVyLnB1c2gocHVzaCk7XG5cdH1cblxuXHRuYW1lID0gZW50cnlbJ25hbWUnXTtcblx0Y3R5cGUudHlwZWRlZihuYW1lLCBtZW1iZXIpO1xufVxuXG5mdW5jdGlvbiBjdGZQYXJzZUVudHJ5KGVudHJ5LCBjdHlwZSlcbntcblx0dmFyIGlpLCBmb3VuZDtcblxuXHRpZiAoISgnbmFtZScgaW4gZW50cnkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZW50cnkgbWlzc2luZyBcIm5hbWVcIiAnICtcblx0XHQgICAgJ3NlY3Rpb24nKSk7XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwgY3RmX2VudHJpZXMubGVuZ3RoOyBpaSsrKSB7XG5cdFx0aWYgKGN0Zl9lbnRyaWVzW2lpXSBpbiBlbnRyeSlcblx0XHRcdGZvdW5kKys7XG5cdH1cblxuXHRpZiAoZm91bmQgPT09IDApXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBmb3VuZCBubyBlbnRyaWVzJykpO1xuXG5cdGlmIChmb3VuZCA+PSAyKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZm91bmQgbW9yZSB0aGFuIG9uZSAnICtcblx0XHQgICAgJ2VudHJ5JykpO1xuXG5cdGlmICgnaW50ZWdlcicgaW4gZW50cnkpIHtcblx0XHRjdGZQYXJzZUludGVnZXIoZW50cnksIGN0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoJ2Zsb2F0JyBpbiBlbnRyeSkge1xuXHRcdGN0ZlBhcnNlRmxvYXQoZW50cnksIGN0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoJ3R5cGVkZWYnIGluIGVudHJ5KSB7XG5cdFx0Y3RmUGFyc2VUeXBlZGVmKGVudHJ5LCBjdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCdzdHJ1Y3QnIGluIGVudHJ5KSB7XG5cdFx0Y3RmUGFyc2VTdHJ1Y3QoZW50cnksIGN0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRBU1NFUlQoZmFsc2UsICdzaG91bGRuXFwndCByZWFjaCBoZXJlJyk7XG59XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlSnNvbihqc29uLCBjdHlwZSlcbntcblx0dmFyIHZlcnNpb24sIGlpO1xuXG5cdEFTU0VSVChqc29uKTtcblx0QVNTRVJUKGN0eXBlKTtcblx0aWYgKCEoJ21ldGFkYXRhJyBpbiBqc29uKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIENURiBKU09OOiBtaXNzaW5nIG1ldGFkYXRhIHNlY3Rpb24nKSk7XG5cblx0aWYgKCEoJ2N0ZjJqc29uX3ZlcnNpb24nIGluIGpzb25bJ21ldGFkYXRhJ10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgQ1RGIEpTT046IG1pc3NpbmcgY3RmMmpzb25fdmVyc2lvbicpKTtcblxuXHR2ZXJzaW9uID0ganNvblsnbWV0YWRhdGEnXVsnY3RmMmpzb25fdmVyc2lvbiddO1xuXHRmb3IgKGlpID0gMDsgaWkgPCBjdGZfdmVyc2lvbnMubGVuZ3RoOyBpaSsrKSB7XG5cdFx0aWYgKGN0Zl92ZXJzaW9uc1tpaV0gPT0gdmVyc2lvbilcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKGlpID09IGN0Zl92ZXJzaW9ucy5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBvcnRlZCBjdGYyanNvbl92ZXJzaW9uOiAnICsgdmVyc2lvbikpO1xuXG5cdGlmICghKCdkYXRhJyBpbiBqc29uKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIENURiBKU09OOiBtaXNzaW5nIGRhdGEgc2VjdGlvbicpKTtcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkoanNvblsnZGF0YSddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGRhdGEgc2VjdGlvbiBpcyBub3QgJyArXG5cdFx0ICAgICdhbiBhcnJheScpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBqc29uWydkYXRhJ10ubGVuZ3RoOyBpaSsrKVxuXHRcdGN0ZlBhcnNlRW50cnkoanNvblsnZGF0YSddW2lpXSwgY3R5cGUpO1xufVxuXG5leHBvcnRzLmN0ZlBhcnNlSnNvbiA9IGN0ZlBhcnNlSnNvbjtcbiIsIi8qXG4gKiBybSAtIEZlYiAyMDExXG4gKiBjdGlvLmpzOlxuICpcbiAqIEEgc2ltcGxlIHdheSB0byByZWFkIGFuZCB3cml0ZSBzaW1wbGUgY3R5cGVzLiBPZiBjb3Vyc2UsIGFzIHlvdSdsbCBmaW5kIHRoZVxuICogY29kZSBpc24ndCBhcyBzaW1wbGUgYXMgaXQgbWlnaHQgYXBwZWFyLiBUaGUgZm9sbG93aW5nIHR5cGVzIGFyZSBjdXJyZW50bHlcbiAqIHN1cHBvcnRlZCBpbiBiaWcgYW5kIGxpdHRsZSBlbmRpYW4gZm9ybWF0czpcbiAqXG4gKiBcdHVpbnQ4X3RcdFx0XHRpbnQ4X3RcbiAqIFx0dWludDE2X3RcdFx0aW50MTZfdFxuICogXHR1aW50MzJfdFx0XHRpbnQzMl90XG4gKlx0ZmxvYXQgKHNpbmdsZSBwcmVjaXNpb24gSUVFRSA3NTQpXG4gKlx0ZG91YmxlIChkb3VibGUgcHJlY2lzaW9uIElFRUUgNzU0KVxuICpcbiAqIFRoaXMgaXMgZGVzaWduZWQgdG8gd29yayBpbiBOb2RlIGFuZCB2OC4gSXQgbWF5IGluIGZhY3Qgd29yayBpbiBvdGhlclxuICogSmF2YXNjcmlwdCBpbnRlcnByZXRlcnMgKHRoYXQnZCBiZSBwcmV0dHkgbmVhdCksIGJ1dCBpdCBoYXNuJ3QgYmVlbiB0ZXN0ZWQuXG4gKiBJZiB5b3UgZmluZCB0aGF0IGl0IGRvZXMgaW4gZmFjdCB3b3JrLCB0aGF0J3MgcHJldHR5IGNvb2wuIFRyeSBhbmQgcGFzcyB3b3JkXG4gKiBiYWNrIHRvIHRoZSBvcmlnaW5hbCBhdXRob3IuXG4gKlxuICogTm90ZSB0byB0aGUgcmVhZGVyOiBJZiB5b3UncmUgdGFic3RvcCBpc24ndCBzZXQgdG8gOCwgcGFydHMgb2YgdGhpcyBtYXkgbG9va1xuICogd2VpcmQuXG4gKi9cblxuLypcbiAqIE51bWJlcnMgaW4gSmF2YXNjcmlwdCBoYXZlIGEgc2VjcmV0OiBhbGwgbnVtYmVycyBtdXN0IGJlIHJlcHJlc2VudGVkIHdpdGggYW5cbiAqIElFRUUtNzU0IGRvdWJsZS4gVGhlIGRvdWJsZSBoYXMgYSBtYW50aXNzYSB3aXRoIGEgbGVuZ3RoIG9mIDUyIGJpdHMgd2l0aCBhblxuICogaW1wbGljaXQgb25lLiBUaHVzIHRoZSByYW5nZSBvZiBpbnRlZ2VycyB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpcyBsaW1pdGVkXG4gKiB0byB0aGUgc2l6ZSBvZiB0aGUgbWFudGlzc2EsIHRoaXMgbWFrZXMgcmVhZGluZyBhbmQgd3JpdGluZyA2NC1iaXQgaW50ZWdlcnNcbiAqIGRpZmZpY3VsdCwgYnV0IGZhciBmcm9tIGltcG9zc2libGUuXG4gKlxuICogQW5vdGhlciBzaWRlIGVmZmVjdCBvZiB0aGlzIHJlcHJlc2VudGF0aW9uIGlzIHdoYXQgaGFwcGVucyB3aGVuIHlvdSB1c2UgdGhlXG4gKiBiaXR3aXNlIG9wZXJhdG9ycywgaS5lLiBzaGlmdCBsZWZ0LCBzaGlmdCByaWdodCwgYW5kLCBvciwgZXRjLiBJbiBKYXZhc2NyaXB0LFxuICogZWFjaCBvcGVyYW5kIGFuZCB0aGUgcmVzdWx0IGlzIGNhc3QgdG8gYSBzaWduZWQgMzItYml0IG51bWJlci4gSG93ZXZlciwgaW5cbiAqIHRoZSBjYXNlIG9mID4+PiB0aGUgdmFsdWVzIGFyZSBjYXN0IHRvIGFuIHVuc2lnbmVkIG51bWJlci5cbiAqL1xuXG4vKlxuICogQSByZW1pbmRlciBvbiBlbmRpYW4gcmVsYXRlZCBpc3N1ZXM6XG4gKlxuICogQmlnIEVuZGlhbjogTVNCIC0+IEZpcnN0IGJ5dGVcbiAqIExpdHRsZSBFbmRpYW46IE1TQi0+TGFzdCBieXRlXG4gKi9cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbi8qXG4gKiBBbiA4IGJpdCB1bnNpZ25lZCBpbnRlZ2VyIGludm9sdmVzIGRvaW5nIG5vIHNpZ25pZmljYW50IHdvcmsuXG4gKi9cbmZ1bmN0aW9uIHJ1aW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0cmV0dXJuIChidWZmZXJbb2Zmc2V0XSk7XG59XG5cbi8qXG4gKiBGb3IgMTYgYml0IHVuc2lnbmVkIG51bWJlcnMgd2UgY2FuIGRvIGFsbCB0aGUgY2FzdGluZyB0aGF0IHdlIHdhbnQgdG8gZG8uXG4gKi9cbmZ1bmN0aW9uIHJnaW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIHZhbCA9IDA7XG5cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDg7XG5cdFx0dmFsIHw9ICBidWZmZXJbb2Zmc2V0KzFdO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdHZhbCB8PSBidWZmZXJbb2Zmc2V0KzFdIDw8IDg7XG5cdH1cblxuXHRyZXR1cm4gKHZhbCk7XG5cbn1cblxuZnVuY3Rpb24gcnVpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMSA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHJldHVybiAocmdpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KSk7XG59XG5cbi8qXG4gKiBCZWNhdXNlIG1vc3QgYml0c2hpZnRpbmcgaXMgZG9uZSB1c2luZyBzaWduZWQgbnVtYmVycywgaWYgd2Ugd291bGQgZ28gaW50b1xuICogdGhlIHJlYWxtIHdoZXJlIHdlIHVzZSB0aGF0IDMybmQgYml0LCB3ZSdsbCBlbmQgdXAgZ29pbmcgaW50byB0aGUgbmVnYXRpdmVcbiAqIHJhbmdlLiBpLmUuOlxuICogPiAyMDAgPDwgMjRcbiAqIC05Mzk1MjQwOTZcbiAqXG4gKiBOb3QgdGhlIHZhbHVlIHlvdSdkIGV4cGVjdC4gVG8gd29yayBhcm91bmQgdGhpcywgd2UgZW5kIHVwIGhhdmluZyB0byBkbyBzb21lXG4gKiBhYnVzZSBvZiB0aGUgSmF2YVNjcmlwdCBzdGFuZGFyZC4gaW4gdGhpcyBjYXNlLCB3ZSBrbm93IHRoYXQgYSA+Pj4gc2hpZnQgaXNcbiAqIGRlZmluZWQgdG8gY2FzdCBvdXIgdmFsdWUgdG8gYW4gKnVuc2lnbmVkKiAzMi1iaXQgbnVtYmVyLiBCZWNhdXNlIG9mIHRoYXQsIHdlXG4gKiB1c2UgdGhhdCBpbnN0ZWFkIHRvIHNhdmUgdXMgc29tZSBhZGRpdGlvbmFsIG1hdGgsIHRob3VnaCBpdCBkb2VzIGZlZWwgYVxuICogbGl0dGxlIHdlaXJkIGFuZCBpdCBpc24ndCBvYnZpb3VzIGFzIHRvIHdoeSB5b3Ugd291bCBkd2FudCB0byBkbyB0aGlzIGF0XG4gKiBmaXJzdC5cbiAqL1xuZnVuY3Rpb24gcmdpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gMDtcblxuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0dmFsID0gYnVmZmVyW29mZnNldCsxXSA8PCAxNjtcblx0XHR2YWwgfD0gYnVmZmVyW29mZnNldCsyXSA8PCA4O1xuXHRcdHZhbCB8PSBidWZmZXJbb2Zmc2V0KzNdO1xuXHRcdHZhbCA9IHZhbCArIChidWZmZXJbb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gYnVmZmVyW29mZnNldCsyXSA8PCAxNjtcblx0XHR2YWwgfD0gYnVmZmVyW29mZnNldCsxXSA8PCA4O1xuXHRcdHZhbCB8PSBidWZmZXJbb2Zmc2V0XTtcblx0XHR2YWwgPSB2YWwgKyAoYnVmZmVyW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKTtcblx0fVxuXG5cdHJldHVybiAodmFsKTtcbn1cblxuZnVuY3Rpb24gcnVpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHJldHVybiAocmdpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KSk7XG59XG5cbi8qXG4gKiBSZWFkcyBhIDY0LWJpdCB1bnNpZ25lZCBudW1iZXIuIFRoZSBhc3R1ZSBvYnNlcnZlciB3aWxsIG5vdGUgdGhhdCB0aGlzXG4gKiBkb2Vzbid0IHF1aXRlIHdvcmsuIEphdmFzY3JpcHQgaGFzIGNob3NlbiB0byBvbmx5IGhhdmUgbnVtYmVycyB0aGF0IGNhbiBiZVxuICogcmVwcmVzZW50ZWQgYnkgYSBkb3VibGUuIEEgZG91YmxlIG9ubHkgaGFzIDUyIGJpdHMgb2YgbWFudGlzc2Egd2l0aCBhblxuICogaW1wbGljaXQgMSwgdGh1cyB3ZSBoYXZlIHVwIHRvIDUzIGJpdHMgdG8gcmVwcmVzZW50IGFuIGludGVnZXIuIEhvd2V2ZXIsIDJeNTNcbiAqIGRvZXNuJ3QgcXVpdGUgZ2l2ZSB1cyB3aGF0IHdlIHdhbnQuIElzbid0IDUzIGJpdHMgZW5vdWdoIGZvciBhbnlvbmU/IFdoYXRcbiAqIGNvdWxkIHlvdSBoYXZlIHBvc3NpYmx5IHdhbnRlZCB0byByZXByZXNlbnQgdGhhdCB3YXMgbGFyZ2VyIHRoYW4gdGhhdD8gT2gsXG4gKiBtYXliZSBhIHNpemU/IFlvdSBtZWFuIHdlIGJ5cGFzc2VkIHRoZSA0IEdCIGxpbWl0IG9uIGZpbGUgc2l6ZXMsIHdoZW4gZGlkXG4gKiB0aGF0IGhhcHBlbj9cbiAqXG4gKiBUbyBnZXQgYXJvdW5kIHRoaXMgZWdyZWdpb3VzIGxhbmd1YWdlIGlzc3VlLCB3ZSdyZSBnb2luZyB0byBpbnN0ZWFkIGNvbnN0cnVjdFxuICogYW4gYXJyYXkgb2YgdHdvIDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy4gV2hlcmUgYXJyWzBdIDw8IDMyICsgYXJyWzFdIHdvdWxkXG4gKiBnaXZlIHRoZSBhY3R1YWwgbnVtYmVyLiBIb3dldmVyLCBub3RlIHRoYXQgdGhlIGFib3ZlIGNvZGUgcHJvYmFibHkgd29uJ3RcbiAqIHByb2R1Y2UgdGhlIGRlc2lyZWQgcmVzdWx0cyBiZWNhdXNlIG9mIHRoZSB3YXkgSmF2YXNjcmlwdCBudW1iZXJzIGFyZVxuICogZG91Ymxlcy5cbiAqL1xuZnVuY3Rpb24gcmdpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbmV3IEFycmF5KDIpO1xuXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHR2YWxbMF0gPSBydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRcdHZhbFsxXSA9IHJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCs0KTtcblx0fSBlbHNlIHtcblx0XHR2YWxbMF0gPSBydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQrNCk7XG5cdFx0dmFsWzFdID0gcnVpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0fVxuXG5cdHJldHVybiAodmFsKTtcbn1cblxuZnVuY3Rpb24gcnVpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHJldHVybiAocmdpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KSk7XG59XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqXG4gKiBEb2luZyBpdCB0aGlzIHdheSBlbmRzIHVwIGFsbG93aW5nIHVzIHRvIHRyZWF0IGl0IGFwcHJvcHJpYXRlbHkgaW5cbiAqIEphdmFzY3JpcHQuIFNpZ2gsIHRoYXQncyByZWFsbHkgcXVpdGUgdWdseSBmb3Igd2hhdCBzaG91bGQganVzdCBiZSBhIGZldyBiaXRcbiAqIHNoaWZ0cywgfiBhbmQgJi5cbiAqL1xuXG4vKlxuICogRW5kaWFubmVzcyBkb2Vzbid0IG1hdHRlciBmb3IgOC1iaXQgc2lnbmVkIHZhbHVlcy4gV2UgY291bGQgaW4gZmFjdCBvcHRpbWl6ZVxuICogdGhpcyBjYXNlIGJlY2F1c2UgdGhlIG1vcmUgdHJhZGl0aW9uYWwgbWV0aG9kcyB3b3JrLCBidXQgZm9yIGNvbnNpc3RlbmN5LFxuICogd2UnbGwga2VlcCBkb2luZyB0aGlzIHRoZSBzYW1lIHdheS5cbiAqL1xuZnVuY3Rpb24gcnNpbnQ4KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBuZWc7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdG5lZyA9IGJ1ZmZlcltvZmZzZXRdICYgMHg4MDtcblx0aWYgKCFuZWcpXG5cdFx0cmV0dXJuIChidWZmZXJbb2Zmc2V0XSk7XG5cblx0cmV0dXJuICgoMHhmZiAtIGJ1ZmZlcltvZmZzZXRdICsgMSkgKiAtMSk7XG59XG5cbi8qXG4gKiBUaGUgMTYtYml0IHZlcnNpb24gcmVxdWlyZXMgYSBiaXQgbW9yZSBlZmZvcnQuIEluIHRoaXMgY2FzZSwgd2UgY2FuIGxldmVyYWdlXG4gKiBvdXIgdW5zaWduZWQgY29kZSB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgd2Ugd2FudCB0byByZXR1cm4uXG4gKi9cbmZ1bmN0aW9uIHJzaW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIG5lZywgdmFsO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAxID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcmdpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0bmVnID0gdmFsICYgMHg4MDAwO1xuXHRpZiAoIW5lZylcblx0XHRyZXR1cm4gKHZhbCk7XG5cblx0cmV0dXJuICgoMHhmZmZmIC0gdmFsICsgMSkgKiAtMSk7XG59XG5cbi8qXG4gKiBXZSByZWFsbHkgc2hvdWxkbid0IGxldmVyYWdlIG91ciAzMi1iaXQgY29kZSBoZXJlIGFuZCBpbnN0ZWFkIHV0aWxpemUgdGhlXG4gKiBmYWN0IHRoYXQgd2Uga25vdyB0aGF0IHNpbmNlIHRoZXNlIGFyZSBzaWduZWQgbnVtYmVycywgd2UgY2FuIGRvIGFsbCB0aGVcbiAqIHNoaWZ0aW5nIGFuZCBiaW5hcnkgYW5kaW5nIHRvIGdlbmVyYXRlIHRoZSAzMi1iaXQgbnVtYmVyLiBCdXQsIGZvclxuICogY29uc2lzdGVuY3kgd2UnbGwgZG8gdGhlIHNhbWUuIElmIHdlIHdhbnQgdG8gZG8gb3RoZXJ3aXNlLCB3ZSBzaG91bGQgaW5zdGVhZFxuICogbWFrZSB0aGUgMzIgYml0IHVuc2lnbmVkIGNvZGUgZG8gdGhlIG9wdGltaXphdGlvbi4gQnV0IGFzIGxvbmcgYXMgdGhlcmVcbiAqIGFyZW4ndCBmbG9hdHMgc2VjcmV0bHkgdW5kZXIgdGhlIGhvb2QgZm9yIHRoYXQsIHdlIC9zaG91bGQvIGJlIG9rYXkuXG4gKi9cbmZ1bmN0aW9uIHJzaW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIG5lZywgdmFsO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcmdpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0bmVnID0gdmFsICYgMHg4MDAwMDAwMDtcblx0aWYgKCFuZWcpXG5cdFx0cmV0dXJuICh2YWwpO1xuXG5cdHJldHVybiAoKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xKTtcbn1cblxuLypcbiAqIFRoZSBzaWduZWQgdmVyc2lvbiBvZiB0aGlzIGNvZGUgc3VmZmVycyBmcm9tIGFsbCBvZiB0aGUgc2FtZSBwcm9ibGVtcyBvZiB0aGVcbiAqIG90aGVyIDY0IGJpdCB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiByc2ludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBuZWcsIHZhbDtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHJnaW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdG5lZyA9IHZhbFswXSAmIDB4ODAwMDAwMDA7XG5cblx0aWYgKCFuZWcpXG5cdFx0cmV0dXJuICh2YWwpO1xuXG5cdHZhbFswXSA9ICgweGZmZmZmZmZmIC0gdmFsWzBdKSAqIC0xO1xuXHR2YWxbMV0gPSAoMHhmZmZmZmZmZiAtIHZhbFsxXSArIDEpICogLTE7XG5cblx0Lypcblx0ICogSWYgd2UgaGFkIHRoZSBrZXkgMHg4MDAwMDAwMDAwMDAwMDAwLCB0aGF0IHdvdWxkIGxlYXZlIHRoZSBsb3dlciAzMlxuXHQgKiBiaXRzIGFzIDB4ZmZmZmZmZmYsIGhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW50IHRvIGFkZCBvbmUsIHRoYXQgd291bGRcblx0ICogYWN0dWFsbHkgbGVhdmUgdGhlIGxvd2VyIDMyLWJpdHMgYXMgMHgxMDAwMDAwMDAsIHdoaWNoIHdvdWxkIGJyZWFrXG5cdCAqIG91ciBhYmlsaXR5IHRvIHdyaXRlIGJhY2sgYSB2YWx1ZSB0aGF0IHdlIHJlY2VpdmVkLiBUbyB3b3JrIGFyb3VuZFxuXHQgKiB0aGlzLCBpZiB3ZSBhY3R1YWxseSBnZXQgdGhhdCB2YWx1ZSwgd2UncmUgZ29pbmcgdG8gYnVtcCB0aGUgdXBwZXJcblx0ICogcG9ydGlvbiBieSAxIGFuZCBzZXQgdGhpcyB0byB6ZXJvLlxuXHQgKi9cblx0bW9kX2Fzc2VydC5vayh2YWxbMV0gPD0gMHgxMDAwMDAwMDApO1xuXHRpZiAodmFsWzFdID09IC0weDEwMDAwMDAwMCkge1xuXHRcdHZhbFsxXSA9IDA7XG5cdFx0dmFsWzBdLS07XG5cdH1cblxuXHRyZXR1cm4gKHZhbCk7XG59XG5cbi8qXG4gKiBXZSBub3cgbW92ZSBvbnRvIElFRUUgNzU0OiBUaGUgdHJhZGl0aW9uYWwgZm9ybSBmb3IgZmxvYXRpbmcgcG9pbnQgbnVtYmVyc1xuICogYW5kIHdoYXQgaXMgc2VjcmV0bHkgaGlkaW5nIGF0IHRoZSBoZWFydCBvZiBldmVyeXRoaW5nIGluIHRoaXMuIEkgcmVhbGx5IGhvcGVcbiAqIHRoYXQgc29tZW9uZSBpcyBhY3R1YWxseSB1c2luZyB0aGlzLCBhcyBvdGhlcndpc2UsIHRoaXMgZWZmb3J0IGlzIHByb2JhYmx5XG4gKiBnb2luZyB0byBiZSBtb3JlIHdhc3RlZC5cbiAqXG4gKiBPbmUgbWlnaHQgYmUgdGVtcHRlZCB0byB1c2UgcGFyc2VGbG9hdCBoZXJlLCBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGF0IGFsbFxuICogZm9yIHNldmVyYWwgcmVhc29ucy4gTW9zdGx5IGR1ZSB0byB0aGUgd2F5IGZsb2F0cyBhY3R1YWxseSB3b3JrLCBhbmRcbiAqIHBhcnNlRmxvYXQgb25seSBhY3R1YWxseSB3b3JrcyBpbiBiYXNlIDEwLiBJIGRvbid0IHNlZSBiYXNlIDEwIGFueXdoZXJlIG5lYXJcbiAqIHRoaXMgZmlsZS5cbiAqXG4gKiBJbiB0aGlzIGNhc2Ugd2UnbGwgaW1wbGVtZW50IHRoZSBzaW5nbGUgYW5kIGRvdWJsZSBwcmVjaXNpb24gdmVyc2lvbnMuIFRoZVxuICogcXVhZHJ1cGxlIHByZWNpc2lvbiwgd2hpbGUgcHJvYmFibHkgdXNlZnVsLCB3b3VsZG4ndCByZWFsbHkgYmUgYWNjZXB0ZWQgYnlcbiAqIEphdmFzY3JpcHQsIHNvIGxldCdzIG5vdCBldmVuIHdhc3RlIG91ciB0aW1lLlxuICpcbiAqIFNvIGxldCdzIHJldmlldyBob3cgdGhpcyBmb3JtYXQgbG9va3MgbGlrZS4gQSBzaW5nbGUgcHJlY2lzaW9uIHZhbHVlIGlzIDMyXG4gKiBiaXRzIGFuZCBoYXMgdGhyZWUgcGFydHM6XG4gKiAgIC0gIFNpZ24gYml0XG4gKiAgIC0gIEV4cG9uZW50IChVc2luZyBiaWFzIG5vdGF0aW9uKVxuICogICAtICBNYW50aXNzYVxuICpcbiAqIHxzfGVlZWVlZWVlfG1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW18XG4gKiAzMXwgMzAtMjMgIHwgIDIyICAgIFx0LSAgICAgICAwICAgICAgIHxcbiAqXG4gKiBUaGUgZXhwb25lbnQgaXMgc3RvcmVkIGluIGEgYmlhc2VkIGlucHV0LiBUaGUgYmlhcyBpbiB0aGlzIGNhc2UgMTI3LlxuICogVGhlcmVmb3JlLCBvdXIgZXhwb25lbnQgaXMgZXF1YWwgdG8gdGhlIDgtYml0IHZhbHVlIC0gMTI3LlxuICpcbiAqIEJ5IGRlZmF1bHQsIGEgbnVtYmVyIGlzIG5vcm1hbGl6ZWQgaW4gSUVFRSwgdGhhdCBtZWFucyB0aGF0IHRoZSBtYW50aXNzYSBoYXNcbiAqIGFuIGltcGxpY2l0IG9uZSB0aGF0IHdlIGRvbid0IHNlZS4gU28gcmVhbGx5IHRoZSB2YWx1ZSBzdG9yZWQgaXMgMS5tLlxuICogSG93ZXZlciwgaWYgdGhlIGV4cG9uZW50IGlzIGFsbCB6ZXJvcywgdGhlbiBpbnN0ZWFkIHdlIGhhdmUgdG8gc2hpZnRcbiAqIGV2ZXJ5dGhpbmcgdG8gdGhlIHJpZ2h0IG9uZSBhbmQgdGhlcmUgaXMgbm8gbW9yZSBpbXBsaWNpdCBvbmUuXG4gKlxuICogU3BlY2lhbCB2YWx1ZXM6XG4gKiAgLSBQb3NpdGl2ZSBJbmZpbml0eTpcbiAqXHRTaWduOlx0XHQwXG4gKlx0RXhwb25lbnQ6IFx0QWxsIDFzXG4gKlx0TWFudGlzc2E6XHQwXG4gKiAgLSBOZWdhdGl2ZSBJbmZpbml0eTpcbiAqXHRTaWduOlx0XHQxXG4gKlx0RXhwb25lbnQ6IFx0QWxsIDFzXG4gKlx0TWFudGlzc2E6XHQwXG4gKiAgLSBOYU46XG4gKlx0U2lnbjpcdFx0KlxuICpcdEV4cG9uZW50OiBcdEFsbCAxc1xuICpcdE1hbnRpc3NhOlx0bm9uLXplcm9cbiAqICAtIFplcm86XG4gKlx0U2lnbjpcdFx0KlxuICpcdEV4cG9uZW50Olx0QWxsIDBzXG4gKlx0TWFudGlzc2E6XHQwXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgemVybywgdGhlIHNpZ24gYml0IGRldGVybWluZXMgd2hldGhlciB3ZSBnZXQgYSBwb3NpdGl2ZSBvclxuICogbmVnYXRpdmUgemVyby4gSG93ZXZlciwgc2luY2UgSmF2YXNjcmlwdCBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBkaWZmZXJlbmNlXG4gKiBiZXR3ZWVuIHRoZSB0d286IGkuZS4gLTAgPT0gMCwgd2UganVzdCBhbHdheXMgcmV0dXJuIDAuXG4gKlxuICovXG5mdW5jdGlvbiByZmxvYXQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIGJ5dGVzID0gW107XG5cdHZhciBzaWduLCBleHBvbmVudCwgbWFudGlzc2EsIHZhbDtcblx0dmFyIGJpYXMgPSAxMjc7XG5cdHZhciBtYXhleHAgPSAweGZmO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0LyogTm9ybWFsaXplIHRoZSBieXRlcyB0byBiZSBpbiBlbmRpYW4gb3JkZXIgKi9cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ5dGVzWzBdID0gYnVmZmVyW29mZnNldF07XG5cdFx0Ynl0ZXNbMV0gPSBidWZmZXJbb2Zmc2V0KzFdO1xuXHRcdGJ5dGVzWzJdID0gYnVmZmVyW29mZnNldCsyXTtcblx0XHRieXRlc1szXSA9IGJ1ZmZlcltvZmZzZXQrM107XG5cdH0gZWxzZSB7XG5cdFx0Ynl0ZXNbM10gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRieXRlc1syXSA9IGJ1ZmZlcltvZmZzZXQrMV07XG5cdFx0Ynl0ZXNbMV0gPSBidWZmZXJbb2Zmc2V0KzJdO1xuXHRcdGJ5dGVzWzBdID0gYnVmZmVyW29mZnNldCszXTtcblx0fVxuXG5cdHNpZ24gPSBieXRlc1swXSAmIDB4ODA7XG5cdGV4cG9uZW50ID0gKGJ5dGVzWzBdICYgMHg3ZikgPDwgMTtcblx0ZXhwb25lbnQgfD0gKGJ5dGVzWzFdICYgMHg4MCkgPj4+IDc7XG5cdG1hbnRpc3NhID0gKGJ5dGVzWzFdICYgMHg3ZikgPDwgMTY7XG5cdG1hbnRpc3NhIHw9IGJ5dGVzWzJdIDw8IDg7XG5cdG1hbnRpc3NhIHw9IGJ5dGVzWzNdO1xuXG5cdC8qIENoZWNrIGZvciBzcGVjaWFsIGNhc2VzIGJlZm9yZSB3ZSBkbyBnZW5lcmFsIHBhcnNpbmcgKi9cblx0aWYgKCFzaWduICYmIGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cblx0aWYgKHNpZ24gJiYgZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblxuXHRpZiAoZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhICE9PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLk5hTik7XG5cblx0Lypcblx0ICogSmF2YXNjcmlwdCByZWFsbHkgZG9lc24ndCBoYXZlIHN1cHBvcnQgZm9yIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIHplcm8uXG5cdCAqIFNvIHdlJ3JlIG5vdCBnb2luZyB0byB0cnkgYW5kIGdpdmUgaXQgdG8geW91LiBUaGF0IHdvdWxkIGJlIGp1c3Rcblx0ICogcGxhaW4gd2VpcmQuIEJlc2lkZXMgLTAgPT0gMC5cblx0ICovXG5cdGlmIChleHBvbmVudCA9PT0gMCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKDApO1xuXG5cdC8qXG5cdCAqIE5vdyB3ZSBjYW4gZGVhbCB3aXRoIHRoZSBiaWFzIGFuZCB0aGUgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG1hbnRpc3NhXG5cdCAqIGhhcyB0aGUgaW1wbGljaXQgb25lIG9yIG5vdC5cblx0ICovXG5cdGV4cG9uZW50IC09IGJpYXM7XG5cdGlmIChleHBvbmVudCA9PSAtYmlhcykge1xuXHRcdGV4cG9uZW50Kys7XG5cdFx0dmFsID0gMDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSAxO1xuXHR9XG5cblx0dmFsID0gKHZhbCArIG1hbnRpc3NhICogTWF0aC5wb3coMiwgLTIzKSkgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG5cblx0aWYgKHNpZ24pXG5cdFx0dmFsICo9IC0xO1xuXG5cdHJldHVybiAodmFsKTtcbn1cblxuLypcbiAqIERvdWJsZXMgaW4gSUVFRSA3NTQgYXJlIGxpa2UgdGhlaXIgYnJvdGhlcnMgZXhjZXB0IGZvciBhIGZldyBjaGFuZ2VzIGFuZFxuICogaW5jcmVhc2VzIGluIHNpemU6XG4gKiAgIC0gVGhlIGV4cG9uZW50IGlzIG5vdyAxMSBiaXRzXG4gKiAgIC0gVGhlIG1hbnRpc3NhIGlzIG5vdyA1MiBiaXRzXG4gKiAgIC0gVGhlIGJpYXMgaXMgbm93IDEwMjNcbiAqXG4gKiB8c3xlZWVlZWVlZWVlZXxtbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tfFxuICogNjN8IDYyIC0gNTIgICB8IFx0NTFcdFx0LVx0XHRcdDAgICAgIHxcbiAqIDYzfCA2MiAtIDUyICAgfCAgICAgIDUxICAgICAgICAgICAgICAtICAgICAgICAgICAgICAgICAgICAgICAwICAgICB8XG4gKlxuICogV2hpbGUgdGhlIHNpemUgaGFzIGluY3JlYXNlZCBhIGZhaXIgYW1vdW50LCB3ZSdyZSBnb2luZyB0byBlbmQgdXAga2VlcGluZyB0aGVcbiAqIHNhbWUgZ2VuZXJhbCBmb3JtdWxhIGZvciBjYWxjdWxhdGluZyB0aGUgZmluYWwgdmFsdWUuIEFzIGEgcmVtaW5kZXIsIHRoaXNcbiAqIGZvcm11bGEgaXM6XG4gKlxuICogKC0xKV5zICogKG4gKyBtKSAqIDJeKGUtYilcbiAqXG4gKiBXaGVyZTpcbiAqXHRzXHRpcyB0aGUgc2lnbiBiaXRcbiAqXHRuXHRpcyAoZXhwb25lbnQgPiAwKSA/IDEgOiAwIC0tIERldGVybWluZXMgd2hldGhlciB3ZSdyZSBub3JtYWxpemVkXG4gKlx0XHRcdFx0XHQgICAgIG9yIG5vdFxuICpcdG1cdGlzIHRoZSBtYW50aXNzYVxuICpcdGVcdGlzIHRoZSBleHBvbmVudCBzcGVjaWZpZWRcbiAqXHRiXHRpcyB0aGUgYmlhcyBmb3IgdGhlIGV4cG9uZW50XG4gKlxuICovXG5mdW5jdGlvbiByZG91YmxlKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBieXRlcyA9IFtdO1xuXHR2YXIgc2lnbiwgZXhwb25lbnQsIG1hbnRpc3NhLCB2YWwsIGxvd21hbnQ7XG5cdHZhciBiaWFzID0gMTAyMztcblx0dmFyIG1heGV4cCA9IDB4N2ZmO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyA3ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0LyogTm9ybWFsaXplIHRoZSBieXRlcyB0byBiZSBpbiBlbmRpYW4gb3JkZXIgKi9cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ5dGVzWzBdID0gYnVmZmVyW29mZnNldF07XG5cdFx0Ynl0ZXNbMV0gPSBidWZmZXJbb2Zmc2V0KzFdO1xuXHRcdGJ5dGVzWzJdID0gYnVmZmVyW29mZnNldCsyXTtcblx0XHRieXRlc1szXSA9IGJ1ZmZlcltvZmZzZXQrM107XG5cdFx0Ynl0ZXNbNF0gPSBidWZmZXJbb2Zmc2V0KzRdO1xuXHRcdGJ5dGVzWzVdID0gYnVmZmVyW29mZnNldCs1XTtcblx0XHRieXRlc1s2XSA9IGJ1ZmZlcltvZmZzZXQrNl07XG5cdFx0Ynl0ZXNbN10gPSBidWZmZXJbb2Zmc2V0KzddO1xuXHR9IGVsc2Uge1xuXHRcdGJ5dGVzWzddID0gYnVmZmVyW29mZnNldF07XG5cdFx0Ynl0ZXNbNl0gPSBidWZmZXJbb2Zmc2V0KzFdO1xuXHRcdGJ5dGVzWzVdID0gYnVmZmVyW29mZnNldCsyXTtcblx0XHRieXRlc1s0XSA9IGJ1ZmZlcltvZmZzZXQrM107XG5cdFx0Ynl0ZXNbM10gPSBidWZmZXJbb2Zmc2V0KzRdO1xuXHRcdGJ5dGVzWzJdID0gYnVmZmVyW29mZnNldCs1XTtcblx0XHRieXRlc1sxXSA9IGJ1ZmZlcltvZmZzZXQrNl07XG5cdFx0Ynl0ZXNbMF0gPSBidWZmZXJbb2Zmc2V0KzddO1xuXHR9XG5cblx0Lypcblx0ICogV2UgY2FuIGNvbnN0cnVjdCB0aGUgZXhwb25lbnQgYW5kIG1hbnRpc3NhIHRoZSBzYW1lIHdheSBhcyB3ZSBkaWQgaW5cblx0ICogdGhlIGNhc2Ugb2YgYSBmbG9hdCwganVzdCBpbmNyZWFzZSB0aGUgcmFuZ2Ugb2YgdGhlIGV4cG9uZW50LlxuXHQgKi9cblx0c2lnbiA9IGJ5dGVzWzBdICYgMHg4MDtcblx0ZXhwb25lbnQgPSAoYnl0ZXNbMF0gJiAweDdmKSA8PCA0O1xuXHRleHBvbmVudCB8PSAoYnl0ZXNbMV0gJiAweGYwKSA+Pj4gNDtcblxuXHQvKlxuXHQgKiBUaGlzIGlzIGdvaW5nIHRvIGJlIHVnbHkgYnV0IHRoZW4gYWdhaW4sIHdlJ3JlIGRlYWxpbmcgd2l0aCBJRUVFIDc1NC5cblx0ICogVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBkb25lIGFzIGEgbm9kZSBhZGQgb24gaW4gYSBmZXcgbGluZXMgb2YgQysrLFxuXHQgKiBidXQgb2ggd2UnbGwsIHdlJ3ZlIG1hZGUgaXQgdGhpcyBmYXIgc28gbGV0J3MgYmUgbmF0aXZlIHRoZSByZXN0IG9mXG5cdCAqIHRoZSB3YXkuLi5cblx0ICpcblx0ICogV2hhdCB3ZSdyZSBnb2luZyB0byBkbyBpcyBicmVhayB0aGUgbWFudGlzc2EgaW50byB0d28gcGFydHMsIHRoZVxuXHQgKiBsb3dlciAyNCBiaXRzIGFuZCB0aGUgdXBwZXIgMjggYml0cy4gV2UnbGwgbXVsdGlwbHkgdGhlIHVwcGVyIDI4IGJpdHNcblx0ICogYnkgdGhlIGFwcHJvcHJpYXRlIHBvd2VyIGFuZCB0aGVuIGFkZCBpbiB0aGUgbG93ZXIgMjQtYml0cy4gTm90XG5cdCAqIHJlYWxseSB0aGF0IGdyZWF0LiBJdCdzIHByZXR0eSBtdWNoIGEgZ2lhbnQga2x1ZGdlIHRvIGRlYWwgd2l0aFxuXHQgKiBKYXZhc2NyaXB0IGVjY2VudHJpY2l0aWVzIGFyb3VuZCBudW1iZXJzLlxuXHQgKi9cblx0bG93bWFudCA9IGJ5dGVzWzddO1xuXHRsb3dtYW50IHw9IGJ5dGVzWzZdIDw8IDg7XG5cdGxvd21hbnQgfD0gYnl0ZXNbNV0gPDwgMTY7XG5cdG1hbnRpc3NhID0gYnl0ZXNbNF07XG5cdG1hbnRpc3NhIHw9IGJ5dGVzWzNdIDw8IDg7XG5cdG1hbnRpc3NhIHw9IGJ5dGVzWzJdIDw8IDE2O1xuXHRtYW50aXNzYSB8PSAoYnl0ZXNbMV0gJiAweDBmKSA8PCAyNDtcblx0bWFudGlzc2EgKj0gTWF0aC5wb3coMiwgMjQpOyAvKiBFcXVpdmFsZW50IHRvIDw8IDI0LCBidXQgSlMgY29tcGF0ICovXG5cdG1hbnRpc3NhICs9IGxvd21hbnQ7XG5cblx0LyogQ2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgYmVmb3JlIHdlIGRvIGdlbmVyYWwgcGFyc2luZyAqL1xuXHRpZiAoIXNpZ24gJiYgZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuXHRpZiAoc2lnbiAmJiBleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuXG5cdGlmIChleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgIT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuTmFOKTtcblxuXHQvKlxuXHQgKiBKYXZhc2NyaXB0IHJlYWxseSBkb2Vzbid0IGhhdmUgc3VwcG9ydCBmb3IgcG9zaXRpdmUgb3IgbmVnYXRpdmUgemVyby5cblx0ICogU28gd2UncmUgbm90IGdvaW5nIHRvIHRyeSBhbmQgZ2l2ZSBpdCB0byB5b3UuIFRoYXQgd291bGQgYmUganVzdFxuXHQgKiBwbGFpbiB3ZWlyZC4gQmVzaWRlcyAtMCA9PSAwLlxuXHQgKi9cblx0aWYgKGV4cG9uZW50ID09PSAwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoMCk7XG5cblx0Lypcblx0ICogTm93IHdlIGNhbiBkZWFsIHdpdGggdGhlIGJpYXMgYW5kIHRoZSBkZXRlcm1pbmUgd2hldGhlciB0aGUgbWFudGlzc2Fcblx0ICogaGFzIHRoZSBpbXBsaWNpdCBvbmUgb3Igbm90LlxuXHQgKi9cblx0ZXhwb25lbnQgLT0gYmlhcztcblx0aWYgKGV4cG9uZW50ID09IC1iaWFzKSB7XG5cdFx0ZXhwb25lbnQrKztcblx0XHR2YWwgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IDE7XG5cdH1cblxuXHR2YWwgPSAodmFsICsgbWFudGlzc2EgKiBNYXRoLnBvdygyLCAtNTIpKSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcblxuXHRpZiAoc2lnbilcblx0XHR2YWwgKj0gLTE7XG5cblx0cmV0dXJuICh2YWwpO1xufVxuXG4vKlxuICogTm93IHRoYXQgd2UgaGF2ZSBnb25lIHRocm91Z2ggdGhlIHBhaW4gb2YgcmVhZGluZyB0aGUgaW5kaXZpZHVhbCB0eXBlcywgd2UncmVcbiAqIHByb2JhYmx5IGdvaW5nIHRvIHdhbnQgc29tZSB3YXkgdG8gd3JpdGUgdGhlc2UgYmFjay4gTm9uZSBvZiB0aGlzIGlzIGdvaW5nIHRvXG4gKiBiZSBnb29kLiBCdXQgc2luY2Ugd2UgaGF2ZSBKYXZhc2NyaXB0IG51bWJlcnMgdGhpcyBzaG91bGQgY2VydGFpbmx5IGJlIG1vcmVcbiAqIGludGVyZXN0aW5nLiBUaG91Z2ggd2UgY2FuIGNvbnN0cmFpbiB0aGlzIGVuZCBhIGxpdHRsZSBiaXQgbW9yZSBpbiB3aGF0IGlzXG4gKiB2YWxpZC4gRm9yIG5vdywgbGV0J3MgZ28gYmFjayB0byBvdXIgZnJpZW5kcyB0aGUgdW5zaWduZWQgdmFsdWUuXG4gKi9cblxuLypcbiAqIFVuc2lnbmVkIG51bWJlcnMgc2VlbSBkZWNlcHRpdmVseSBlYXN5LiBIZXJlIGFyZSB0aGUgZ2VuZXJhbCBzdGVwcyBhbmQgcnVsZXNcbiAqIHRoYXQgd2UgYXJlIGdvaW5nIHRvIHRha2U6XG4gKiAgIC0gIElmIHRoZSBudW1iZXIgaXMgbmVnYXRpdmUsIHRocm93IGFuIEVycm9yXG4gKiAgIC0gIFRydW5jYXRlIGFueSBmbG9hdGluZyBwb2ludCBwb3J0aW9uXG4gKiAgIC0gIFRha2UgdGhlIG1vZHVsdXMgb2YgdGhlIG51bWJlciBpbiBvdXIgYmFzZVxuICogICAtICBXcml0ZSBpdCBvdXQgdG8gdGhlIGJ1ZmZlciBpbiB0aGUgZW5kaWFuIGZvcm1hdCByZXF1ZXN0ZWQgYXQgdGhlIG9mZnNldFxuICovXG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdCBpc1xuICogbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3QgZXhjZWVkIHRoZVxuICogbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICpcbiAqXHR2YWx1ZVx0XHRUaGUgbnVtYmVyIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICpcbiAqXHRtYXhcdFx0VGhlIG1heGltdW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHJlcHVpbnQodmFsdWUsIG1heClcbntcblx0aWYgKHR5cGVvZiAodmFsdWUpICE9ICdudW1iZXInKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJykpKTtcblxuXHRpZiAodmFsdWUgPCAwKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuICcgK1xuXHRcdCAgICAndW5zaWduZWQgdmFsdWUnKSk7XG5cblx0aWYgKHZhbHVlID4gbWF4KVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yICcgK1xuXHRcdCAgICAndHlwZScpKTtcblxuXHRpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50JykpO1xuXG5cdHJldHVybiAodmFsdWUpO1xufVxuXG4vKlxuICogOC1iaXQgdmVyc2lvbiwgY2xhc3N5LiBXZSBjYW4gaWdub3JlIGVuZGlhbm5lc3Mgd2hpY2ggaXMgZ29vZC5cbiAqL1xuZnVuY3Rpb24gd3VpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXB1aW50KHZhbHVlLCAweGZmKTtcblx0YnVmZmVyW29mZnNldF0gPSB2YWw7XG59XG5cbi8qXG4gKiBQcmV0dHkgbXVjaCB0aGUgc2FtZSBhcyB0aGUgOC1iaXQgdmVyc2lvbiwganVzdCB0aGlzIHRpbWUgd2UgbmVlZCB0byB3b3JyeVxuICogYWJvdXQgZW5kaWFuIHJlbGF0ZWQgaXNzdWVzLlxuICovXG5mdW5jdGlvbiB3Z2ludDE2KHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gKHZhbCAmIDB4ZmYwMCkgPj4+IDg7XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9IHZhbCAmIDB4MDBmZjtcblx0fSBlbHNlIHtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gKHZhbCAmIDB4ZmYwMCkgPj4+IDg7XG5cdFx0YnVmZmVyW29mZnNldF0gPSB2YWwgJiAweDAwZmY7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3VpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAxID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHVpbnQodmFsdWUsIDB4ZmZmZik7XG5cdHdnaW50MTYodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIFRoZSAzMi1iaXQgdmVyc2lvbiBpcyBnb2luZyB0byBoYXZlIHRvIGJlIGEgbGl0dGxlIGRpZmZlcmVudCB1bmZvcnR1bmF0ZWx5LlxuICogV2UgY2FuJ3QgcXVpdGUgYml0c2hpZnQgdG8gZ2V0IHRoZSBsYXJnZXN0IGJ5dGUsIGJlY2F1c2UgdGhhdCB3b3VsZCBlbmQgdXBcbiAqIGdldHRpbmcgdXMgY2F1Z2h0IGJ5IHRoZSBzaWduZWQgdmFsdWVzLlxuICpcbiAqIEFuZCB5ZXMsIHdlIGRvIHdhbnQgdG8gc3VidHJhY3Qgb3V0IHRoZSBsb3dlciBwYXJ0IGJ5IGRlZmF1bHQuIFRoaXMgbWVhbnNcbiAqIHRoYXQgd2hlbiB3ZSBkbyB0aGUgZGl2aXNpb24sIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGJpdCBzaGlmdCBhbmQgd2Ugd29uJ3RcbiAqIGVuZCB1cCBnZW5lcmF0aW5nIGEgZmxvYXRpbmcgcG9pbnQgdmFsdWUuIElmIHdlIGRpZCBnZW5lcmF0ZSBhIGZsb2F0aW5nIHBvaW50XG4gKiB2YWx1ZSB3ZSdkIGhhdmUgdG8gdHJ1bmNhdGUgaXQgaW50ZWxsaWdlbnRseSwgdGhpcyBzYXZlcyB1cyB0aGF0IHByb2JsZW0gYW5kXG4gKiBtYXkgZXZlbiBiZSBzb21ld2hhdCBmYXN0ZXIgdW5kZXIgdGhlIGhvb2QuXG4gKi9cbmZ1bmN0aW9uIHdnaW50MzIodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0YnVmZmVyW29mZnNldF0gPSAodmFsIC0gKHZhbCAmIDB4MDBmZmZmZmYpKSAvIE1hdGgucG93KDIsIDI0KTtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gKHZhbCA+Pj4gMTYpICYgMHhmZjtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gKHZhbCA+Pj4gOCkgJiAweGZmO1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSB2YWwgJiAweGZmO1xuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSAodmFsIC0gKHZhbCAmIDB4MDBmZmZmZmYpKSAvXG5cdFx0ICAgIE1hdGgucG93KDIsIDI0KTtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gKHZhbCA+Pj4gMTYpICYgMHhmZjtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gKHZhbCA+Pj4gOCkgJiAweGZmO1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gdmFsICYgMHhmZjtcblx0fVxufVxuXG5mdW5jdGlvbiB3dWludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG5cdHdnaW50MzIodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIFVubGlrZSB0aGUgb3RoZXIgdmVyc2lvbnMsIHdlIGV4cGVjdCB0aGUgdmFsdWUgdG8gYmUgaW4gdGhlIGZvcm0gb2YgdHdvXG4gKiBhcnJheXMgd2hlcmUgdmFsdWVbMF0gPDwgMzIgKyB2YWx1ZVsxXSB3b3VsZCByZXN1bHQgaW4gdGhlIHZhbHVlIHRoYXQgd2VcbiAqIHdhbnQuXG4gKi9cbmZ1bmN0aW9uIHdnaW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHR3Z2ludDMyKHZhbHVlWzBdLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHR3Z2ludDMyKHZhbHVlWzFdLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KzQpO1xuXHR9IGVsc2Uge1xuXHRcdHdnaW50MzIodmFsdWVbMF0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQrNCk7XG5cdFx0d2dpbnQzMih2YWx1ZVsxXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3VpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5JykpO1xuXG5cdGlmICh2YWx1ZS5sZW5ndGggIT0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyA3ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0cHJlcHVpbnQodmFsdWVbMF0sIDB4ZmZmZmZmZmYpO1xuXHRwcmVwdWludCh2YWx1ZVsxXSwgMHhmZmZmZmZmZik7XG5cdHdnaW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKlx0d2UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgb2ZmIHRvIHRoZSBlcXVpdmFsZW50IHd1aW50XG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAqXHR3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICpcdG1iICsgdmFsICsgMSwgd2hlcmVcbiAqXHRtYlx0aXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqXHR2YWxcdGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICpcbiAqIFRodXMgdGhlIG92ZXJhbGwgZmxvdyBpczpcbiAqICAgLSAgVHJ1bmNhdGUgdGhlIGZsb2F0aW5nIHBvaW50IHBhcnQgb2YgdGhlIG51bWJlclxuICogICAtICBXZSBkb24ndCBoYXZlIHRvIHRha2UgdGhlIG1vZHVsdXMsIGJlY2F1c2UgdGhlIHVuc2lnbmVkIHZlcnNpb25zIHdpbGxcbiAqICAgXHR0YWtlIGNhcmUgb2YgdGhhdCBmb3IgdXMuIEFuZCB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRoYXRcbiAqICAgXHRwb3RlbnRpYWxseSBjYXVzaW5nIGJhZCB0aGluZ3MgdG8gaGFwcGVuIGJlY2F1c2Ugb2Ygc2lnbiBleHRlbnNpb25cbiAqICAgLSAgUGFzcyBpdCBvZmYgdG8gdGhlIGFwcHJvcHJpYXRlIHVuc2lnbmVkIHZlcnNpb24sIHBvdGVudGlhbGx5IG1vZGlmeWluZ1xuICpcdHRoZSBuZWdhdGl2ZSBwb3J0aW9ucyBhcyBuZWNlc3NhcnkuXG4gKi9cblxuLypcbiAqIEEgc2VyaWVzIG9mIGNoZWNrcyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHNpZ25lZCAzMi1iaXQgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIHByZXBzaW50KHZhbHVlLCBtYXgsIG1pbilcbntcblx0aWYgKHR5cGVvZiAodmFsdWUpICE9ICdudW1iZXInKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJykpKTtcblxuXHRpZiAodmFsdWUgPiBtYXgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJykpO1xuXG5cdGlmICh2YWx1ZSA8IG1pbilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJykpO1xuXG5cdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKSk7XG5cblx0cmV0dXJuICh2YWx1ZSk7XG59XG5cbi8qXG4gKiBUaGUgOC1iaXQgdmVyc2lvbiBvZiB0aGUgc2lnbmVkIHZhbHVlLiBPdmVyYWxsLCBmYWlybHkgc3RyYWlnaHRmb3J3YXJkLlxuICovXG5mdW5jdGlvbiB3c2ludDgodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcblx0aWYgKHZhbCA+PSAwKVxuXHRcdHd1aW50OCh2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRlbHNlXG5cdFx0d3VpbnQ4KDB4ZmYgKyB2YWwgKyAxLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIFRoZSAxNi1iaXQgdmVyc2lvbiBvZiB0aGUgc2lnbmVkIHZhbHVlLiBBbHNvLCBmYWlybHkgc3RyYWlnaHRmb3J3YXJkLlxuICovXG5mdW5jdGlvbiB3c2ludDE2KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDEgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcblx0aWYgKHZhbCA+PSAwKVxuXHRcdHdnaW50MTYodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0ZWxzZVxuXHRcdHdnaW50MTYoMHhmZmZmICsgdmFsICsgMSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cbn1cblxuLypcbiAqIFdlIGNhbiBkbyB0aGlzIHJlbGF0aXZlbHkgZWFzaWx5IGJ5IGxldmVyYWdpbmcgdGhlIGNvZGUgdXNlZCBmb3IgMzItYml0XG4gKiB1bnNpZ25lZCBjb2RlLlxuICovXG5mdW5jdGlvbiB3c2ludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuXHRpZiAodmFsID49IDApXG5cdFx0d2dpbnQzMih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRlbHNlXG5cdFx0d2dpbnQzMigweGZmZmZmZmZmICsgdmFsICsgMSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBUaGUgc2lnbmVkIDY0IGJpdCBpbnRlZ2VyIHNob3VsZCBieSBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgd2hlbiByZWNlaXZlZC5cbiAqIE1haW5seSBpdCBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGFycmF5IG9mIHR3byBpbnRlZ2VycyB3aGVyZVxuICogdmFsdWVbMF0gPDwgMzIgKyB2YWx1ZVsxXSBpcyB0aGUgZGVzaXJlZCBudW1iZXIuIEZ1cnRoZXJtb3JlLCB0aGUgdHdvIHZhbHVlc1xuICogbmVlZCB0byBiZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gd3NpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZ6cG9zLCB2b3Bvcztcblx0dmFyIHZhbHMgPSBuZXcgQXJyYXkoMik7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5JykpO1xuXG5cdGlmICh2YWx1ZS5sZW5ndGggIT0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyA3ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0Lypcblx0ICogV2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBzYW1lIHNpZ24gb24gYm90aCB2YWx1ZXMuIFRoZVxuXHQgKiBob2tpZXN0IHdheSB0byB0byBkbyB0aGlzIGlzIHRvIG11bHRpcGx5IHRoZSBudW1iZXIgYnkgK2luZi4gSWYgd2UgZG9cblx0ICogdGhpcywgd2UnbGwgZ2V0IGVpdGhlciArLy1pbmYgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cblx0ICogT25jZSB3ZSBoYXZlIHRoaXMsIHdlIGNhbiBjb21wYXJlIGl0IHRvICtpbmYgdG8gc2VlIGlmIHRoZSBudW1iZXIgaXNcblx0ICogcG9zaXRpdmUgb3Igbm90LlxuXHQgKi9cblx0dnpwb3MgPSAodmFsdWVbMF0gKiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpID09XG5cdCAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdHZvcG9zID0gKHZhbHVlWzFdICogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSA9PVxuXHQgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdC8qXG5cdCAqIElmIGVpdGhlciBvZiB0aGVzZSBpcyB6ZXJvLCB0aGVuIHdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdGhpcyBjaGVjay5cblx0ICovXG5cdGlmICh2YWx1ZVswXSAhPSAwICYmIHZhbHVlWzFdICE9IDAgJiYgdnpwb3MgIT0gdm9wb3MpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignQm90aCBlbnRyaWVzIGluIHRoZSBhcnJheSBtdXN0IGhhdmUgJyArXG5cdFx0ICAgICd0aGUgc2FtZSBzaWduJykpO1xuXG5cdC8qXG5cdCAqIERvaW5nIHZlcmlmaWNhdGlvbiBmb3IgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaXMgYWN0dWFsbHkgYSBiaWdcblx0ICogdHJpY2tpZXIgdGhhbiBpdCBhcHBlYXJzLiBXZSBjYW4ndCBxdWl0ZSB1c2Ugb3VyIHN0YW5kYXJkIHRlY2huaXF1ZXNcblx0ICogYmVjYXVzZSB3ZSBuZWVkIHRvIGNvbXBhcmUgYm90aCBzZXRzIG9mIHZhbHVlcy4gVGhlIGZpcnN0IHZhbHVlIGlzXG5cdCAqIHByZXR0eSBzdHJhaWdodGZvcndhcmQuIElmIHRoZSBmaXJzdCB2YWx1ZSBpcyBiZW9uZCB0aGUgZXh0cmVtZXMgdGhhblxuXHQgKiB3ZSBlcnJvciBvdXQuIEhvd2V2ZXIsIHRoZSB2YWxpZCByYW5nZSBvZiB0aGUgc2Vjb25kIHZhbHVlIHZhcmllc1xuXHQgKiBiYXNlZCBvbiB0aGUgZmlyc3Qgb25lLiBJZiB0aGUgZmlyc3QgdmFsdWUgaXMgbmVnYXRpdmUsIGFuZCAqbm90KiB0aGVcblx0ICogbGFyZ2VzdCBuZWdhdGl2ZSB2YWx1ZSwgdGhhbiBpdCBjYW4gYmUgYW55IGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBbXG5cdCAqIDAsIDB4ZmZmZmZmZmYgXS4gSWYgaXQgaXMgdGhlIGxhcmdlc3QgbmVnYXRpdmUgbnVtYmVyLCBpdCBtdXN0IGJlXG5cdCAqIHplcm8uXG5cdCAqXG5cdCAqIElmIHRoZSBmaXJzdCBudW1iZXIgaXMgcG9zaXRpdmUsIHRoYW4gaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGVcblx0ICogdmFsdWUgaXMuIFdlIGp1c3Qgc2ltcGx5IGhhdmUgdG8gbWFrZSBzdXJlIHdlIGhhdmUgYSB2YWxpZCBwb3NpdGl2ZVxuXHQgKiBpbnRlZ2VyLlxuXHQgKi9cblx0aWYgKHZ6cG9zKSB7XG5cdFx0cHJlcHVpbnQodmFsdWVbMF0sIDB4N2ZmZmZmZmYpO1xuXHRcdHByZXB1aW50KHZhbHVlWzFdLCAweGZmZmZmZmZmKTtcblx0fSBlbHNlIHtcblx0XHRwcmVwc2ludCh2YWx1ZVswXSwgMCwgLTB4ODAwMDAwMDApO1xuXHRcdHByZXBzaW50KHZhbHVlWzFdLCAwLCAtMHhmZmZmZmZmZik7XG5cdFx0aWYgKHZhbHVlWzBdID09IC0weDgwMDAwMDAwICYmIHZhbHVlWzFdICE9IDApXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSAnICtcblx0XHRcdCAgICAnYWxsb3dlZCB2YWx1ZScpKTtcblx0fVxuXG5cdC8qIEZpeCBuZWdhdGl2ZSBudW1iZXJzICovXG5cdGlmICh2YWx1ZVswXSA8IDAgfHwgdmFsdWVbMV0gPCAwKSB7XG5cdFx0dmFsc1swXSA9IDB4ZmZmZmZmZmYgLSBNYXRoLmFicyh2YWx1ZVswXSk7XG5cdFx0dmFsc1sxXSA9IDB4MTAwMDAwMDAwIC0gTWF0aC5hYnModmFsdWVbMV0pO1xuXHRcdGlmICh2YWxzWzFdID09IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHR2YWxzWzFdID0gMDtcblx0XHRcdHZhbHNbMF0rKztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dmFsc1swXSA9IHZhbHVlWzBdO1xuXHRcdHZhbHNbMV0gPSB2YWx1ZVsxXTtcblx0fVxuXHR3Z2ludDY0KHZhbHMsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogTm93IHdlIGFyZSBtb3Zpbmcgb250byB0aGUgd2VpcmRlciBvZiB0aGVzZSwgdGhlIGZsb2F0IGFuZCBkb3VibGUuIEZvciB0aGlzXG4gKiB3ZSdyZSBnb2luZyB0byBqdXN0IGhhdmUgdG8gZG8gc29tZXRoaW5nIHRoYXQncyBwcmV0dHkgd2VpcmQuIEZpcnN0IG9mZiwgd2VcbiAqIGhhdmUgbm8gd2F5IHRvIGdldCBhdCB0aGUgdW5kZXJseWluZyBmbG9hdCByZXByZXNlbnRhdGlvbiwgYXQgbGVhc3Qgbm90XG4gKiBlYXNpbHkuIEJ1dCB0aGF0IGRvZXNuJ3QgbWVhbiB3ZSBjYW4ndCBmaWd1cmUgaXQgb3V0LCB3ZSBqdXN0IGhhdmUgdG8gdXNlIG91clxuICogaGVhZHMuXG4gKlxuICogT25lIG1pZ2h0IHByb3Bvc2UgdG8gdXNlIE51bWJlci50b1N0cmluZygyKS4gT2YgY291cnNlLCB0aGlzIGlzIG5vdCByZWFsbHlcbiAqIHRoYXQgZ29vZCwgYmVjYXVzZSB0aGUgRUNNQVNjcmlwdCAyNjIgdjMgU3RhbmRhcmQgc2F5cyB0aGUgZm9sbG93aW5nIFNlY3Rpb25cbiAqIDE1LjcuNC4yLU51bWJlci5wcm90b3R5cGUudG9TdHJpbmcgKHJhZGl4KTpcbiAqXG4gKiBJZiByYWRpeCBpcyBhbiBpbnRlZ2VyIGZyb20gMiB0byAzNiwgYnV0IG5vdCAxMCwgdGhlIHJlc3VsdCBpcyBhIHN0cmluZywgdGhlXG4gKiBjaG9pY2Ugb2Ygd2hpY2ggaXMgaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LlxuICpcbiAqIFdlbGwgdGhhdCBkb2Vzbid0IHJlYWxseSBoZWxwIHVzIG9uZSBiaXQgbm93IGRvZXMgaXQ/IFdlIGNvdWxkIHVzZSB0aGVcbiAqIHN0YW5kYXJkIGJhc2UgMTAgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLCBidXQgdGhhdCdzIGp1c3QgZ29pbmcgdG8gY3JlYXRlIG1vcmVcbiAqIGVycm9ycyBhcyB3ZSBlbmQgdXAgdHJ5aW5nIHRvIGNvbnZlcnQgaXQgYmFjayB0byBhIGJpbmFyeSB2YWx1ZS4gU28sIHJlYWxseVxuICogdGhpcyBqdXN0IG1lYW5zIHdlIGhhdmUgdG8gYmUgbm9uLWxhenkgYW5kIHBhcnNlIHRoZSBzdHJ1Y3R1cmUgaW50ZWxsaWdlbnRseS5cbiAqXG4gKiBGaXJzdCBvZmYsIHdlIGNhbiBkbyB0aGUgYmFzaWMgY2hlY2tzOiBOYU4sIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBpbmZpbml0eS5cbiAqXG4gKiBOb3cgdGhhdCB0aG9zZSBhcmUgZG9uZSB3ZSBjYW4gd29yayBiYWNrd2FyZHMgdG8gZ2VuZXJhdGUgdGhlIG1hbnRpc3NhIGFuZFxuICogZXhwb25lbnQuXG4gKlxuICogVGhlIGZpcnN0IHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgZGV0ZXJtaW5lIHRoZSBzaWduIGJpdCwgZWFzeSB0byBkbywgY2hlY2tcbiAqIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGxlc3MgdGhhbiAwLiBBbmQgY29udmVydCB0aGUgbnVtYmVyIHRvIGl0cyBhYnNvbHV0ZVxuICogdmFsdWUgcmVwcmVzZW50YXRpb24uIE5leHQsIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW5cbiAqIG9uZSBvciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gb25lIGFuZCBmcm9tIHRoZXJlIGRldGVybWluZSB3aGF0IHBvd2VyIHdhc1xuICogdXNlZCB0byBnZXQgdGhlcmUuIFdoYXQgZm9sbG93cyBpcyBub3cgc3BlY2lmaWMgdG8gZmxvYXRzLCB0aG91Z2ggdGhlIGdlbmVyYWxcbiAqIGlkZWFzIGJlaGluZCB0aGlzIHdpbGwgaG9sZCBmb3IgZG91YmxlcyBhcyB3ZWxsLCBidXQgdGhlIGV4YWN0IG51bWJlcnNcbiAqIGludm9sdmVkIHdpbGwgY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgaGF2ZSB0aGF0IHBvd2VyIHdlIGNhbiBkZXRlcm1pbmUgdGhlIGV4cG9uZW50IGFuZCB0aGUgbWFudGlzc2EuIENhbGxcbiAqIHRoZSB2YWx1ZSB0aGF0IGhhcyB0aGUgbnVtYmVyIG9mIGJpdHMgdG8gcmVhY2ggdGhlIHBvd2VyIGViaXRzLiBJbiB0aGVcbiAqIGdlbmVyYWwgY2FzZSB0aGV5IGhhdmUgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICpcdGV4cG9uZW50XHQxMjcgKyBlYml0c1xuICpcdG1hbnRpc3NhXHR2YWx1ZSAqIDJeKDIzIC0gZWJpdHMpICYgMHg3ZmZmZmZcbiAqXG4gKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgdmFsdWUgb2YgZWJpdHMgaXMgPD0gLTEyNyB3ZSBhcmUgbm93IGluIHRoZSBjYXNlIHdoZXJlXG4gKiB3ZSBubyBsb25nZXIgaGF2ZSBub3JtYWxpemVkIG51bWJlcnMuIEluIHRoaXMgY2FzZSB0aGUgdmFsdWVzIHRha2Ugb24gdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqIFx0ZXhwb25lbnRcdDBcbiAqXHRtYW50aXNzYVx0dmFsdWUgKiAyXjE0OSAmIDB4N2ZmZmZmXG4gKlxuICogT25jZSB3ZSBoYXZlIHRoZSB2YWx1ZXMgZm9yIHRoZSBzaWduLCBtYW50aXNzYSwgYW5kIGV4cG9uZW50LiBXZSByZWNvbnN0cnVjdFxuICogdGhlIGZvdXIgYnl0ZXMgYXMgZm9sbG93czpcbiAqXG4gKlx0Ynl0ZTBcdFx0c2lnbiBiaXQgYW5kIHNldmVuIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmcm9tIHRoZSBleHBcbiAqXHRcdFx0c2lnbiA8PCA3IHwgKGV4cG9uZW50ICYgMHhmZSkgPj4+IDFcbiAqXG4gKlx0Ynl0ZTFcdFx0bHNiIGZyb20gdGhlIGV4cG9uZW50IGFuZCA3IHRvcCBiaXRzIGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdChleHBvbmVudCAmIDB4MDEpIDw8IDcgfCAobWFudGlzc2EgJiAweDdmMDAwMCkgPj4+IDE2XG4gKlxuICpcdGJ5dGUyXHRcdGJpdHMgOC0xNSAoemVybyBpbmRleGluZykgZnJvbSBtYW50aXNzYVxuICpcdFx0XHRtYW50aXNzYSAmIDB4ZmYwMCA+PiA4XG4gKlxuICpcdGJ5dGUzXHRcdGJpdHMgMC03IGZyb20gbWFudGlzc2FcbiAqXHRcdFx0bWFudGlzc2EgJiAweGZmXG4gKlxuICogT25jZSB3ZSBoYXZlIHRoaXMgd2UgaGF2ZSB0byBhc3NpZ24gdGhlbSBpbnRvIHRoZSBidWZmZXIgaW4gcHJvcGVyIGVuZGlhblxuICogb3JkZXIuXG4gKi9cblxuLypcbiAqIENvbXB1dGUgdGhlIGxvZyBiYXNlIDIgb2YgdGhlIHZhbHVlLiBOb3csIHNvbWVvbmUgd2hvIHJlbWVtYmVycyBiYXNpY1xuICogcHJvcGVydGllcyBvZiBsb2dhcml0aG1zIHdpbGwgcG9pbnQgb3V0IHRoYXQgd2UgY291bGQgdXNlIHRoZSBjaGFuZ2Ugb2YgYmFzZVxuICogZm9ybXVsYSBmb3IgbG9ncywgYW5kIGluIGZhY3QgdGhhdCB3b3VsZCBiZSBhc3R1dGUsIGJlY2F1c2UgdGhhdCdzIHdoYXQgd2UnbGxcbiAqIGRvIGZvciBub3cuIEl0IGZlZWxzIGNsZWFuZXIsIGFsYmVpdCBpdCBtYXkgYmUgbGVzcyBlZmZpY2llbnQgdGhhbiBqdXN0XG4gKiBpdGVyYXRpbmcgYW5kIGRpdmlkaW5nIGJ5IDIuIFdlIG1heSB3YW50IHRvIGNvbWUgYmFjayBhbmQgcmV2aXNpdCB0aGF0IHNvbWVcbiAqIGRheS5cbiAqL1xuZnVuY3Rpb24gbG9nMih2YWx1ZSlcbntcblx0cmV0dXJuIChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZygyKSk7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHRoZSBleHBvbmVudCBvZiB0aGUgbnVtYmVyIHdlJ3JlIGxvb2tpbmcgYXQuXG4gKi9cbmZ1bmN0aW9uIGludGV4cCh2YWx1ZSlcbntcblx0cmV0dXJuIChNYXRoLmZsb29yKGxvZzIodmFsdWUpKSk7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZXJtaW5lIHRoZSBleHBvbmVudCBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZnJhY2V4cCh2YWx1ZSlcbntcblx0cmV0dXJuIChNYXRoLmZsb29yKGxvZzIodmFsdWUpKSk7XG59XG5cbmZ1bmN0aW9uIHdmbG9hdCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHNpZ24sIGV4cG9uZW50LCBtYW50aXNzYSwgZWJpdHM7XG5cdHZhciBieXRlcyA9IFtdO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdGlmIChpc05hTih2YWx1ZSkpIHtcblx0XHRzaWduID0gMDtcblx0XHRleHBvbmVudCA9IDB4ZmY7XG5cdFx0bWFudGlzc2EgPSAyMztcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcblx0XHRzaWduID0gMDtcblx0XHRleHBvbmVudCA9IDB4ZmY7XG5cdFx0bWFudGlzc2EgPSAwO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuXHRcdHNpZ24gPSAxO1xuXHRcdGV4cG9uZW50ID0gMHhmZjtcblx0XHRtYW50aXNzYSA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0LyogV2VsbCB3ZSBoYXZlIHNvbWUgd29yayB0byBkbyAqL1xuXG5cdFx0LyogVGhhbmtmdWxseSB0aGUgc2lnbiBiaXQgaXMgdHJpdmlhbCAqL1xuXHRcdGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdHNpZ24gPSAxO1xuXHRcdFx0dmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpZ24gPSAwO1xuXHRcdH1cblxuXHRcdC8qIFVzZSB0aGUgY29ycmVjdCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIGJpdHMgKi9cblx0XHRpZiAodmFsdWUgPCAxKVxuXHRcdFx0ZWJpdHMgPSBmcmFjZXhwKHZhbHVlKTtcblx0XHRlbHNlXG5cdFx0XHRlYml0cyA9IGludGV4cCh2YWx1ZSk7XG5cblx0XHQvKiBUaW1lIHRvIGRlYWwgd2l0aCB0aGUgaXNzdWVzIHN1cnJvdW5kaW5nIG5vcm1hbGl6YXRpb24gKi9cblx0XHRpZiAoZWJpdHMgPD0gLTEyNykge1xuXHRcdFx0ZXhwb25lbnQgPSAwO1xuXHRcdFx0bWFudGlzc2EgPSAodmFsdWUgKiBNYXRoLnBvdygyLCAxNDkpKSAmIDB4N2ZmZmZmO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvbmVudCA9IDEyNyArIGViaXRzO1xuXHRcdFx0bWFudGlzc2EgPSB2YWx1ZSAqIE1hdGgucG93KDIsIDIzIC0gZWJpdHMpO1xuXHRcdFx0bWFudGlzc2EgJj0gMHg3ZmZmZmY7XG5cdFx0fVxuXHR9XG5cblx0Ynl0ZXNbMF0gPSBzaWduIDw8IDcgfCAoZXhwb25lbnQgJiAweGZlKSA+Pj4gMTtcblx0Ynl0ZXNbMV0gPSAoZXhwb25lbnQgJiAweDAxKSA8PCA3IHwgKG1hbnRpc3NhICYgMHg3ZjAwMDApID4+PiAxNjtcblx0Ynl0ZXNbMl0gPSAobWFudGlzc2EgJiAweDAwZmYwMCkgPj4+IDg7XG5cdGJ5dGVzWzNdID0gbWFudGlzc2EgJiAweDAwMDBmZjtcblxuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0YnVmZmVyW29mZnNldF0gPSBieXRlc1swXTtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gYnl0ZXNbMV07XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9IGJ5dGVzWzJdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSBieXRlc1szXTtcblx0fSBlbHNlIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IGJ5dGVzWzNdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSBieXRlc1syXTtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gYnl0ZXNbMV07XG5cdFx0YnVmZmVyW29mZnNldCszXSA9IGJ5dGVzWzBdO1xuXHR9XG59XG5cbi8qXG4gKiBOb3cgd2UgbW92ZSBvbnRvIGRvdWJsZXMuIERvdWJsZXMgYXJlIHNpbWlsYXIgdG8gZmxvYXRzIGluIHByZXR0eSBtdWNoIGFsbFxuICogd2F5cyBleGNlcHQgdGhhdCB0aGUgcHJvY2Vzc2luZyBpc24ndCBxdWl0ZSBhcyBzdHJhaWdodGZvcndhcmQgYmVjYXVzZSB3ZVxuICogY2FuJ3QgYWx3YXlzIHVzZSBzaGlmdGluZywgaS5lLiB3ZSBoYXZlID4gMzIgYml0IHZhbHVlcy5cbiAqXG4gKiBXZSdyZSBnb2luZyB0byBwcm9jZWVkIGluIGFuIGlkZW50aWNhbCBmYXNoaW9uIHRvIGZsb2F0cyBhbmQgdXRpbGl6ZSB0aGUgc2FtZVxuICogaGVscGVyIGZ1bmN0aW9ucy4gQWxsIHRoYXQgcmVhbGx5IGlzIGNoYW5naW5nIGFyZSB0aGUgc3BlY2lmaWMgdmFsdWVzIHRoYXQgd2VcbiAqIHVzZSB0byBkbyB0aGUgY2FsY3VsYXRpb25zLiBUaHVzLCB0byByZXZpZXcgd2UgaGF2ZSB0byBkbyB0aGUgZm9sbG93aW5nLlxuICpcbiAqIEZpcnN0IGdldCB0aGUgc2lnbiBiaXQgYW5kIGNvbnZlcnQgdGhlIHZhbHVlIHRvIGl0cyBhYnNvbHV0ZSB2YWx1ZVxuICogcmVwcmVzZW50YXRpb24uIE5leHQsIHdlIGRldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdHMgdGhhdCB3ZSB1c2VkIHRvIGdldCB0b1xuICogdGhlIHZhbHVlLCBicmFuY2hpbmcgd2hldGhlciB0aGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGxlc3MgdGhhbiAxLiBPbmNlXG4gKiB3ZSBoYXZlIHRoYXQgdmFsdWUgd2hpY2ggd2Ugd2lsbCBhZ2FpbiBjYWxsIGViaXRzLCB3ZSBoYXZlIHRvIGRvIHRoZVxuICogZm9sbG93aW5nIGluIHRoZSBnZW5lcmFsIGNhc2U6XG4gKlxuICpcdGV4cG9uZW50XHQxMDIzICsgZWJpdHNcbiAqXHRtYW50aXNzYVx0W3ZhbHVlICogMl4oNTIgLSBlYml0cyldICUgMl41MlxuICpcbiAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSB2YWx1ZSBvZiBlYml0cyA8PSAtMTAyMyB3ZSBubyBsb25nZXIgdXNlIG5vcm1hbGl6ZWRcbiAqIG51bWJlcnMsIHRodXMgbGlrZSB3aXRoIGZsb2F0cyB3ZSBoYXZlIHRvIGRvIHNsaWdodGx5IGRpZmZlcmVudCBwcm9jZXNzaW5nOlxuICpcbiAqXHRleHBvbmVudFx0MFxuICpcdG1hbnRpc3NhXHRbdmFsdWUgKiAyXjEwNzRdICUgMl41MlxuICpcbiAqIE9uY2Ugd2UgaGF2ZSBkZXRlcm1pbmVkIHRoZSBzaWduLCBleHBvbmVudCBhbmQgbWFudGlzc2Egd2UgY2FuIGNvbnN0cnVjdCB0aGVcbiAqIGJ5dGVzIGFzIGZvbGxvd3M6XG4gKlxuICpcdGJ5dGUwXHRcdHNpZ24gYml0IGFuZCBzZXZlbiBtb3N0IHNpZ25pZmljYW50IGJpdHMgZm9ybSB0aGUgZXhwXG4gKlx0XHRcdHNpZ24gPDwgNyB8IChleHBvbmVudCAmIDB4N2YwKSA+Pj4gNFxuICpcbiAqXHRieXRlMVx0XHRSZW1haW5pbmcgNCBiaXRzIGZyb20gdGhlIGV4cG9uZW50IGFuZCB0aGUgZm91ciBtb3N0XG4gKlx0XHRcdHNpZ25pZmljYW50IGJpdHMgZnJvbSB0aGUgbWFudGlzc2EgNDgtNTFcbiAqXHRcdFx0KGV4cG9uZW50ICYgMHgwMGYpIDw8IDQgfCBtYW50aXNzYSA+Pj4gNDhcbiAqXG4gKlx0Ynl0ZTJcdFx0Qml0cyA0MC00NyBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHQobWFudGlzc2EgPj4+IDQwKSAmIDB4ZmZcbiAqXG4gKlx0Ynl0ZTNcdFx0Qml0cyAzMi0zOSBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHQobWFudGlzc2EgPj4+IDMyKSAmIDB4ZmZcbiAqXG4gKlx0Ynl0ZTRcdFx0Qml0cyAyNC0zMSBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHQobWFudGlzc2EgPj4+IDI0KSAmIDB4ZmZcbiAqXG4gKlx0Ynl0ZTVcdFx0Qml0cyAxNi0yMyBmcm9tIHRoZSBNYW50aXNzYVxuICpcdFx0XHQobWFudGlzc2EgPj4+IDE2KSAmIDB4ZmZcbiAqXG4gKlx0Ynl0ZTZcdFx0Qml0cyA4LTE1IGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdChtYW50aXNzYSA+Pj4gOCkgJiAweGZmXG4gKlxuICpcdGJ5dGU3XHRcdEJpdHMgMC03IGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdG1hbnRpc3NhICYgMHhmZlxuICpcbiAqIE5vdyB3ZSBjYW4ndCBxdWl0ZSBkbyB0aGUgcmlnaHQgc2hpZnRpbmcgdGhhdCB3ZSB3YW50IGluIGJ5dGVzIDEgLSAzLCBiZWNhdXNlXG4gKiB3ZSdsbCBoYXZlIGV4dGVuZGVkIHRvbyBmYXIgYW5kIHdlJ2xsIGxvc2UgdGhvc2UgdmFsdWVzIHdoZW4gd2UgdHJ5IGFuZCBkb1xuICogdGhlIHNoaWZ0LiBJbnN0ZWFkIHdlIGhhdmUgdG8gdXNlIGFuIGFsdGVybmF0ZSBhcHByb2FjaC4gVG8gdHJ5IGFuZCBzdGF5IG91dFxuICogb2YgZmxvYXRpbmcgcG9pbnQsIHdoYXQgd2UnbGwgZG8gaXMgc2F5IHRoYXQgbWFudGlzc2EgLT0gYnl0ZXNbNC03XSBhbmQgdGhlblxuICogZGl2aWRlIGJ5IDJeMzIuIE9uY2Ugd2UndmUgZG9uZSB0aGF0IHdlIGNhbiB1c2UgYmluYXJ5IGFyaXRobWV0aWMuIE9vZixcbiAqIHRoYXQncyB1Z2x5LCBidXQgaXQgc2VlbXMgdG8gYXZvaWQgdXNpbmcgZmxvYXRpbmcgcG9pbnQgKGp1c3QgYmFzZWQgb24gaG93IHY4XG4gKiBzZWVtcyB0byBiZSBvcHRpbWl6aW5nIGZvciBiYXNlIDIgYXJpdGhtZXRpYykuXG4gKi9cbmZ1bmN0aW9uIHdkb3VibGUodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBzaWduLCBleHBvbmVudCwgbWFudGlzc2EsIGViaXRzO1xuXHR2YXIgYnl0ZXMgPSBbXTtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cblx0aWYgKG9mZnNldCArIDcgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0c2lnbiA9IDA7XG5cdFx0ZXhwb25lbnQgPSAweDdmZjtcblx0XHRtYW50aXNzYSA9IDIzO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuXHRcdHNpZ24gPSAwO1xuXHRcdGV4cG9uZW50ID0gMHg3ZmY7XG5cdFx0bWFudGlzc2EgPSAwO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuXHRcdHNpZ24gPSAxO1xuXHRcdGV4cG9uZW50ID0gMHg3ZmY7XG5cdFx0bWFudGlzc2EgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdC8qIFdlbGwgd2UgaGF2ZSBzb21lIHdvcmsgdG8gZG8gKi9cblxuXHRcdC8qIFRoYW5rZnVsbHkgdGhlIHNpZ24gYml0IGlzIHRyaXZpYWwgKi9cblx0XHRpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRzaWduID0gMTtcblx0XHRcdHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaWduID0gMDtcblx0XHR9XG5cblx0XHQvKiBVc2UgdGhlIGNvcnJlY3QgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIG51bWJlciBvZiBiaXRzICovXG5cdFx0aWYgKHZhbHVlIDwgMSlcblx0XHRcdGViaXRzID0gZnJhY2V4cCh2YWx1ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0ZWJpdHMgPSBpbnRleHAodmFsdWUpO1xuXG5cdFx0Lypcblx0XHQgKiBUaGlzIGlzIGEgdG90YWwgaGFjayB0byBkZXRlcm1pbmUgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG5cdFx0ICogVW5mb3J0dW5hdGVseSwgd2Ugc29tZXRpbWVzIGRvIG5vdCBnZXQgYSBwcm9wZXIgdmFsdWUgZm9yXG5cdFx0ICogZWJpdHMsIGkuZS4gd2UgbG9zZSB0aGUgdmFsdWVzIHRoYXQgd291bGQgZ2V0IHJvdW5kZWQgb2ZmLlxuXHRcdCAqXG5cdFx0ICpcblx0XHQgKiBUaGUgYXN0dXRlIG9ic2VydmVyIG1heSB3b25kZXIgd2h5IHdlIHdvdWxkIGJlXG5cdFx0ICogbXVsdGlwbHlpbmcgYnkgdHdvIE1hdGgucG93cyByYXRoZXIgdGhhbiBqdXN0IHN1bW1pbmdcblx0XHQgKiB0aGVtLiBXZWxsLCB0aGF0J3MgdG8gZ2V0IGFyb3VuZCBhIHNtYWxsIGJ1ZyBpbiB0aGVcblx0XHQgKiB3YXkgdjggc2VlbXMgdG8gaW1wbGVtZW50IHRoZSBmdW5jdGlvbi4gT24gb2NjYXNpb25cblx0XHQgKiBkb2luZzpcblx0XHQgKlxuXHRcdCAqIGZvbyAqIE1hdGgucG93KDIsIDEwMjMgKyA1MSlcblx0XHQgKlxuXHRcdCAqIENhdXNlcyB1cyB0byBvdmVyZmxvdyB0byBpbmZpbml0eSwgd2hlcmUgYXMgZG9pbmc6XG5cdFx0ICpcblx0XHQgKiBmb28gKiBNYXRoLnBvdygyLCAxMDIzKSAqIE1hdGgucG93KDIsIDUxKVxuXHRcdCAqXG5cdFx0ICogRG9lcyBub3QgY2F1c2UgdXMgdG8gb3ZlcmZsb3cuIEdvIGZpZ3VyZS5cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGlmICh2YWx1ZSA8PSAyLjIyNTA3Mzg1ODUwNzIwMWUtMzA4IHx8IGViaXRzIDw9IC0xMDIzKSB7XG5cdFx0XHRleHBvbmVudCA9IDA7XG5cdFx0XHRtYW50aXNzYSA9IHZhbHVlICogTWF0aC5wb3coMiwgMTAyMykgKiBNYXRoLnBvdygyLCA1MSk7XG5cdFx0XHRtYW50aXNzYSAlPSBNYXRoLnBvdygyLCA1Mik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qXG5cdFx0XHQgKiBXZSBtaWdodCBoYXZlIGdvdHRlbiBmdWNrZWQgYnkgb3VyIGZsb2F0aW5nIHBvaW50XG5cdFx0XHQgKiBsb2dhcml0aG0gbWFnaWMuIFRoaXMgaXMgcmF0aGVyIGNyYXBweSwgYnV0IHRoYXQnc1xuXHRcdFx0ICogb3VyIGx1Y2suIElmIHdlIGp1c3QgaGFkIGEgbG9nIGJhc2UgMiBvciBhY2Nlc3MgdG9cblx0XHRcdCAqIHRoZSBzdHVwaWQgdW5kZXJseWluZyByZXByZXNlbnRhdGlvbiB0aGlzIHdvdWxkIGhhdmVcblx0XHRcdCAqIGJlZW4gbXVjaCBlYXNpZXIgYW5kIHdlIHdvdWxkbid0IGhhdmUgc3VjaCBzdHVwaWRcblx0XHRcdCAqIGtsdWRnZXMgb3IgaGFja3MuXG5cdFx0XHQgKi9cblx0XHRcdGlmIChlYml0cyA+IDEwMjMpXG5cdFx0XHRcdGViaXRzID0gMTAyMztcblx0XHRcdGV4cG9uZW50ID0gMTAyMyArIGViaXRzO1xuXHRcdFx0bWFudGlzc2EgPSB2YWx1ZSAqIE1hdGgucG93KDIsIC1lYml0cyk7XG5cdFx0XHRtYW50aXNzYSAqPSBNYXRoLnBvdygyLCA1Mik7XG5cdFx0XHRtYW50aXNzYSAlPSBNYXRoLnBvdygyLCA1Mik7XG5cdFx0fVxuXHR9XG5cblx0LyogRmlsbCB0aGUgYnl0ZXMgaW4gYmFja3dhcmRzIHRvIGRlYWwgd2l0aCB0aGUgc2l6ZSBpc3N1ZXMgKi9cblx0Ynl0ZXNbN10gPSBtYW50aXNzYSAmIDB4ZmY7XG5cdGJ5dGVzWzZdID0gKG1hbnRpc3NhID4+PiA4KSAmIDB4ZmY7XG5cdGJ5dGVzWzVdID0gKG1hbnRpc3NhID4+PiAxNikgJiAweGZmO1xuXHRtYW50aXNzYSA9IChtYW50aXNzYSAtIChtYW50aXNzYSAmIDB4ZmZmZmZmKSkgLyBNYXRoLnBvdygyLCAyNCk7XG5cdGJ5dGVzWzRdID0gbWFudGlzc2EgJiAweGZmO1xuXHRieXRlc1szXSA9IChtYW50aXNzYSA+Pj4gOCkgJiAweGZmO1xuXHRieXRlc1syXSA9IChtYW50aXNzYSA+Pj4gMTYpICYgMHhmZjtcblx0Ynl0ZXNbMV0gPSAoZXhwb25lbnQgJiAweDAwZikgPDwgNCB8IG1hbnRpc3NhID4+PiAyNDtcblx0Ynl0ZXNbMF0gPSAoc2lnbiA8PCA3KSB8IChleHBvbmVudCAmIDB4N2YwKSA+Pj4gNDtcblxuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0YnVmZmVyW29mZnNldF0gPSBieXRlc1swXTtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gYnl0ZXNbMV07XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9IGJ5dGVzWzJdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSBieXRlc1szXTtcblx0XHRidWZmZXJbb2Zmc2V0KzRdID0gYnl0ZXNbNF07XG5cdFx0YnVmZmVyW29mZnNldCs1XSA9IGJ5dGVzWzVdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNl0gPSBieXRlc1s2XTtcblx0XHRidWZmZXJbb2Zmc2V0KzddID0gYnl0ZXNbN107XG5cdH0gZWxzZSB7XG5cdFx0YnVmZmVyW29mZnNldCs3XSA9IGJ5dGVzWzBdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNl0gPSBieXRlc1sxXTtcblx0XHRidWZmZXJbb2Zmc2V0KzVdID0gYnl0ZXNbMl07XG5cdFx0YnVmZmVyW29mZnNldCs0XSA9IGJ5dGVzWzNdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSBieXRlc1s0XTtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gYnl0ZXNbNV07XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9IGJ5dGVzWzZdO1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gYnl0ZXNbN107XG5cdH1cbn1cblxuLypcbiAqIEFjdHVhbGx5IGV4cG9ydCBvdXIgd29yayBhYm92ZS4gT25lIG1pZ2h0IGFyZ3VlIHRoYXQgd2Ugc2hvdWxkbid0IGV4cG9zZVxuICogdGhlc2UgaW50ZXJmYWNlcyBhbmQganVzdCBmb3JjZSBwZW9wbGUgdG8gdXNlIHRoZSBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zXG4gKiBhcm91bmQgdGhpcyB3b3JrLiBIb3dldmVyLCB1bmxpa2Ugc2F5IG90aGVyIGxpYnJhcmllcyB3ZSd2ZSBjb21lIGFjcm9zcywgdGhpc1xuICogaW50ZXJmYWNlIGhhcyBzZXZlcmFsIHByb3BlcnRpZXM6IGl0IG1ha2VzIHNlbnNlLCBpdCdzIHNpbXBsZSwgYW5kIGl0J3NcbiAqIHVzZWZ1bC5cbiAqL1xuZXhwb3J0cy5ydWludDggPSBydWludDg7XG5leHBvcnRzLnJ1aW50MTYgPSBydWludDE2O1xuZXhwb3J0cy5ydWludDMyID0gcnVpbnQzMjtcbmV4cG9ydHMucnVpbnQ2NCA9IHJ1aW50NjQ7XG5leHBvcnRzLnd1aW50OCA9IHd1aW50ODtcbmV4cG9ydHMud3VpbnQxNiA9IHd1aW50MTY7XG5leHBvcnRzLnd1aW50MzIgPSB3dWludDMyO1xuZXhwb3J0cy53dWludDY0ID0gd3VpbnQ2NDtcblxuZXhwb3J0cy5yc2ludDggPSByc2ludDg7XG5leHBvcnRzLnJzaW50MTYgPSByc2ludDE2O1xuZXhwb3J0cy5yc2ludDMyID0gcnNpbnQzMjtcbmV4cG9ydHMucnNpbnQ2NCA9IHJzaW50NjQ7XG5leHBvcnRzLndzaW50OCA9IHdzaW50ODtcbmV4cG9ydHMud3NpbnQxNiA9IHdzaW50MTY7XG5leHBvcnRzLndzaW50MzIgPSB3c2ludDMyO1xuZXhwb3J0cy53c2ludDY0ID0gd3NpbnQ2NDtcblxuZXhwb3J0cy5yZmxvYXQgPSByZmxvYXQ7XG5leHBvcnRzLnJkb3VibGUgPSByZG91YmxlO1xuZXhwb3J0cy53ZmxvYXQgPSB3ZmxvYXQ7XG5leHBvcnRzLndkb3VibGUgPSB3ZG91YmxlO1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGx0eCA9IHJlcXVpcmUoJ2x0eCcpO1xudmFyIFN0cmVhbVBhcnNlciA9IHJlcXVpcmUoJy4vc3RyZWFtX3BhcnNlcicpO1xudmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJ2ZheWUtd2Vic29ja2V0JykgP1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJ2ZheWUtd2Vic29ja2V0JykuQ2xpZW50IDpcbiAgICAgICAgICAgICAgICB3aW5kb3cuV2ViU29ja2V0O1xuXG5cbnZhciBOU19TVFJFQU0gPSBleHBvcnRzLk5TX1NUUkVBTSA9ICdodHRwOi8vZXRoZXJ4LmphYmJlci5vcmcvc3RyZWFtcyc7XG52YXIgTlNfWE1QUF9TVFJFQU1TID0gJ3VybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1zdHJlYW1zJztcblxuZnVuY3Rpb24gV1NDb25uZWN0aW9uKHVybCkge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy54bWxucyA9IHt9O1xuICAgIHRoaXMud2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLnVybCwgWyd4bXBwJ10pO1xuICAgIHRoaXMud2Vic29ja2V0Lm9ub3BlbiA9IHRoaXMub25vcGVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy53ZWJzb2NrZXQub25tZXNzYWdlID0gdGhpcy5vbm1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLndlYnNvY2tldC5vbmNsb3NlID0gdGhpcy5vbmNsb3NlLmJpbmQodGhpcyk7XG4gICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IHRoaXMub25lcnJvci5iaW5kKHRoaXMpO1xufVxudXRpbC5pbmhlcml0cyhXU0Nvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLldTQ29ubmVjdGlvbiA9IFdTQ29ubmVjdGlvbjtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5tYXhTdGFuemFTaXplID0gNjU1MzU7XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICB0aGlzLnN0YXJ0UGFyc2VyKCk7XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0UGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFN0cmVhbVBhcnNlci5TdHJlYW1QYXJzZXIodGhpcy5tYXhTdGFuemFTaXplKTtcblxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdzdGFydCcsIGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgIHNlbGYuc3RyZWFtQXR0cnMgPSBhdHRycztcbiAgICAgICAgLyogV2UgbmVlZCB0aG9zZSB4bWxucyBvZnRlbiwgc3RvcmUgdGhlbSBleHRyYSAqL1xuICAgICAgICBzZWxmLnN0cmVhbU5zQXR0cnMgPSB7fTtcbiAgICAgICAgZm9yKHZhciBrIGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChrID09ICd4bWxucycgfHxcbiAgICAgICAgICAgIGsuc3Vic3RyKDAsIDYpID09ICd4bWxuczonKVxuICAgICAgICAgICAgICAgIHNlbGYuc3RyZWFtTnNBdHRyc1trXSA9IGF0dHJzW2tdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTm90aWZ5IGluIGNhc2Ugd2UgZG9uJ3Qgd2FpdCBmb3IgPHN0cmVhbTpmZWF0dXJlcy8+XG4gICAgICAgICAgIChDb21wb25lbnQgb3Igbm9uLTEuMCBzdHJlYW1zKVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5lbWl0KCdzdHJlYW1TdGFydCcsIGF0dHJzKTtcbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignc3RhbnphJywgZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgICAgIC8vc2VsZi5vblN0YW56YShzZWxmLmFkZFN0cmVhbU5zKHN0YW56YSkpO1xuICAgICAgICBzZWxmLm9uU3RhbnphKHN0YW56YSk7XG4gICAgfSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdG9wUGFyc2VyKCk7XG4gICAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSk7XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0b3BQYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBObyBtb3JlIGV2ZW50cywgcGxlYXNlIChtYXkgaGFwcGVuIGhvd2V2ZXIpICovXG4gICAgaWYodGhpcy5wYXJzZXIpIHtcbiAgICAgICAgLyogR2V0IEdDJ2VkICovXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBhcnNlcjtcbiAgICB9XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnNvbGUubG9nKFwid3MgbXNnXCIsIG1zZy5kYXRhKTtcbiAgICBpZiAobXNnICYmIG1zZy5kYXRhICYmIHRoaXMucGFyc2VyKVxuXHR0aGlzLnBhcnNlci53cml0ZShtc2cuZGF0YSk7XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLm9uU3RhbnphID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgaWYgKHN0YW56YS5pcygnZXJyb3InLCBOU19TVFJFQU0pKSB7XG4gICAgICAgIC8qIFRPRE86IGV4dHJhY3QgZXJyb3IgdGV4dCAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgc3RhbnphKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YW56YScsIHN0YW56YSk7XG4gICAgfVxufTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdHRycyA9IHt9O1xuICAgIGZvcih2YXIgayBpbiB0aGlzLnhtbG5zKSB7XG4gICAgICAgIGlmICh0aGlzLnhtbG5zLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBpZiAoIWspXG4gICAgICAgICAgICAgICAgYXR0cnMueG1sbnMgPSB0aGlzLnhtbG5zW2tdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGF0dHJzWyd4bWxuczonICsga10gPSB0aGlzLnhtbG5zW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnhtcHBWZXJzaW9uKVxuICAgICAgICBhdHRycy52ZXJzaW9uID0gdGhpcy54bXBwVmVyc2lvbjtcbiAgICBpZiAodGhpcy5zdHJlYW1UbylcbiAgICAgICAgYXR0cnMudG8gPSB0aGlzLnN0cmVhbVRvO1xuICAgIGlmICh0aGlzLnN0cmVhbUlkKVxuICAgICAgICBhdHRycy5pZCA9IHRoaXMuc3RyZWFtSWQ7XG5cbiAgICB2YXIgZWwgPSBuZXcgbHR4LkVsZW1lbnQoJ3N0cmVhbTpzdHJlYW0nLCBhdHRycyk7XG4gICAgLy8gbWFrZSBpdCBub24tZW1wdHkgdG8gY3V0IHRoZSBjbG9zaW5nIHRhZ1xuICAgIGVsLnQoJyAnKTtcbiAgICB2YXIgcyA9IGVsLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zZW5kKHMuc3Vic3RyKDAsIHMuaW5kZXhPZignIDwvc3RyZWFtOnN0cmVhbT4nKSkpO1xuXG4gICAgdGhpcy5zdHJlYW1PcGVuZWQgPSB0cnVlO1xufTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgaWYgKHN0YW56YS5yb290KVxuXHRzdGFuemEgPSBzdGFuemEucm9vdCgpO1xuICAgIHN0YW56YSA9IHN0YW56YS50b1N0cmluZygpO1xuICAgIGNvbnNvbGUubG9nKFwid3Mgc2VuZFwiLCBzdGFuemEpO1xuICAgIHRoaXMud2Vic29ja2V0LnNlbmQoc3RhbnphKTtcbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xufTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNlbmQoXCI8L3N0cmVhbTpzdHJlYW0+XCIpO1xuICAgIGlmICh0aGlzLndlYnNvY2tldClcblx0dGhpcy53ZWJzb2NrZXQuY2xvc2UoKTtcbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG59O1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciByZXF1ZXN0ID0gcmVxdWlyZSgncmVxdWVzdCcpO1xudmFyIGx0eCA9IHJlcXVpcmUoJ2x0eCcpO1xuXG5cbmZ1bmN0aW9uIEJPU0hDb25uZWN0aW9uKG9wdHMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmJvc2hVUkwgPSBvcHRzLmJvc2hVUkw7XG4gICAgdGhpcy5qaWQgPSBvcHRzLmppZDtcbiAgICB0aGlzLnhtbG5zQXR0cnMgPSB7XG5cdHhtbG5zOiBcImh0dHA6Ly9qYWJiZXIub3JnL3Byb3RvY29sL2h0dHBiaW5kXCIsXG5cdCd4bWxuczp4bXBwJzogXCJ1cm46eG1wcDp4Ym9zaFwiLFxuXHQneG1sbnM6c3RyZWFtJzogXCJodHRwOi8vZXRoZXJ4LmphYmJlci5vcmcvc3RyZWFtc1wiXG4gICAgfTtcbiAgICBpZiAob3B0cy54bWxucylcblx0Zm9yKHZhciBwcmVmaXggaW4gb3B0cy54bWxucylcblx0ICAgIGlmIChwcmVmaXgpXG5cdFx0dGhpcy54bWxuc0F0dHJzW1wieG1sbnM6XCIgKyBwcmVmaXhdID0gb3B0cy54bWxuc1twcmVmaXhdO1xuXHQgICAgZWxzZVxuXHRcdHRoaXMueG1sbnNBdHRyc1tcInhtbG5zXCJdID0gb3B0cy54bWxuc1twcmVmaXhdO1xuICAgIHRoaXMuY3VycmVudFJlcXVlc3RzID0gMDtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5yaWQgPSBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDk5OTk5OTk5OTkpO1xuXG4gICAgdGhpcy5yZXF1ZXN0KHtcblx0dG86IHRoaXMuamlkLmRvbWFpbixcblx0dmVyOiBcIjEuNlwiLFxuXHR3YWl0OiBcIjEwXCIsXG5cdGhvbGQ6IFwiMVwiLFxuXHRjb250ZW50OiB0aGlzLmNvbnRlbnRUeXBlXG4gICAgfSwgW10sIGZ1bmN0aW9uKGVyciwgYm9keUVsKSB7XG5cdGlmIChlcnIpIHtcblx0ICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHR9IGVsc2UgaWYgKGJvZHlFbCAmJiBib2R5RWwuYXR0cnMpIHtcblx0ICAgIHRoYXQuc2lkID0gYm9keUVsLmF0dHJzLnNpZDtcblx0ICAgIHRoYXQubWF4UmVxdWVzdHMgPSBwYXJzZUludChib2R5RWwuYXR0cnMucmVxdWVzdHMsIDEwKSB8fCAyO1xuXHQgICAgaWYgKHRoYXQuc2lkICYmIHRoYXQubWF4UmVxdWVzdHMgPiAwKSB7XG5cdFx0dGhhdC5lbWl0KCdjb25uZWN0Jyk7XG5cdFx0dGhhdC5wcm9jZXNzUmVzcG9uc2UoYm9keUVsKTtcblx0XHRwcm9jZXNzLm5leHRUaWNrKHRoYXQubWF5UmVxdWVzdC5iaW5kKHRoYXQpKTtcblx0ICAgIH0gZWxzZVxuXHRcdHRoYXQuZW1pdCgnZXJyb3InLCBcIkludmFsaWQgcGFyYW1ldGVyc1wiKTtcblx0fVxuICAgIH0pO1xufVxudXRpbC5pbmhlcml0cyhCT1NIQ29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuQk9TSENvbm5lY3Rpb24gPSBCT1NIQ29ubmVjdGlvbjtcblxuQk9TSENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbnRlbnRUeXBlID0gXCJ0ZXh0L3htbDsgY2hhcnNldD11dGYtOFwiO1xuXG5CT1NIQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHN0YW56YSkge1xuICAgIHRoaXMucXVldWUucHVzaChzdGFuemEucm9vdCgpKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubWF5UmVxdWVzdC5iaW5kKHRoaXMpKTtcbn07XG5cbkJPU0hDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzUmVzcG9uc2UgPSBmdW5jdGlvbihib2R5RWwpIHtcbiAgICBpZiAoYm9keUVsICYmIGJvZHlFbC5jaGlsZHJlbikge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keUVsLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgY2hpbGQgPSBib2R5RWwuY2hpbGRyZW5baV07XG5cdCAgICBpZiAoY2hpbGQubmFtZSAmJiBjaGlsZC5hdHRycyAmJiBjaGlsZC5jaGlsZHJlbilcblx0XHR0aGlzLmVtaXQoJ3N0YW56YScsIGNoaWxkKTtcblx0fVxuICAgIH1cbiAgICBpZiAoYm9keUVsICYmIGJvZHlFbC5hdHRycy50eXBlID09PSAndGVybWluYXRlJykge1xuXHR0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGJvZHlFbC5hdHRycy5jb25kaXRpb24gfHwgXCJTZXNzaW9uIHRlcm1pbmF0ZWRcIikpO1xuXHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxufTtcblxuQk9TSENvbm5lY3Rpb24ucHJvdG90eXBlLm1heVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGNhblJlcXVlc3QgPVxuXHQvKiBNdXN0IGhhdmUgYSBzZXNzaW9uIGFscmVhZHkgKi9cblx0dGhpcy5zaWQgJiZcblx0LyogV2UgY2FuIG9ubHkgcmVjZWl2ZSB3aGVuIG9uZSByZXF1ZXN0IGlzIGluIGZsaWdodCAqL1xuXHQodGhpcy5jdXJyZW50UmVxdWVzdHMgPT09IDAgfHxcblx0IC8qIElzIHRoZXJlIHNvbWV0aGluZyB0byBzZW5kLCBhbmQgYXJlIHdlIGFsbG93ZWQ/ICovXG5cdCAoKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLmN1cnJlbnRSZXF1ZXN0cyA8IHRoaXMubWF4UmVxdWVzdHMpKVxuXHQpO1xuICAgIGlmICghY2FuUmVxdWVzdClcblx0cmV0dXJuO1xuXG4gICAgdmFyIHN0YW56YXMgPSB0aGlzLnF1ZXVlO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLnJpZCsrO1xuICAgIHRoaXMucmVxdWVzdCh7fSwgc3RhbnphcywgZnVuY3Rpb24oZXJyLCBib2R5RWwpIHtcblx0aWYgKGVycikge1xuXHQgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycik7XG5cdCAgICB0aGF0LmVtaXQoJ2Nsb3NlJyk7XG5cdCAgICBkZWxldGUgdGhhdC5zaWQ7XG5cdH0gZWxzZSB7XG5cdCAgICBpZiAoYm9keUVsKVxuXHRcdHRoYXQucHJvY2Vzc1Jlc3BvbnNlKGJvZHlFbCk7XG5cblx0ICAgIHByb2Nlc3MubmV4dFRpY2sodGhhdC5tYXlSZXF1ZXN0LmJpbmQodGhhdCkpO1xuXHR9XG4gICAgfSk7XG59O1xuXG5CT1NIQ29ubmVjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oc3Rhbnphcykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHN0YW56YXMgPSBzdGFuemFzIHx8IFtdO1xuICAgIGlmICh0eXBlb2Ygc3RhbnphcyAhPT0gJ2FycmF5Jylcblx0c3RhbnphcyA9IFtzdGFuemFzXTtcblxuICAgIHN0YW56YXMgPSB0aGlzLnF1ZXVlLmNvbmNhdChzdGFuemFzKTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5yaWQrKztcbiAgICB0aGlzLnJlcXVlc3QoeyB0eXBlOiAndGVybWluYXRlJyB9LCBzdGFuemFzLCBmdW5jdGlvbihlcnIsIGJvZHlFbCkge1xuXHRpZiAoYm9keUVsKVxuXHQgICAgdGhhdC5wcm9jZXNzUmVzcG9uc2UoYm9keUVsKTtcblxuXHR0aGF0LmVtaXQoJ2VuZCcpO1xuXHR0aGF0LmVtaXQoJ2Nsb3NlJyk7XG5cdGRlbGV0ZSB0aGF0LnNpZDtcbiAgICB9KTtcbn07XG5cbkJPU0hDb25uZWN0aW9uLnByb3RvdHlwZS5tYXhIVFRQUmV0cmllcyA9IDU7XG5cbkJPU0hDb25uZWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24oYXR0cnMsIGNoaWxkcmVuLCBjYiwgcmV0cnkpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0cnkgPSByZXRyeSB8fCAwO1xuXG4gICAgYXR0cnMucmlkID0gdGhpcy5yaWQudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5zaWQpXG5cdGF0dHJzLnNpZCA9IHRoaXMuc2lkO1xuXG4gICAgZm9yKHZhciBrIGluIHRoaXMueG1sbnNBdHRycylcblx0YXR0cnNba10gPSB0aGlzLnhtbG5zQXR0cnNba107XG4gICAgdmFyIGJvc2hFbCA9IG5ldyBsdHguRWxlbWVudCgnYm9keScsIGF0dHJzKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG5cdGJvc2hFbC5jbm9kZShjaGlsZHJlbltpXSk7XG5cbiAgICByZXF1ZXN0KHtcblx0dXJpOiB0aGlzLmJvc2hVUkwsXG5cdG1ldGhvZDogJ1BPU1QnLFxuXHRoZWFkZXJzOiB7XG5cdCAgICBcIkNvbnRlbnQtVHlwZVwiOiB0aGlzLmNvbnRlbnRUeXBlXG5cdH0sXG5cdGJvZHk6IGJvc2hFbC50b1N0cmluZygpXG4gICAgfSwgZnVuY3Rpb24oZXJyLCByZXMsIGJvZHkpIHtcblx0dGhhdC5jdXJyZW50UmVxdWVzdHMtLTtcblxuXHRpZiAoZXJyKSB7XG5cdCAgICBpZiAocmV0cnkgPCB0aGF0Lm1heEhUVFBSZXRyaWVzKVxuXHRcdHJldHVybiB0aGF0LnJlcXVlc3QoYXR0cnMsIGNoaWxkcmVuLCBjYiwgcmV0cnkgKyAxKTtcblx0ICAgIGVsc2Vcblx0XHRyZXR1cm4gY2IoZXJyKTtcblx0fVxuXHRpZiAocmVzLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzLnN0YXR1c0NvZGUgPj0gNDAwKVxuXHQgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihcIkhUVFAgc3RhdHVzIFwiICsgcmVzLnN0YXR1c0NvZGUpKTtcblxuXHR2YXIgYm9keUVsO1xuXHR0cnkge1xuXHQgICAgYm9keUVsID0gbHR4LnBhcnNlKGJvZHkpO1xuXHR9IGNhdGNoKGUpIHtcblx0ICAgIHJldHVybiBjYihlKTtcblx0fVxuXG5cdGlmIChib2R5RWwgJiYgYm9keUVsLmF0dHJzLnR5cGUgPT09ICd0ZXJtaW5hdGUnKVxuXHQgICAgY2IobmV3IEVycm9yKGJvZHlFbC5hdHRycy5jb25kaXRpb24pKTtcblx0ZWxzZSBpZiAoYm9keUVsKVxuXHQgICAgY2IobnVsbCwgYm9keUVsKTtcblx0ZWxzZVxuXHQgICAgY2IobmV3IEVycm9yKCdubyA8Ym9keS8+JykpO1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFJlcXVlc3RzKys7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7dmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIERlbGF5ZWRTdHJlYW0gPSByZXF1aXJlKCdkZWxheWVkLXN0cmVhbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJpbmVkU3RyZWFtO1xuZnVuY3Rpb24gQ29tYmluZWRTdHJlYW0oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMiAqIDEwMjQgKiAxMDI0O1xuICB0aGlzLnBhdXNlU3RyZWFtcyA9IHRydWU7XG5cbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbn1cbnV0aWwuaW5oZXJpdHMoQ29tYmluZWRTdHJlYW0sIFN0cmVhbSk7XG5cbkNvbWJpbmVkU3RyZWFtLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGNvbWJpbmVkU3RyZWFtID0gbmV3IHRoaXMoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBjb21iaW5lZFN0cmVhbVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkU3RyZWFtO1xufTtcblxuQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHJldHVybiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ3N0cmluZycpXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdib29sZWFuJykgICAgXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdudW1iZXInKVxuICAgICYmICghQnVmZmVyLmlzQnVmZmVyKHN0cmVhbSkpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG5cbiAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgIGlmICghKHN0cmVhbSBpbnN0YW5jZW9mIERlbGF5ZWRTdHJlYW0pKSB7XG4gICAgICBzdHJlYW0ub24oJ2RhdGEnLCB0aGlzLl9jaGVja0RhdGFTaXplLmJpbmQodGhpcykpO1xuXG4gICAgICBzdHJlYW0gPSBEZWxheWVkU3RyZWFtLmNyZWF0ZShzdHJlYW0sIHtcbiAgICAgICAgbWF4RGF0YVNpemU6IEluZmluaXR5LFxuICAgICAgICBwYXVzZVN0cmVhbTogdGhpcy5wYXVzZVN0cmVhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVFcnJvcnMoc3RyZWFtKTtcblxuICAgIGlmICh0aGlzLnBhdXNlU3RyZWFtcykge1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fc3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIFN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHRoaXMsIGRlc3QsIG9wdGlvbnMpO1xuICB0aGlzLnJlc3VtZSgpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9nZXROZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBudWxsO1xuICB2YXIgc3RyZWFtID0gdGhpcy5fc3RyZWFtcy5zaGlmdCgpO1xuXG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmVuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcGlwZU5leHQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2V0U3RyZWFtID0gc3RyZWFtO1xuICBnZXRTdHJlYW0oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuICAgIGlmIChpc1N0cmVhbUxpa2UpIHtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIHRoaXMuX2NoZWNrRGF0YVNpemUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9oYW5kbGVFcnJvcnMoc3RyZWFtKTtcbiAgICB9XG5cbiAgICB0aGlzLl9waXBlTmV4dChzdHJlYW0pO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9waXBlTmV4dCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gc3RyZWFtO1xuXG4gIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcbiAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgIHN0cmVhbS5vbignZW5kJywgdGhpcy5fZ2V0TmV4dC5iaW5kKHRoaXMpKVxuICAgIHN0cmVhbS5waXBlKHRoaXMsIHtlbmQ6IGZhbHNlfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gc3RyZWFtO1xuICB0aGlzLndyaXRlKHZhbHVlKTtcbiAgdGhpcy5fZ2V0TmV4dCgpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFcnJvcnMgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5fZW1pdEVycm9yKGVycik7XG4gIH0pO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucGF1c2VTdHJlYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbGVhc2VkKSB7XG4gICAgdGhpcy5fcmVsZWFzZWQgPSB0cnVlO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2dldE5leHQoKTtcbiAgfVxuXG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnZW5kJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVEYXRhU2l6ZSgpO1xuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdEZWxheWVkU3RyZWFtI21heERhdGFTaXplIG9mICcgKyB0aGlzLm1heERhdGFTaXplICsgJyBieXRlcyBleGNlZWRlZC4nXG4gIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IobWVzc2FnZSkpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl91cGRhdGVEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGFTaXplID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3N0cmVhbXMuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbS5kYXRhU2l6ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuZGF0YVNpemUgKz0gc3RyZWFtLmRhdGFTaXplO1xuICB9KTtcblxuICBpZiAodGhpcy5fY3VycmVudFN0cmVhbSAmJiB0aGlzLl9jdXJyZW50U3RyZWFtLmRhdGFTaXplKSB7XG4gICAgdGhpcy5kYXRhU2l6ZSArPSB0aGlzLl9jdXJyZW50U3RyZWFtLmRhdGFTaXplO1xuICB9XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2VtaXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIvLyBMb2FkIG1vZHVsZXNcclxuXHJcbnZhciBCb29tID0gcmVxdWlyZSgnYm9vbScpO1xyXG52YXIgSG9layA9IHJlcXVpcmUoJ2hvZWsnKTtcclxudmFyIENyeXB0aWxlcyA9IHJlcXVpcmUoJ2NyeXB0aWxlcycpO1xyXG52YXIgQ3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuXHJcbi8vIERlY2xhcmUgaW50ZXJuYWxzXHJcblxyXG52YXIgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxuLy8gSGF3ayBhdXRoZW50aWNhdGlvblxyXG5cclxuLypcclxuICAgcmVxOiAgICAgICAgICAgICAgICAgbm9kZSdzIEhUVFAgcmVxdWVzdCBvYmplY3Qgb3IgYW4gb2JqZWN0IGFzIGZvbGxvd3M6XHJcbiAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJy9yZXNvdXJjZS80P2E9MSZiPTInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogJ2V4YW1wbGUuY29tJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IDgwODAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiAnSGF3ayBpZD1cImRoMzdmZ2o0OTJqZVwiLCB0cz1cIjEzNTM4MzIyMzRcIiwgbm9uY2U9XCJqNGgzZzJcIiwgZXh0PVwic29tZS1hcHAtZXh0LWRhdGFcIiwgbWFjPVwiNlI0clY1aUUrTlBveW0rV3dqZUh6akFHWFV0TE5JeG1vMXZwTW9mcExBRT1cIidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICBcclxuICAgY3JlZGVudGlhbHNGdW5jOiAgICAgcmVxdWlyZWQgZnVuY3Rpb24gdG8gbG9va3VwIHRoZSBzZXQgb2YgSGF3ayBjcmVkZW50aWFscyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgaWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVkZW50aWFscyBpbmNsdWRlIHRoZSBNQUMga2V5LCBNQUMgYWxnb3JpdGhtLCBhbmQgb3RoZXIgYXR0cmlidXRlcyAoc3VjaCBhcyB1c2VybmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZGVkIGJ5IHRoZSBhcHBsaWNhdGlvbi4gVGhpcyBmdW5jdGlvbiBpcyB0aGUgZXF1aXZhbGVudCBvZiB2ZXJpZnlpbmcgdGhlIHVzZXJuYW1lIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCBpbiBCYXNpYyBhdXRoZW50aWNhdGlvbi5cclxuICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWRlbnRpYWxzRnVuYyA9IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9va3VwIGNyZWRlbnRpYWxzIGluIGRhdGFiYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5sb29rdXAoaWQsIGZ1bmN0aW9uIChlcnIsIGl0ZW0pIHtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIWl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWRlbnRpYWxzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGl0ZW0ua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGdvcml0aG06IGl0ZW0uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsaWNhdGlvbiBzcGVjaWZpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBpdGVtLnVzZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNyZWRlbnRpYWxzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gIFxyXG4gICBvcHRpb25zOiB7XHJcblxyXG4gICAgICAgIGhvc3RIZWFkZXJOYW1lOiAgICAgICAgb3B0aW9uYWwgaGVhZGVyIGZpZWxkIG5hbWUsIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgJ0hvc3QnIGhlYWRlciB3aGVuIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlaGluZCBhIGNhY2hlIG9mIGEgcHJveHkuIEFwYWNoZTIgY2hhbmdlcyB0aGUgdmFsdWUgb2YgdGhlICdIb3N0JyBoZWFkZXIgd2hpbGUgcHJlc2VydmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9yaWdpbmFsICh3aGljaCBpcyB3aGF0IHRoZSBtb2R1bGUgbXVzdCB2ZXJpZnkpIGluIHRoZSAneC1mb3J3YXJkZWQtaG9zdCcgaGVhZGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB1c2VkIHdoZW4gcGFzc2VkIGEgbm9kZSBIdHRwLlNlcnZlclJlcXVlc3Qgb2JqZWN0LlxyXG4gIFxyXG4gICAgICAgIG5vbmNlRnVuYzogICAgICAgICAgICAgb3B0aW9uYWwgbm9uY2UgdmFsaWRhdGlvbiBmdW5jdGlvbi4gVGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBpcyBmdW5jdGlvbihub25jZSwgdHMsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlcmUgJ2NhbGxiYWNrJyBtdXN0IGJlIGNhbGxlZCB1c2luZyB0aGUgc2lnbmF0dXJlIGZ1bmN0aW9uKGVycikuXHJcbiAgXHJcbiAgICAgICAgdGltZXN0YW1wU2tld1NlYzogICAgICBvcHRpb25hbCBudW1iZXIgb2Ygc2Vjb25kcyBvZiBwZXJtaXR0ZWQgY2xvY2sgc2tldyBmb3IgaW5jb21pbmcgdGltZXN0YW1wcy4gRGVmYXVsdHMgdG8gNjAgc2Vjb25kcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb3ZpZGVzIGEgKy8tIHNrZXcgd2hpY2ggbWVhbnMgYWN0dWFsIGFsbG93ZWQgd2luZG93IGlzIGRvdWJsZSB0aGUgbnVtYmVyIG9mIHNlY29uZHMuXHJcbiAgXHJcbiAgICAgICAgbG9jYWx0aW1lT2Zmc2V0TXNlYzogICBvcHRpb25hbCBsb2NhbCBjbG9jayB0aW1lIG9mZnNldCBleHByZXNzIGluIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyAocG9zaXRpdmUgb3IgbmVnYXRpdmUpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMC5cclxuICBcclxuICAgICAgICBwYXlsb2FkOiAgICAgICAgICAgICAgIG9wdGlvbmFsIHBheWxvYWQgZm9yIHZhbGlkYXRpb24uIFRoZSBjbGllbnQgY2FsY3VsYXRlcyB0aGUgaGFzaCB2YWx1ZSBhbmQgaW5jbHVkZXMgaXQgdmlhIHRoZSAnaGFzaCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciBhdHRyaWJ1dGUuIFRoZSBzZXJ2ZXIgYWx3YXlzIGVuc3VyZXMgdGhlIHZhbHVlIHByb3ZpZGVkIGhhcyBiZWVuIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNQUMuIFdoZW4gdGhpcyBvcHRpb24gaXMgcHJvdmlkZWQsIGl0IHZhbGlkYXRlcyB0aGUgaGFzaCB2YWx1ZSBpdHNlbGYuIFZhbGlkYXRpb24gaXMgZG9uZSBieSBjYWxjdWxhdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBoYXNoIHZhbHVlIG92ZXIgdGhlIGVudGlyZSBwYXlsb2FkIChhc3N1bWluZyBpdCBoYXMgYWxyZWFkeSBiZSBub3JtYWxpemVkIHRvIHRoZSBzYW1lIGZvcm1hdCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nIHVzZWQgYnkgdGhlIGNsaWVudCB0byBjYWxjdWxhdGUgdGhlIGhhc2ggb24gcmVxdWVzdCkuIElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhlIHRpbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGF1dGhlbnRpY2F0aW9uLCB0aGUgYXV0aGVudGljYXRlUGF5bG9hZCgpIG1ldGhvZCBjYW4gYmUgdXNlZCBieSBwYXNzaW5nIGl0IHRoZSBjcmVkZW50aWFscyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuaGFzaCByZXR1cm5lZCBpbiB0aGUgYXV0aGVudGljYXRlIGNhbGxiYWNrLlxyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKSB7IH1cclxuICovXHJcblxyXG5leHBvcnRzLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChyZXEsIGNyZWRlbnRpYWxzRnVuYywgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuXHJcbiAgICBjYWxsYmFjayA9IFV0aWxzLm5leHRUaWNrKGNhbGxiYWNrKTtcclxuICAgIFxyXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zXHJcblxyXG4gICAgb3B0aW9ucy5ub25jZUZ1bmMgPSBvcHRpb25zLm5vbmNlRnVuYyB8fCBmdW5jdGlvbiAobm9uY2UsIHRzLCBub25jZUNhbGxiYWNrKSB7IHJldHVybiBub25jZUNhbGxiYWNrKCk7IH07ICAgLy8gTm8gdmFsaWRhdGlvblxyXG4gICAgb3B0aW9ucy50aW1lc3RhbXBTa2V3U2VjID0gb3B0aW9ucy50aW1lc3RhbXBTa2V3U2VjIHx8IDYwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNjAgc2Vjb25kc1xyXG5cclxuICAgIC8vIEFwcGxpY2F0aW9uIHRpbWVcclxuXHJcbiAgICB2YXIgbm93ID0gVXRpbHMubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApOyAgICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBub3cgYmVmb3JlIGFueSBvdGhlciBwcm9jZXNzaW5nXHJcblxyXG4gICAgLy8gQ29udmVydCBub2RlIEh0dHAgcmVxdWVzdCBvYmplY3QgdG8gYSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcblxyXG4gICAgdmFyIHJlcXVlc3QgPSBVdGlscy5wYXJzZVJlcXVlc3QocmVxLCBvcHRpb25zKTtcclxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5iYWRSZXF1ZXN0KHJlcXVlc3QubWVzc2FnZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIEhUVFAgQXV0aG9yaXphdGlvbiBoZWFkZXJcclxuXHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IFV0aWxzLnBhcnNlQXV0aG9yaXphdGlvbkhlYWRlcihyZXF1ZXN0LmF1dGhvcml6YXRpb24pO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgYXJ0aWZhY3RzIGNvbnRhaW5lclxyXG5cclxuICAgIHZhciBhcnRpZmFjdHMgPSB7XHJcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcclxuICAgICAgICBob3N0OiByZXF1ZXN0Lmhvc3QsXHJcbiAgICAgICAgcG9ydDogcmVxdWVzdC5wb3J0LFxyXG4gICAgICAgIHJlc291cmNlOiByZXF1ZXN0LnVybCxcclxuICAgICAgICB0czogYXR0cmlidXRlcy50cyxcclxuICAgICAgICBub25jZTogYXR0cmlidXRlcy5ub25jZSxcclxuICAgICAgICBoYXNoOiBhdHRyaWJ1dGVzLmhhc2gsXHJcbiAgICAgICAgZXh0OiBhdHRyaWJ1dGVzLmV4dCxcclxuICAgICAgICBhcHA6IGF0dHJpYnV0ZXMuYXBwLFxyXG4gICAgICAgIGRsZzogYXR0cmlidXRlcy5kbGcsXHJcbiAgICAgICAgbWFjOiBhdHRyaWJ1dGVzLm1hYyxcclxuICAgICAgICBpZDogYXR0cmlidXRlcy5pZFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBWZXJpZnkgcmVxdWlyZWQgaGVhZGVyIGF0dHJpYnV0ZXNcclxuXHJcbiAgICBpZiAoIWF0dHJpYnV0ZXMuaWQgfHxcclxuICAgICAgICAhYXR0cmlidXRlcy50cyB8fFxyXG4gICAgICAgICFhdHRyaWJ1dGVzLm5vbmNlIHx8XHJcbiAgICAgICAgIWF0dHJpYnV0ZXMubWFjKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmJhZFJlcXVlc3QoJ01pc3NpbmcgYXR0cmlidXRlcycpLCBudWxsLCBhcnRpZmFjdHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZldGNoIEhhd2sgY3JlZGVudGlhbHNcclxuXHJcbiAgICBjcmVkZW50aWFsc0Z1bmMoYXR0cmlidXRlcy5pZCwgZnVuY3Rpb24gKGVyciwgY3JlZGVudGlhbHMpIHtcclxuXHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBjcmVkZW50aWFscyB8fCBudWxsLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ1Vua25vd24gY3JlZGVudGlhbHMnLCAnSGF3aycpLCBudWxsLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscy5rZXkgfHxcclxuICAgICAgICAgICAgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uaW50ZXJuYWwoJ0ludmFsaWQgY3JlZGVudGlhbHMnKSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoQ3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5pbnRlcm5hbCgnVW5rbm93biBhbGdvcml0aG0nKSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgTUFDXHJcblxyXG4gICAgICAgIHZhciBtYWMgPSBDcnlwdG8uY2FsY3VsYXRlTWFjKCdoZWFkZXInLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICBpZiAoIUNyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKG1hYywgYXR0cmlidXRlcy5tYWMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnQmFkIG1hYycsICdIYXdrJyksIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgcGF5bG9hZCBoYXNoXHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnBheWxvYWQgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgb3B0aW9ucy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHsgICAgICAgLy8gJycgaXMgdmFsaWRcclxuXHJcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5oYXNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ01pc3NpbmcgcmVxdWlyZWQgcGF5bG9hZCBoYXNoJywgJ0hhd2snKSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gQ3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdGlvbnMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCByZXF1ZXN0LmNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgaWYgKCFDcnlwdGlsZXMuZml4ZWRUaW1lQ29tcGFyaXNvbihoYXNoLCBhdHRyaWJ1dGVzLmhhc2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ0JhZCBwYXlsb2FkIGhhc2gnLCAnSGF3aycpLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbm9uY2VcclxuXHJcbiAgICAgICAgb3B0aW9ucy5ub25jZUZ1bmMoYXR0cmlidXRlcy5ub25jZSwgYXR0cmlidXRlcy50cywgZnVuY3Rpb24gKGVycikge1xyXG5cclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdJbnZhbGlkIG5vbmNlJywgJ0hhd2snKSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRpbWVzdGFtcCBzdGFsZW5lc3NcclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicygoYXR0cmlidXRlcy50cyAqIDEwMDApIC0gbm93KSA+IChvcHRpb25zLnRpbWVzdGFtcFNrZXdTZWMgKiAxMDAwKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyZXNoID0gTWF0aC5mbG9vcigoVXRpbHMubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApKSAvIDEwMDApOyAgICAgICAgICAgIC8vIEdldCBmcmVzaCBub3dcclxuICAgICAgICAgICAgICAgIHZhciB0c20gPSBDcnlwdG8uY2FsY3VsYXRlVHNNYWMoZnJlc2gsIGNyZWRlbnRpYWxzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnU3RhbGUgdGltZXN0YW1wJywgJ0hhd2snLCB7IHRzOiBmcmVzaCwgdHNtOiB0c20gfSksIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG4vLyBBdXRoZW50aWNhdGUgcGF5bG9hZCBoYXNoIC0gdXNlZCB3aGVuIHBheWxvYWQgY2Fubm90IGJlIHByb3ZpZGVkIGR1cmluZyBhdXRoZW50aWNhdGUoKVxyXG5cclxuLypcclxuICAgIHBheWxvYWQ6ICAgICAgICByYXcgcmVxdWVzdCBwYXlsb2FkXHJcbiAgICBjcmVkZW50aWFsczogICAgZnJvbSBhdXRoZW50aWNhdGUgY2FsbGJhY2tcclxuICAgIGFydGlmYWN0czogICAgICBmcm9tIGF1dGhlbnRpY2F0ZSBjYWxsYmFja1xyXG4gICAgY29udGVudFR5cGU6ICAgIHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXVxyXG4qL1xyXG5cclxuZXhwb3J0cy5hdXRoZW50aWNhdGVQYXlsb2FkID0gZnVuY3Rpb24gKHBheWxvYWQsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMsIGNvbnRlbnRUeXBlKSB7XHJcblxyXG4gICAgdmFyIGNhbGN1bGF0ZWRIYXNoID0gQ3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKHBheWxvYWQsIGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY29udGVudFR5cGUpO1xyXG4gICAgcmV0dXJuIENyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKGNhbGN1bGF0ZWRIYXNoLCBhcnRpZmFjdHMuaGFzaCk7XHJcbn07XHJcblxyXG5cclxuLy8gR2VuZXJhdGUgYSBTZXJ2ZXItQXV0aG9yaXphdGlvbiBoZWFkZXIgZm9yIGEgZ2l2ZW4gcmVzcG9uc2VcclxuXHJcbi8qXHJcbiAgICBjcmVkZW50aWFsczoge30sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCByZWNlaXZlZCBmcm9tIGF1dGhlbnRpY2F0ZSgpXHJcbiAgICBhcnRpZmFjdHM6IHt9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCByZWNlaXZlZCBmcm9tIGF1dGhlbnRpY2F0ZSgpOyAnbWFjJywgJ2hhc2gnLCBhbmQgJ2V4dCcgLSBpZ25vcmVkXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgZXh0OiAnYXBwbGljYXRpb24tc3BlY2lmaWMnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljIGRhdGEgc2VudCB2aWEgdGhlIGV4dCBhdHRyaWJ1dGVcclxuICAgICAgICBwYXlsb2FkOiAne1wic29tZVwiOlwicGF5bG9hZFwifScsICAgICAgICAgICAgICAgICAgICAgIC8vIFVURi04IGVuY29kZWQgc3RyaW5nIGZvciBib2R5IGhhc2ggZ2VuZXJhdGlvbiAoaWdub3JlZCBpZiBoYXNoIHByb3ZpZGVkKVxyXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsICAgICAgICAgICAgICAgICAgICAvLyBQYXlsb2FkIGNvbnRlbnQtdHlwZSAoaWdub3JlZCBpZiBoYXNoIHByb3ZpZGVkKVxyXG4gICAgICAgIGhhc2g6ICdVNE1LS1NtaVZ4azM3SkNDckFWSWpWPScgICAgICAgICAgICAgICAgICAgICAvLyBQcmUtY2FsY3VsYXRlZCBwYXlsb2FkIGhhc2hcclxuICAgIH1cclxuKi9cclxuXHJcbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyBQcmVwYXJlIGlucHV0c1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmICghYXJ0aWZhY3RzIHx8XHJcbiAgICAgICAgdHlwZW9mIGFydGlmYWN0cyAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGFydGlmYWN0cyA9IEhvZWsuY2xvbmUoYXJ0aWZhY3RzKTtcclxuICAgIGRlbGV0ZSBhcnRpZmFjdHMubWFjO1xyXG4gICAgYXJ0aWZhY3RzLmhhc2ggPSBvcHRpb25zLmhhc2g7XHJcbiAgICBhcnRpZmFjdHMuZXh0ID0gb3B0aW9ucy5leHQ7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgY3JlZGVudGlhbHNcclxuXHJcbiAgICBpZiAoIWNyZWRlbnRpYWxzIHx8XHJcbiAgICAgICAgIWNyZWRlbnRpYWxzLmtleSB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5hbGdvcml0aG0pIHtcclxuXHJcbiAgICAgICAgLy8gSW52YWxpZCBjcmVkZW50aWFsIG9iamVjdFxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgcGF5bG9hZCBoYXNoXHJcblxyXG4gICAgaWYgKCFhcnRpZmFjdHMuaGFzaCAmJlxyXG4gICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3BheWxvYWQnKSkge1xyXG5cclxuICAgICAgICBhcnRpZmFjdHMuaGFzaCA9IENyeXB0by5jYWxjdWxhdGVQYXlsb2FkSGFzaChvcHRpb25zLnBheWxvYWQsIGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgb3B0aW9ucy5jb250ZW50VHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1hYyA9IENyeXB0by5jYWxjdWxhdGVNYWMoJ3Jlc3BvbnNlJywgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGhlYWRlclxyXG5cclxuICAgIHZhciBoZWFkZXIgPSAnSGF3ayBtYWM9XCInICsgbWFjICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgKGFydGlmYWN0cy5oYXNoID8gJywgaGFzaD1cIicgKyBhcnRpZmFjdHMuaGFzaCArICdcIicgOiAnJyk7XHJcblxyXG4gICAgaWYgKGFydGlmYWN0cy5leHQgIT09IG51bGwgJiZcclxuICAgICAgICBhcnRpZmFjdHMuZXh0ICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBhcnRpZmFjdHMuZXh0ICE9PSAnJykgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgZmFsc2V5IHZhbHVlcyBhbGxvd2VkXHJcblxyXG4gICAgICAgIGhlYWRlciArPSAnLCBleHQ9XCInICsgVXRpbHMuZXNjYXBlSGVhZGVyQXR0cmlidXRlKGFydGlmYWN0cy5leHQpICsgJ1wiJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGVhZGVyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEFyZ3VtZW50cyBhbmQgb3B0aW9ucyBhcmUgdGhlIHNhbWUgYXMgaW5kZXguanMgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgdGhlIG9ubHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxyXG4gKiAnaG9zdEhlYWRlck5hbWUnLCAnbG9jYWx0aW1lT2Zmc2V0TXNlYydcclxuICovXHJcblxyXG5leHBvcnRzLmF1dGhlbnRpY2F0ZUJld2l0ID0gZnVuY3Rpb24gKHJlcSwgY3JlZGVudGlhbHNGdW5jLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cclxuICAgIGNhbGxiYWNrID0gVXRpbHMubmV4dFRpY2soY2FsbGJhY2spO1xyXG5cclxuICAgIC8vIEFwcGxpY2F0aW9uIHRpbWVcclxuXHJcbiAgICB2YXIgbm93ID0gVXRpbHMubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApO1xyXG5cclxuICAgIC8vIENvbnZlcnQgbm9kZSBIdHRwIHJlcXVlc3Qgb2JqZWN0IHRvIGEgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9iamVjdFxyXG5cclxuICAgIHZhciByZXF1ZXN0ID0gVXRpbHMucGFyc2VSZXF1ZXN0KHJlcSwgb3B0aW9ucyk7XHJcbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uYmFkUmVxdWVzdChyZXF1ZXN0Lm1lc3NhZ2UpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRyYWN0IGJld2l0XHJcblxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDQgICAgIFxyXG4gICAgdmFyIHJlc291cmNlID0gcmVxdWVzdC51cmwubWF0Y2goL14oXFwvLiopKFtcXD8mXSliZXdpdFxcPShbXiYkXSopKD86JiguKykpPyQvKTtcclxuICAgIGlmICghcmVzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQobnVsbCwgJ0hhd2snKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmV3aXQgbm90IGVtcHR5XHJcblxyXG4gICAgaWYgKCFyZXNvdXJjZVszXSkge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnRW1wdHkgYmV3aXQnLCAnSGF3aycpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWZXJpZnkgbWV0aG9kIGlzIEdFVFxyXG5cclxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgJiZcclxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnSW52YWxpZCBtZXRob2QnLCAnSGF3aycpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBvdGhlciBhdXRoZW50aWNhdGlvblxyXG5cclxuICAgIGlmIChyZXF1ZXN0LmF1dGhvcml6YXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5iYWRSZXF1ZXN0KCdNdWx0aXBsZSBhdXRoZW50aWNhdGlvbnMnLCAnSGF3aycpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBiZXdpdFxyXG5cclxuICAgIHZhciBiZXdpdFN0cmluZyA9IFV0aWxzLmJhc2U2NHVybERlY29kZShyZXNvdXJjZVszXSk7XHJcbiAgICBpZiAoYmV3aXRTdHJpbmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgYmV3aXQgZW5jb2RpbmcnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmV3aXQgZm9ybWF0OiBpZFxcZXhwXFxtYWNcXGV4dCAoJ1xcJyBpcyB1c2VkIGJlY2F1c2UgaXQgaXMgYSByZXNlcnZlZCBoZWFkZXIgYXR0cmlidXRlIGNoYXJhY3RlcilcclxuXHJcbiAgICB2YXIgYmV3aXRQYXJ0cyA9IGJld2l0U3RyaW5nLnNwbGl0KCdcXFxcJyk7XHJcbiAgICBpZiAoIWJld2l0UGFydHMgfHxcclxuICAgICAgICBiZXdpdFBhcnRzLmxlbmd0aCAhPT0gNCkge1xyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGJld2l0IHN0cnVjdHVyZScpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYmV3aXQgPSB7XHJcbiAgICAgICAgaWQ6IGJld2l0UGFydHNbMF0sXHJcbiAgICAgICAgZXhwOiBwYXJzZUludChiZXdpdFBhcnRzWzFdLCAxMCksXHJcbiAgICAgICAgbWFjOiBiZXdpdFBhcnRzWzJdLFxyXG4gICAgICAgIGV4dDogYmV3aXRQYXJ0c1szXSB8fCAnJ1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIWJld2l0LmlkIHx8XHJcbiAgICAgICAgIWJld2l0LmV4cCB8fFxyXG4gICAgICAgICFiZXdpdC5tYWMpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uYmFkUmVxdWVzdCgnTWlzc2luZyBiZXdpdCBhdHRyaWJ1dGVzJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCBVUkwgd2l0aG91dCBiZXdpdFxyXG5cclxuICAgIHZhciB1cmwgPSByZXNvdXJjZVsxXTtcclxuICAgIGlmIChyZXNvdXJjZVs0XSkge1xyXG4gICAgICAgIHVybCArPSByZXNvdXJjZVsyXSArIHJlc291cmNlWzRdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGV4cGlyYXRpb25cclxuXHJcbiAgICBpZiAoYmV3aXQuZXhwICogMTAwMCA8PSBub3cpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ0FjY2VzcyBleHBpcmVkJywgJ0hhd2snKSwgbnVsbCwgYmV3aXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZldGNoIEhhd2sgY3JlZGVudGlhbHNcclxuXHJcbiAgICBjcmVkZW50aWFsc0Z1bmMoYmV3aXQuaWQsIGZ1bmN0aW9uIChlcnIsIGNyZWRlbnRpYWxzKSB7XHJcblxyXG4gICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgY3JlZGVudGlhbHMgfHwgbnVsbCwgYmV3aXQuZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY3JlZGVudGlhbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdVbmtub3duIGNyZWRlbnRpYWxzJywgJ0hhd2snKSwgbnVsbCwgYmV3aXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscy5rZXkgfHxcclxuICAgICAgICAgICAgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uaW50ZXJuYWwoJ0ludmFsaWQgY3JlZGVudGlhbHMnKSwgY3JlZGVudGlhbHMsIGJld2l0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChDcnlwdG8uYWxnb3JpdGhtcy5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmludGVybmFsKCdVbmtub3duIGFsZ29yaXRobScpLCBjcmVkZW50aWFscywgYmV3aXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIE1BQ1xyXG5cclxuICAgICAgICB2YXIgbWFjID0gQ3J5cHRvLmNhbGN1bGF0ZU1hYygnYmV3aXQnLCBjcmVkZW50aWFscywge1xyXG4gICAgICAgICAgICB0czogYmV3aXQuZXhwLFxyXG4gICAgICAgICAgICBub25jZTogJycsXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgIHJlc291cmNlOiB1cmwsXHJcbiAgICAgICAgICAgIGhvc3Q6IHJlcXVlc3QuaG9zdCxcclxuICAgICAgICAgICAgcG9ydDogcmVxdWVzdC5wb3J0LFxyXG4gICAgICAgICAgICBleHQ6IGJld2l0LmV4dFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoIUNyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKG1hYywgYmV3aXQubWFjKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ0JhZCBtYWMnLCAnSGF3aycpLCBjcmVkZW50aWFscywgYmV3aXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VjY2Vzc2Z1bCBhdXRoZW50aWNhdGlvblxyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY3JlZGVudGlhbHMsIGJld2l0KTtcclxuICAgIH0pO1xyXG59O1xyXG4iLCIvLyBMb2FkIG1vZHVsZXNcclxuXHJcbnZhciBVcmwgPSByZXF1aXJlKCd1cmwnKTtcclxudmFyIEhvZWsgPSByZXF1aXJlKCdob2VrJyk7XHJcbnZhciBDcnlwdGlsZXMgPSByZXF1aXJlKCdjcnlwdGlsZXMnKTtcclxudmFyIENyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJyk7XHJcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcblxyXG4vLyBEZWNsYXJlIGludGVybmFsc1xyXG5cclxudmFyIGludGVybmFscyA9IHt9O1xyXG5cclxuXHJcbi8vIEdlbmVyYXRlIGFuIEF1dGhvcml6YXRpb24gaGVhZGVyIGZvciBhIGdpdmVuIHJlcXVlc3RcclxuXHJcbi8qXHJcbiAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/YT1iJyBvciBvYmplY3QgZnJvbSBVcmwucGFyc2UoKVxyXG4gICAgbWV0aG9kOiBIVFRQIHZlcmIgKGUuZy4gJ0dFVCcsICdQT1NUJylcclxuICAgIG9wdGlvbnM6IHtcclxuXHJcbiAgICAgICAgLy8gUmVxdWlyZWRcclxuXHJcbiAgICAgICAgY3JlZGVudGlhbHM6IHtcclxuICAgICAgICAgICAgaWQ6ICdkaDM3ZmdqNDkyamUnLFxyXG4gICAgICAgICAgICBrZXk6ICdhb2lqZWRvYWlqc2RsYWtzamRsJyxcclxuICAgICAgICAgICAgYWxnb3JpdGhtOiAnc2hhMjU2JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzaGExJywgJ3NoYTI1NidcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBPcHRpb25hbFxyXG5cclxuICAgICAgICBleHQ6ICdhcHBsaWNhdGlvbi1zcGVjaWZpYycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YSBzZW50IHZpYSB0aGUgZXh0IGF0dHJpYnV0ZVxyXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHByZS1jYWxjdWxhdGVkIHRpbWVzdGFtcFxyXG4gICAgICAgIG5vbmNlOiAnMjMzNGYzNGYnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHByZS1nZW5lcmF0ZWQgbm9uY2VcclxuICAgICAgICBsb2NhbHRpbWVPZmZzZXRNc2VjOiA0MDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGltZSBvZmZzZXQgdG8gc3luYyB3aXRoIHNlcnZlciB0aW1lIChpZ25vcmVkIGlmIHRpbWVzdGFtcCBwcm92aWRlZClcclxuICAgICAgICBwYXlsb2FkOiAne1wic29tZVwiOlwicGF5bG9hZFwifScsICAgICAgICAgICAgICAgICAgICAgIC8vIFVURi04IGVuY29kZWQgc3RyaW5nIGZvciBib2R5IGhhc2ggZ2VuZXJhdGlvbiAoaWdub3JlZCBpZiBoYXNoIHByb3ZpZGVkKVxyXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsICAgICAgICAgICAgICAgICAgICAvLyBQYXlsb2FkIGNvbnRlbnQtdHlwZSAoaWdub3JlZCBpZiBoYXNoIHByb3ZpZGVkKVxyXG4gICAgICAgIGhhc2g6ICdVNE1LS1NtaVZ4azM3SkNDckFWSWpWPScsICAgICAgICAgICAgICAgICAgICAvLyBQcmUtY2FsY3VsYXRlZCBwYXlsb2FkIGhhc2hcclxuICAgICAgICBhcHA6ICcyNHMyMzQyM2YzNGR4JywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ogYXBwbGljYXRpb24gaWRcclxuICAgICAgICBkbGc6ICcyMzRzejM0dHd3M3NkJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ogZGVsZWdhdGVkLWJ5IGFwcGxpY2F0aW9uIGlkXHJcbiAgICB9XHJcbiovXHJcblxyXG5leHBvcnRzLmhlYWRlciA9IGZ1bmN0aW9uICh1cmksIG1ldGhvZCwgb3B0aW9ucykge1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgZmllbGQ6ICcnLFxyXG4gICAgICAgIGFydGlmYWN0czoge31cclxuICAgIH07XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgaW5wdXRzXHJcblxyXG4gICAgaWYgKCF1cmkgfHwgKHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB1cmkgIT09ICdvYmplY3QnKSB8fFxyXG4gICAgICAgICFtZXRob2QgfHwgdHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAhb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcHBsaWNhdGlvbiB0aW1lXHJcblxyXG4gICAgdmFyIHRpbWVzdGFtcCA9IG9wdGlvbnMudGltZXN0YW1wIHx8IE1hdGguZmxvb3IoKFV0aWxzLm5vdygpICsgKG9wdGlvbnMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKSkgLyAxMDAwKVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIGNyZWRlbnRpYWxzXHJcblxyXG4gICAgdmFyIGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcclxuICAgIGlmICghY3JlZGVudGlhbHMgfHxcclxuICAgICAgICAhY3JlZGVudGlhbHMuaWQgfHxcclxuICAgICAgICAhY3JlZGVudGlhbHMua2V5IHx8XHJcbiAgICAgICAgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xyXG5cclxuICAgICAgICAvLyBJbnZhbGlkIGNyZWRlbnRpYWwgb2JqZWN0XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgVVJJXHJcblxyXG4gICAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdXJpID0gVXJsLnBhcnNlKHVyaSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHNpZ25hdHVyZVxyXG5cclxuICAgIHZhciBhcnRpZmFjdHMgPSB7XHJcbiAgICAgICAgdHM6IHRpbWVzdGFtcCxcclxuICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSB8fCBDcnlwdGlsZXMucmFuZG9tU3RyaW5nKDYpLFxyXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICAgIHJlc291cmNlOiB1cmkucGF0aG5hbWUgKyAodXJpLnNlYXJjaCB8fCAnJyksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluIHRyYWlsaW5nICc/J1xyXG4gICAgICAgIGhvc3Q6IHVyaS5ob3N0bmFtZSxcclxuICAgICAgICBwb3J0OiB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSAnaHR0cDonID8gODAgOiA0NDMpLFxyXG4gICAgICAgIGhhc2g6IG9wdGlvbnMuaGFzaCxcclxuICAgICAgICBleHQ6IG9wdGlvbnMuZXh0LFxyXG4gICAgICAgIGFwcDogb3B0aW9ucy5hcHAsXHJcbiAgICAgICAgZGxnOiBvcHRpb25zLmRsZ1xyXG4gICAgfTtcclxuXHJcbiAgICByZXN1bHQuYXJ0aWZhY3RzID0gYXJ0aWZhY3RzO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwYXlsb2FkIGhhc2hcclxuXHJcbiAgICBpZiAoIWFydGlmYWN0cy5oYXNoICYmXHJcbiAgICAgICAgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGF5bG9hZCcpKSB7XHJcblxyXG4gICAgICAgIGFydGlmYWN0cy5oYXNoID0gQ3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdGlvbnMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFjID0gQ3J5cHRvLmNhbGN1bGF0ZU1hYygnaGVhZGVyJywgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGhlYWRlclxyXG5cclxuICAgIHZhciBoYXNFeHQgPSBhcnRpZmFjdHMuZXh0ICE9PSBudWxsICYmIGFydGlmYWN0cy5leHQgIT09IHVuZGVmaW5lZCAmJiBhcnRpZmFjdHMuZXh0ICE9PSAnJzsgICAgICAgLy8gT3RoZXIgZmFsc2V5IHZhbHVlcyBhbGxvd2VkXHJcbiAgICB2YXIgaGVhZGVyID0gJ0hhd2sgaWQ9XCInICsgY3JlZGVudGlhbHMuaWQgK1xyXG4gICAgICAgICAgICAgICAgICdcIiwgdHM9XCInICsgYXJ0aWZhY3RzLnRzICtcclxuICAgICAgICAgICAgICAgICAnXCIsIG5vbmNlPVwiJyArIGFydGlmYWN0cy5ub25jZSArXHJcbiAgICAgICAgICAgICAgICAgKGFydGlmYWN0cy5oYXNoID8gJ1wiLCBoYXNoPVwiJyArIGFydGlmYWN0cy5oYXNoIDogJycpICtcclxuICAgICAgICAgICAgICAgICAoaGFzRXh0ID8gJ1wiLCBleHQ9XCInICsgVXRpbHMuZXNjYXBlSGVhZGVyQXR0cmlidXRlKGFydGlmYWN0cy5leHQpIDogJycpICtcclxuICAgICAgICAgICAgICAgICAnXCIsIG1hYz1cIicgKyBtYWMgKyAnXCInO1xyXG5cclxuICAgIGlmIChhcnRpZmFjdHMuYXBwKSB7XHJcbiAgICAgICAgaGVhZGVyICs9ICcsIGFwcD1cIicgKyBhcnRpZmFjdHMuYXBwICtcclxuICAgICAgICAgICAgICAgICAgKGFydGlmYWN0cy5kbGcgPyAnXCIsIGRsZz1cIicgKyBhcnRpZmFjdHMuZGxnIDogJycpICsgJ1wiJztcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQuZmllbGQgPSBoZWFkZXI7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBWYWxpZGF0ZSBzZXJ2ZXIgcmVzcG9uc2VcclxuXHJcbi8qXHJcbiAgICByZXM6ICAgICAgICBub2RlJ3MgcmVzcG9uc2Ugb2JqZWN0XHJcbiAgICBhcnRpZmFjdHM6ICBvYmplY3QgcmVjaWV2ZWQgZnJvbSBoZWFkZXIoKS5hcnRpZmFjdHNcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBwYXlsb2FkOiAgICBvcHRpb25hbCBwYXlsb2FkIHJlY2VpdmVkXHJcbiAgICAgICAgcmVxdWlyZWQ6ICAgc3BlY2lmaWVzIGlmIGEgU2VydmVyLUF1dGhvcml6YXRpb24gaGVhZGVyIGlzIHJlcXVpcmVkLiBEZWZhdWx0cyB0byAnZmFsc2UnXHJcbiAgICB9XHJcbiovXHJcblxyXG5leHBvcnRzLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChyZXMsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICBhcnRpZmFjdHMgPSBIb2VrLmNsb25lKGFydGlmYWN0cyk7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBpZiAocmVzLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXSkge1xyXG5cclxuICAgICAgICAvLyBQYXJzZSBIVFRQIFdXVy1BdXRoZW50aWNhdGUgaGVhZGVyXHJcblxyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gVXRpbHMucGFyc2VBdXRob3JpemF0aW9uSGVhZGVyKHJlcy5oZWFkZXJzWyd3d3ctYXV0aGVudGljYXRlJ10sIFsndHMnLCAndHNtJywgJ2Vycm9yJ10pO1xyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMudHMpIHtcclxuICAgICAgICAgICAgdmFyIHRzbSA9IENyeXB0by5jYWxjdWxhdGVUc01hYyhhdHRyaWJ1dGVzLnRzLCBjcmVkZW50aWFscyk7XHJcbiAgICAgICAgICAgIGlmICh0c20gIT09IGF0dHJpYnV0ZXMudHNtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgSFRUUCBTZXJ2ZXItQXV0aG9yaXphdGlvbiBoZWFkZXJcclxuXHJcbiAgICBpZiAoIXJlcy5oZWFkZXJzWydzZXJ2ZXItYXV0aG9yaXphdGlvbiddICYmXHJcbiAgICAgICAgIW9wdGlvbnMucmVxdWlyZWQpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBVdGlscy5wYXJzZUF1dGhvcml6YXRpb25IZWFkZXIocmVzLmhlYWRlcnNbJ3NlcnZlci1hdXRob3JpemF0aW9uJ10sIFsnbWFjJywgJ2V4dCcsICdoYXNoJ10pO1xyXG4gICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBhcnRpZmFjdHMuZXh0ID0gYXR0cmlidXRlcy5leHQ7XHJcbiAgICBhcnRpZmFjdHMuaGFzaCA9IGF0dHJpYnV0ZXMuaGFzaDtcclxuXHJcbiAgICB2YXIgbWFjID0gQ3J5cHRvLmNhbGN1bGF0ZU1hYygncmVzcG9uc2UnLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgIGlmIChtYWMgIT09IGF0dHJpYnV0ZXMubWFjKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGF5bG9hZCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhdHRyaWJ1dGVzLmhhc2gpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNhbGN1bGF0ZWRIYXNoID0gQ3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdGlvbnMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCByZXMuaGVhZGVyc1snY29udGVudC10eXBlJ10pO1xyXG4gICAgcmV0dXJuIChjYWxjdWxhdGVkSGFzaCA9PT0gYXR0cmlidXRlcy5oYXNoKTtcclxufTtcclxuXHJcblxyXG4vLyBHZW5lcmF0ZSBhIGJld2l0IHZhbHVlIGZvciBhIGdpdmVuIFVSSVxyXG5cclxuLypcclxuICogY3JlZGVudGlhbHMgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBrZXlzOiAnaWQsICdrZXknLCAnYWxnb3JpdGhtJy5cclxuICogb3B0aW9ucyBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIGtleXM6ICdleHQnLCAnbG9jYWx0aW1lT2Zmc2V0TXNlYydcclxuICovXHJcbi8qXHJcbiAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/YT1iJyBvciBvYmplY3QgZnJvbSBVcmwucGFyc2UoKVxyXG4gICAgb3B0aW9uczoge1xyXG5cclxuICAgICAgICAvLyBSZXF1aXJlZFxyXG5cclxuICAgICAgICBjcmVkZW50aWFsczoge1xyXG4gICAgICAgICAgICBpZDogJ2RoMzdmZ2o0OTJqZScsXHJcbiAgICAgICAgICAgIGtleTogJ2FvaWplZG9haWpzZGxha3NqZGwnLFxyXG4gICAgICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc2hhMScsICdzaGEyNTYnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0dGxTZWM6IDYwICogNjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFRMIGluIHNlY29uZHNcclxuXHJcbiAgICAgICAgLy8gT3B0aW9uYWxcclxuXHJcbiAgICAgICAgZXh0OiAnYXBwbGljYXRpb24tc3BlY2lmaWMnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljIGRhdGEgc2VudCB2aWEgdGhlIGV4dCBhdHRyaWJ1dGVcclxuICAgICAgICBsb2NhbHRpbWVPZmZzZXRNc2VjOiA0MDAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGltZSBvZmZzZXQgdG8gc3luYyB3aXRoIHNlcnZlciB0aW1lXHJcbiAgICB9O1xyXG4qL1xyXG5cclxuZXhwb3J0cy5nZXRCZXdpdCA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBpbnB1dHNcclxuXHJcbiAgICBpZiAoIXVyaSB8fFxyXG4gICAgICAgICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdXJpICE9PSAnb2JqZWN0JykgfHxcclxuICAgICAgICAhb3B0aW9ucyB8fFxyXG4gICAgICAgIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICFvcHRpb25zLnR0bFNlYykge1xyXG5cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucy5leHQgPSAob3B0aW9ucy5leHQgPT09IG51bGwgfHwgb3B0aW9ucy5leHQgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5leHQpOyAgICAgICAvLyBaZXJvIGlzIHZhbGlkIHZhbHVlXHJcblxyXG4gICAgLy8gQXBwbGljYXRpb24gdGltZVxyXG5cclxuICAgIHZhciBub3cgPSBVdGlscy5ub3coKSArIChvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgY3JlZGVudGlhbHNcclxuXHJcbiAgICB2YXIgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xyXG4gICAgaWYgKCFjcmVkZW50aWFscyB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5pZCB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5rZXkgfHxcclxuICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQ3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBVUklcclxuXHJcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB1cmkgPSBVcmwucGFyc2UodXJpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc2lnbmF0dXJlXHJcblxyXG4gICAgdmFyIGV4cCA9IE1hdGguZmxvb3Iobm93IC8gMTAwMCkgKyBvcHRpb25zLnR0bFNlYztcclxuICAgIHZhciBtYWMgPSBDcnlwdG8uY2FsY3VsYXRlTWFjKCdiZXdpdCcsIGNyZWRlbnRpYWxzLCB7XHJcbiAgICAgICAgdHM6IGV4cCxcclxuICAgICAgICBub25jZTogJycsXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICByZXNvdXJjZTogdXJpLnBhdGhuYW1lICsgKHVyaS5zZWFyY2ggfHwgJycpLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWludGFpbiB0cmFpbGluZyAnPydcclxuICAgICAgICBob3N0OiB1cmkuaG9zdG5hbWUsXHJcbiAgICAgICAgcG9ydDogdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IDgwIDogNDQzKSxcclxuICAgICAgICBleHQ6IG9wdGlvbnMuZXh0XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgYmV3aXQ6IGlkXFxleHBcXG1hY1xcZXh0XHJcblxyXG4gICAgdmFyIGJld2l0ID0gY3JlZGVudGlhbHMuaWQgKyAnXFxcXCcgKyBleHAgKyAnXFxcXCcgKyBtYWMgKyAnXFxcXCcgKyBvcHRpb25zLmV4dDtcclxuICAgIHJldHVybiBVdGlscy5iYXNlNjR1cmxFbmNvZGUoYmV3aXQpO1xyXG59O1xyXG5cclxuIiwiKGZ1bmN0aW9uKF9fZGlybmFtZSl7Ly8gTG9hZCBtb2R1bGVzXG5cbnZhciBIb2VrID0gcmVxdWlyZSgnaG9laycpO1xudmFyIFNudHAgPSByZXF1aXJlKCdzbnRwJyk7XG52YXIgQm9vbSA9IHJlcXVpcmUoJ2Jvb20nKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge307XG5cblxuLy8gSW1wb3J0IEhvZWsgVXRpbGl0aWVzXG5cbmludGVybmFscy5pbXBvcnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBmb3IgKHZhciBpIGluIEhvZWspIHtcbiAgICAgICAgaWYgKEhvZWsuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIGV4cG9ydHNbaV0gPSBIb2VrW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuaW50ZXJuYWxzLmltcG9ydCgpO1xuXG5cbi8vIEhhd2sgdmVyc2lvblxuXG5leHBvcnRzLnZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5sb2FkUGFja2FnZShfX2Rpcm5hbWUgKyAnLy4uJykudmVyc2lvbjtcbn07XG5cblxuLy8gRXh0cmFjdCBob3N0IGFuZCBwb3J0IGZyb20gcmVxdWVzdFxuXG5leHBvcnRzLnBhcnNlSG9zdCA9IGZ1bmN0aW9uIChyZXEsIGhvc3RIZWFkZXJOYW1lKSB7XG5cbiAgICBob3N0SGVhZGVyTmFtZSA9IChob3N0SGVhZGVyTmFtZSA/IGhvc3RIZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkgOiAnaG9zdCcpO1xuICAgIHZhciBob3N0SGVhZGVyID0gcmVxLmhlYWRlcnNbaG9zdEhlYWRlck5hbWVdO1xuICAgIGlmICghaG9zdEhlYWRlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaG9zdEhlYWRlclJlZ2V4ID0gL14oPzooPzpcXHJcXG4pP1tcXHQgXSkqKFteOl0rKSg/OjooXFxkKykpPyg/Oig/Olxcclxcbik/W1xcdCBdKSokLzsgICAgIC8vIERvZXMgbm90IHN1cHBvcnQgSVB2NlxuICAgIHZhciBob3N0UGFydHMgPSBob3N0SGVhZGVyLm1hdGNoKGhvc3RIZWFkZXJSZWdleCk7XG5cbiAgICBpZiAoIWhvc3RQYXJ0cyB8fFxuICAgICAgICBob3N0UGFydHMubGVuZ3RoICE9PSAzIHx8XG4gICAgICAgICFob3N0UGFydHNbMV0pIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBob3N0UGFydHNbMV0sXG4gICAgICAgIHBvcnQ6IChob3N0UGFydHNbMl0gPyBob3N0UGFydHNbMl0gOiAocmVxLmNvbm5lY3Rpb24gJiYgcmVxLmNvbm5lY3Rpb24uZW5jcnlwdGVkID8gNDQzIDogODApKVxuICAgIH07XG59O1xuXG5cbi8vIFBhcnNlIENvbnRlbnQtVHlwZSBoZWFkZXIgY29udGVudFxuXG5leHBvcnRzLnBhcnNlQ29udGVudFR5cGUgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlci5zcGxpdCgnOycpWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXG4vLyBDb252ZXJ0IG5vZGUncyAgdG8gcmVxdWVzdCBjb25maWd1cmF0aW9uIG9iamVjdFxuXG5leHBvcnRzLnBhcnNlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEsIG9wdGlvbnMpIHtcblxuICAgIGlmICghcmVxLmhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG5cbiAgICAvLyBPYnRhaW4gaG9zdCBhbmQgcG9ydCBpbmZvcm1hdGlvblxuXG4gICAgdmFyIGhvc3QgPSBleHBvcnRzLnBhcnNlSG9zdChyZXEsIG9wdGlvbnMuaG9zdEhlYWRlck5hbWUpO1xuICAgIGlmICghaG9zdCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIEhvc3QgaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgdXJsOiByZXEudXJsLFxuICAgICAgICBob3N0OiBob3N0Lm5hbWUsXG4gICAgICAgIHBvcnQ6IGhvc3QucG9ydCxcbiAgICAgICAgYXV0aG9yaXphdGlvbjogcmVxLmhlYWRlcnMuYXV0aG9yaXphdGlvbixcbiAgICAgICAgY29udGVudFR5cGU6IHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJ1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbn07XG5cblxuZXhwb3J0cy5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gU250cC5ub3coKTtcbn07XG5cblxuLy8gUGFyc2UgSGF3ayBIVFRQIEF1dGhvcml6YXRpb24gaGVhZGVyXG5cbmV4cG9ydHMucGFyc2VBdXRob3JpemF0aW9uSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwga2V5cykge1xuXG4gICAga2V5cyA9IGtleXMgfHwgWydpZCcsICd0cycsICdub25jZScsICdoYXNoJywgJ2V4dCcsICdtYWMnLCAnYXBwJywgJ2RsZyddO1xuXG4gICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIEJvb20udW5hdXRob3JpemVkKG51bGwsICdIYXdrJyk7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlclBhcnRzID0gaGVhZGVyLm1hdGNoKC9eKFxcdyspKD86XFxzKyguKikpPyQvKTsgICAgICAgLy8gSGVhZGVyOiBzY2hlbWVbIHNvbWV0aGluZ11cbiAgICBpZiAoIWhlYWRlclBhcnRzKSB7XG4gICAgICAgIHJldHVybiBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgaGVhZGVyIHN5bnRheCcpO1xuICAgIH1cblxuICAgIHZhciBzY2hlbWUgPSBoZWFkZXJQYXJ0c1sxXTtcbiAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT09ICdoYXdrJykge1xuICAgICAgICByZXR1cm4gQm9vbS51bmF1dGhvcml6ZWQobnVsbCwgJ0hhd2snKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlc1N0cmluZyA9IGhlYWRlclBhcnRzWzJdO1xuICAgIGlmICghYXR0cmlidXRlc1N0cmluZykge1xuICAgICAgICByZXR1cm4gQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGhlYWRlciBzeW50YXgnKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcbiAgICB2YXIgdmVyaWZ5ID0gYXR0cmlidXRlc1N0cmluZy5yZXBsYWNlKC8oXFx3Kyk9XCIoW15cIlxcXFxdKilcIlxccyooPzosXFxzKnwkKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuXG4gICAgICAgIC8vIENoZWNrIHZhbGlkIGF0dHJpYnV0ZSBuYW1lc1xuXG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoJDEpID09PSAtMSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1Vua25vd24gYXR0cmlidXRlOiAnICsgJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvd2VkIGF0dHJpYnV0ZSB2YWx1ZSBjaGFyYWN0ZXJzOiAhIyQlJicoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4gYW5kIHNwYWNlLCBhLXosIEEtWiwgMC05XG5cbiAgICAgICAgaWYgKCQyLm1hdGNoKC9eWyBcXHdcXCEjXFwkJSYnXFwoXFwpXFwqXFwrLFxcLVxcLlxcL1xcOjs8XFw9PlxcP0BcXFtcXF1cXF5gXFx7XFx8XFx9fl0rJC8pID09PSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQmFkIGF0dHJpYnV0ZSB2YWx1ZTogJyArICQxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcblxuICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSgkMSkpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdEdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVzWyQxXSA9ICQyO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG5cbiAgICBpZiAodmVyaWZ5ICE9PSAnJykge1xuICAgICAgICByZXR1cm4gQm9vbS5iYWRSZXF1ZXN0KGVycm9yTWVzc2FnZSB8fCAnQmFkIGhlYWRlciBmb3JtYXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cblxuZXhwb3J0cy51bmF1dGhvcml6ZWQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgcmV0dXJuIEJvb20udW5hdXRob3JpemVkKG1lc3NhZ2UsICdIYXdrJyk7XG59O1xuXG5cbn0pKFwiL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2xpYlwiKSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5ZWRTdHJlYW07XG5mdW5jdGlvbiBEZWxheWVkU3RyZWFtKCkge1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMTAyNCAqIDEwMjQ7XG4gIHRoaXMucGF1c2VTdHJlYW0gPSB0cnVlO1xuXG4gIHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQgPSBmYWxzZTtcbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMgPSBbXTtcbn1cbnV0aWwuaW5oZXJpdHMoRGVsYXllZFN0cmVhbSwgU3RyZWFtKTtcblxuRGVsYXllZFN0cmVhbS5jcmVhdGUgPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGRlbGF5ZWRTdHJlYW0gPSBuZXcgdGhpcygpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGRlbGF5ZWRTdHJlYW1bb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgfVxuXG4gIGRlbGF5ZWRTdHJlYW0uc291cmNlID0gc291cmNlO1xuXG4gIHZhciByZWFsRW1pdCA9IHNvdXJjZS5lbWl0O1xuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGF5ZWRTdHJlYW0uX2hhbmRsZUVtaXQoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVhbEVtaXQuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcbiAgaWYgKGRlbGF5ZWRTdHJlYW0ucGF1c2VTdHJlYW0pIHtcbiAgICBzb3VyY2UucGF1c2UoKTtcbiAgfVxuXG4gIHJldHVybiBkZWxheWVkU3RyZWFtO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWRhYmxlO1xufSk7XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbGVhc2VkKSB7XG4gICAgdGhpcy5yZWxlYXNlKCk7XG4gIH1cblxuICB0aGlzLnNvdXJjZS5yZXN1bWUoKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc291cmNlLnBhdXNlKCk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JlbGVhc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9idWZmZXJlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzID0gW107XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByID0gU3RyZWFtLnByb3RvdHlwZS5waXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMucmVzdW1lKCk7XG4gIHJldHVybiByO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUuX2hhbmRsZUVtaXQgPSBmdW5jdGlvbihhcmdzKSB7XG4gIGlmICh0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYXJnc1swXSA9PT0gJ2RhdGEnKSB7XG4gICAgdGhpcy5kYXRhU2l6ZSArPSBhcmdzWzFdLmxlbmd0aDtcbiAgICB0aGlzLl9jaGVja0lmTWF4RGF0YVNpemVFeGNlZWRlZCgpO1xuICB9XG5cbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMucHVzaChhcmdzKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9jaGVja0lmTWF4RGF0YVNpemVFeGNlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmRhdGFTaXplIDw9IHRoaXMubWF4RGF0YVNpemUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9tYXhEYXRhU2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdEZWxheWVkU3RyZWFtI21heERhdGFTaXplIG9mICcgKyB0aGlzLm1heERhdGFTaXplICsgJyBieXRlcyBleGNlZWRlZC4nXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbnZhciBSZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xudmFyIFdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cblxuLy8vLS0tIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgUmVhZGVyOiBSZWFkZXIsXG5cbiAgV3JpdGVyOiBXcml0ZXJcblxufTtcblxuZm9yICh2YXIgdCBpbiB0eXBlcykge1xuICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkodCkpXG4gICAgbW9kdWxlLmV4cG9ydHNbdF0gPSB0eXBlc1t0XTtcbn1cbmZvciAodmFyIGUgaW4gZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMuaGFzT3duUHJvcGVydHkoZSkpXG4gICAgbW9kdWxlLmV4cG9ydHNbZV0gPSBlcnJvcnNbZV07XG59XG4iLG51bGwsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBuZXdJbnZhbGlkQXNuMUVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICAgIGUubmFtZSA9ICdJbnZhbGlkQXNuMUVycm9yJztcbiAgICBlLm1lc3NhZ2UgPSBtc2cgfHwgJyc7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxufTtcbiIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRU9DOiAwLFxuICBCb29sZWFuOiAxLFxuICBJbnRlZ2VyOiAyLFxuICBCaXRTdHJpbmc6IDMsXG4gIE9jdGV0U3RyaW5nOiA0LFxuICBOdWxsOiA1LFxuICBPSUQ6IDYsXG4gIE9iamVjdERlc2NyaXB0b3I6IDcsXG4gIEV4dGVybmFsOiA4LFxuICBSZWFsOiA5LCAvLyBmbG9hdFxuICBFbnVtZXJhdGlvbjogMTAsXG4gIFBEVjogMTEsXG4gIFV0ZjhTdHJpbmc6IDEyLFxuICBSZWxhdGl2ZU9JRDogMTMsXG4gIFNlcXVlbmNlOiAxNixcbiAgU2V0OiAxNyxcbiAgTnVtZXJpY1N0cmluZzogMTgsXG4gIFByaW50YWJsZVN0cmluZzogMTksXG4gIFQ2MVN0cmluZzogMjAsXG4gIFZpZGVvdGV4U3RyaW5nOiAyMSxcbiAgSUE1U3RyaW5nOiAyMixcbiAgVVRDVGltZTogMjMsXG4gIEdlbmVyYWxpemVkVGltZTogMjQsXG4gIEdyYXBoaWNTdHJpbmc6IDI1LFxuICBWaXNpYmxlU3RyaW5nOiAyNixcbiAgR2VuZXJhbFN0cmluZzogMjgsXG4gIFVuaXZlcnNhbFN0cmluZzogMjksXG4gIENoYXJhY3RlclN0cmluZzogMzAsXG4gIEJNUFN0cmluZzogMzEsXG4gIENvbnN0cnVjdG9yOiAzMixcbiAgQ29udGV4dDogMTI4XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCIoZnVuY3Rpb24oQnVmZmVyKXsvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxudmFyIERFRkFVTFRfT1BUUyA9IHtcbiAgc2l6ZTogMTAyNCxcbiAgZ3Jvd3RoRmFjdG9yOiA4XG59O1xuXG5cbi8vLy0tLSBIZWxwZXJzXG5cbmZ1bmN0aW9uIG1lcmdlKGZyb20sIHRvKSB7XG4gIGFzc2VydC5vayhmcm9tKTtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZihmcm9tKSwgJ29iamVjdCcpO1xuICBhc3NlcnQub2sodG8pO1xuICBhc3NlcnQuZXF1YWwodHlwZW9mKHRvKSwgJ29iamVjdCcpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAodG9ba2V5XSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gdG87XG59XG5cblxuXG4vLy8tLS0gQVBJXG5cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBtZXJnZShERUZBVUxUX09QVFMsIG9wdGlvbnMgfHwge30pO1xuXG4gIHRoaXMuX2J1ZiA9IG5ldyBCdWZmZXIob3B0aW9ucy5zaXplIHx8IDEwMjQpO1xuICB0aGlzLl9zaXplID0gdGhpcy5fYnVmLmxlbmd0aDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgLy8gQSBsaXN0IG9mIG9mZnNldHMgaW4gdGhlIGJ1ZmZlciB3aGVyZSB3ZSBuZWVkIHRvIGluc2VydFxuICAvLyBzZXF1ZW5jZSB0YWcvbGVuIHBhaXJzLlxuICB0aGlzLl9zZXEgPSBbXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnYnVmZmVyJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX3NlcS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFzbjFFcnJvcihzZWxmLl9zZXEubGVuZ3RoICsgJyB1bmVuZGVkIHNlcXVlbmNlKHMpJyk7XG5cbiAgICByZXR1cm4gc2VsZi5fYnVmLnNsaWNlKDAsIHNlbGYuX29mZnNldCk7XG4gIH0pO1xufVxuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24oYikge1xuICBpZiAodHlwZW9mKGIpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDEpO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gYjtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUludCA9IGZ1bmN0aW9uKGksIHRhZykge1xuICBpZiAodHlwZW9mKGkpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5JbnRlZ2VyO1xuXG4gIHZhciBzeiA9IDQ7XG5cbiAgd2hpbGUgKCgoKGkgJiAweGZmODAwMDAwKSA9PT0gMCkgfHwgKChpICYgMHhmZjgwMDAwMCkgPT09IDB4ZmY4MDAwMDApKSAmJlxuICAgICAgICAgKHN6ID4gMSkpIHtcbiAgICBzei0tO1xuICAgIGkgPDw9IDg7XG4gIH1cblxuICBpZiAoc3ogPiA0KVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXNuMUVycm9yKCdCRVIgaW50cyBjYW5ub3QgYmUgPiAweGZmZmZmZmZmJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDIgKyBzeik7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSB0YWc7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBzejtcblxuICB3aGlsZSAoc3otLSA+IDApIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gKChpICYgMHhmZjAwMDAwMCkgPj4gMjQpO1xuICAgIGkgPDw9IDg7XG4gIH1cblxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTnVsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnl0ZShBU04xLk51bGwpO1xuICB0aGlzLndyaXRlQnl0ZSgweDAwKTtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUVudW1lcmF0aW9uID0gZnVuY3Rpb24oaSwgdGFnKSB7XG4gIGlmICh0eXBlb2YoaSkgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgaWYgKHR5cGVvZih0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkVudW1lcmF0aW9uO1xuXG4gIHJldHVybiB0aGlzLndyaXRlSW50KGksIHRhZyk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCb29sZWFuID0gZnVuY3Rpb24oYiwgdGFnKSB7XG4gIGlmICh0eXBlb2YoYikgIT09ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuQm9vbGVhbjtcblxuICB0aGlzLl9lbnN1cmUoMyk7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSB0YWc7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSAweDAxO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gYiA/IDB4ZmYgOiAweDAwO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24ocywgdGFnKSB7XG4gIGlmICh0eXBlb2YocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgKHdhczogJyArIHR5cGVvZihzKSArICcpJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PY3RldFN0cmluZztcblxuICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocyk7XG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgobGVuKTtcbiAgaWYgKGxlbikge1xuICAgIHRoaXMuX2Vuc3VyZShsZW4pO1xuICAgIHRoaXMuX2J1Zi53cml0ZShzLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX29mZnNldCArPSBsZW47XG4gIH1cbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZiwgdGFnKSB7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFnIG11c3QgYmUgYSBudW1iZXInKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgYnVmZmVyJyk7XG5cbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChidWYubGVuZ3RoKTtcbiAgdGhpcy5fZW5zdXJlKGJ1Zi5sZW5ndGgpO1xuICBidWYuY29weSh0aGlzLl9idWYsIHRoaXMuX29mZnNldCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSBidWYubGVuZ3RoO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nQXJyYXkgPSBmdW5jdGlvbihzdHJpbmdzKSB7XG4gIGlmICgoIXN0cmluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheVtTdHJpbmddJyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHNlbGYud3JpdGVTdHJpbmcocyk7XG4gIH0pO1xufTtcblxuLy8gVGhpcyBpcyByZWFsbHkgdG8gc29sdmUgREVSIGNhc2VzLCBidXQgd2hhdGV2ZXIgZm9yIG5vd1xuV3JpdGVyLnByb3RvdHlwZS53cml0ZU9JRCA9IGZ1bmN0aW9uKHMsIHRhZykge1xuICBpZiAodHlwZW9mKHMpICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgaWYgKCEvXihbMC05XStcXC4pezMsfVswLTldKyQvLnRlc3QocykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBPSUQgc3RyaW5nJyk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlT2N0ZXQoYnl0ZXMsIG9jdGV0KSB7XG4gICAgaWYgKG9jdGV0IDwgMTI4KSB7XG4gICAgICAgIGJ5dGVzLnB1c2gob2N0ZXQpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAxNjM4NCkge1xuICAgICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gNykgfCAweDgwKTtcbiAgICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAyMDk3MTUyKSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMTQpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMjY4NDM1NDU2KSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMjEpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyOCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyMSkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAxNCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRtcCA9IHMuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gW107XG4gIGJ5dGVzLnB1c2gocGFyc2VJbnQodG1wWzBdLCAxMCkgKiA0MCArIHBhcnNlSW50KHRtcFsxXSwgMTApKTtcbiAgdG1wLnNsaWNlKDIpLmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgIGVuY29kZU9jdGV0KGJ5dGVzLCBwYXJzZUludChiLCAxMCkpO1xuICB9KTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2Vuc3VyZSgyICsgYnl0ZXMubGVuZ3RoKTtcbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChieXRlcy5sZW5ndGgpO1xuICBieXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICBzZWxmLndyaXRlQnl0ZShiKTtcbiAgfSk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVMZW5ndGggPSBmdW5jdGlvbihsZW4pIHtcbiAgaWYgKHR5cGVvZihsZW4pICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDQpO1xuXG4gIGlmIChsZW4gPD0gMHg3Zikge1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICB0aGlzLl9zaGlmdChzdGFydCwgbGVuLCAxKTtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MztcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDE2O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXNuMUVScm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5zdGFydFNlcXVlbmNlID0gZnVuY3Rpb24odGFnKSB7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5TZXF1ZW5jZSB8IEFTTjEuQ29uc3RydWN0b3I7XG5cbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy5fc2VxLnB1c2godGhpcy5fb2Zmc2V0KTtcbiAgdGhpcy5fZW5zdXJlKDMpO1xuICB0aGlzLl9vZmZzZXQgKz0gMztcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS5lbmRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VxID0gdGhpcy5fc2VxLnBvcCgpO1xuICB2YXIgc3RhcnQgPSBzZXEgKyAzO1xuICB2YXIgbGVuID0gdGhpcy5fb2Zmc2V0IC0gc3RhcnQ7XG5cbiAgaWYgKGxlbiA8PSAweDdmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTIpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTEpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZikge1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgMSk7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgzO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgM10gPSBsZW47XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBc24xRXJyb3IoJ1NlcXVlbmNlIHRvbyBsb25nJyk7XG4gIH1cbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS5fc2hpZnQgPSBmdW5jdGlvbihzdGFydCwgbGVuLCBzaGlmdCkge1xuICBhc3NlcnQub2soc3RhcnQgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhsZW4gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhzaGlmdCk7XG5cbiAgdGhpcy5fYnVmLmNvcHkodGhpcy5fYnVmLCBzdGFydCArIHNoaWZ0LCBzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB0aGlzLl9vZmZzZXQgKz0gc2hpZnQ7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLl9lbnN1cmUgPSBmdW5jdGlvbihsZW4pIHtcbiAgYXNzZXJ0Lm9rKGxlbik7XG5cbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCBsZW4pIHtcbiAgICB2YXIgc3ogPSB0aGlzLl9zaXplICogdGhpcy5fb3B0aW9ucy5ncm93dGhGYWN0b3I7XG4gICAgaWYgKHN6IC0gdGhpcy5fb2Zmc2V0IDwgbGVuKVxuICAgICAgc3ogKz0gbGVuO1xuXG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3opO1xuXG4gICAgdGhpcy5fYnVmLmNvcHkoYnVmLCAwLCAwLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX2J1ZiA9IGJ1ZjtcbiAgICB0aGlzLl9zaXplID0gc3o7XG4gIH1cbn07XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7Ly8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxuXG5cbi8vLy0tLSBBUElcblxuZnVuY3Rpb24gUmVhZGVyKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGEgbm9kZSBCdWZmZXInKTtcblxuICB0aGlzLl9idWYgPSBkYXRhO1xuICB0aGlzLl9zaXplID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gVGhlc2UgaG9sZCB0aGUgXCJjdXJyZW50XCIgc3RhdGVcbiAgdGhpcy5fbGVuID0gMDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnbGVuZ3RoJywgZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLl9sZW47IH0pO1xuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ29mZnNldCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5fb2Zmc2V0OyB9KTtcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdyZW1haW4nLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5fc2l6ZSAtIHNlbGYuX29mZnNldDtcbiAgfSk7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnYnVmZmVyJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuX2J1Zi5zbGljZShzZWxmLl9vZmZzZXQpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlYWRzIGEgc2luZ2xlIGJ5dGUgYW5kIGFkdmFuY2VzIG9mZnNldDsgeW91IGNhbiBwYXNzIGluIGB0cnVlYCB0byBtYWtlIHRoaXNcbiAqIGEgXCJwZWVrXCIgb3BlcmF0aW9uIChpLmUuLCBnZXQgdGhlIGJ5dGUsIGJ1dCBkb24ndCBhZHZhbmNlIHRoZSBvZmZzZXQpLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVlayB0cnVlIG1lYW5zIGRvbid0IG1vdmUgb2Zmc2V0LlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgbmV4dCBieXRlLCBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YS5cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uKHBlZWspIHtcbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCAxKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBiID0gdGhpcy5fYnVmW3RoaXMuX29mZnNldF0gJiAweGZmO1xuXG4gIGlmICghcGVlaylcbiAgICB0aGlzLl9vZmZzZXQgKz0gMTtcblxuICByZXR1cm4gYjtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRCeXRlKHRydWUpO1xufTtcblxuXG4vKipcbiAqIFJlYWRzIGEgKHBvdGVudGlhbGx5KSB2YXJpYWJsZSBsZW5ndGggb2ZmIHRoZSBCRVIgYnVmZmVyLiAgVGhpcyBjYWxsIGlzXG4gKiBub3QgcmVhbGx5IG1lYW50IHRvIGJlIGNhbGxlZCBkaXJlY3RseSwgYXMgY2FsbGVycyBoYXZlIHRvIG1hbmlwdWxhdGVcbiAqIHRoZSBpbnRlcm5hbCBidWZmZXIgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNhbGwsIHlvdSBjYW4gY2FsbCBgUmVhZGVyLmxlbmd0aGAsIHVudGlsIHRoZVxuICogbmV4dCB0aGluZyBjYWxsZWQgdGhhdCBkb2VzIGEgcmVhZExlbmd0aC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbW91bnQgb2Ygb2Zmc2V0IHRvIGFkdmFuY2UgdGhlIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge0ludmFsaWRBc24xRXJyb3J9IG9uIGJhZCBBU04uMVxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRMZW5ndGggPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuICAgIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICBpZiAob2Zmc2V0ID49IHRoaXMuX3NpemUpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbkIgPSB0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZjtcbiAgaWYgKGxlbkIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKChsZW5CICYgMHg4MCkgPT0gMHg4MCkge1xuICAgIGxlbkIgJj0gMHg3ZjtcblxuICAgIGlmIChsZW5CID09IDApXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAobGVuQiA+IDQpXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdlbmNvZGluZyB0b28gbG9uZycpO1xuXG4gICAgaWYgKHRoaXMuX3NpemUgLSBvZmZzZXQgPCBsZW5CKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuQjsgaSsrKVxuICAgICAgdGhpcy5fbGVuID0gKHRoaXMuX2xlbiA8PCA4KSArICh0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBXYXNuJ3QgYSB2YXJpYWJsZSBsZW5ndGhcbiAgICB0aGlzLl9sZW4gPSBsZW5CO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cblxuLyoqXG4gKiBQYXJzZXMgdGhlIG5leHQgc2VxdWVuY2UgaW4gdGhpcyBCRVIgYnVmZmVyLlxuICpcbiAqIFRvIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSwgY2FsbCBgUmVhZGVyLmxlbmd0aGAuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgc2VxdWVuY2UncyB0YWcuXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZFNlcXVlbmNlID0gZnVuY3Rpb24odGFnKSB7XG4gIHZhciBzZXEgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKHNlcSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkICYmIHRhZyAhPT0gc2VxKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIHNlcS50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcbiAgcmV0dXJuIHNlcTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkVGFnKEFTTjEuSW50ZWdlcik7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9yZWFkVGFnKEFTTjEuQm9vbGVhbikgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZFRhZyhBU04xLkVudW1lcmF0aW9uKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24odGFnLCByZXRidWYpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PY3RldFN0cmluZztcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYiAhPT0gdGFnKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIGIudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG5cbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5fc2l6ZSAtIG8pXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICcnO1xuXG4gIHZhciBzdHIgPSB0aGlzLl9idWYuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSB0aGlzLmxlbmd0aDtcblxuICByZXR1cm4gcmV0YnVmID8gc3RyIDogc3RyLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRPSUQgPSBmdW5jdGlvbih0YWcpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGIgIT09IHRhZylcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBiLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuICBpZiAobyA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLl9zaXplIC0gbylcbiAgICByZXR1cm4gbnVsbDtcblxuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHZhbHVlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gJiAweGZmO1xuXG4gICAgdmFsdWUgPDw9IDc7XG4gICAgdmFsdWUgKz0gYnl0ZSAmIDB4N2Y7XG4gICAgaWYgKChieXRlICYgMHg4MCkgPT0gMCkge1xuICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhbHVlID0gdmFsdWVzLnNoaWZ0KCk7XG4gIHZhbHVlcy51bnNoaWZ0KHZhbHVlICUgNDApO1xuICB2YWx1ZXMudW5zaGlmdCgodmFsdWUgLyA0MCkgPj4gMCk7XG5cbiAgcmV0dXJuIHZhbHVlcy5qb2luKCcuJyk7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUuX3JlYWRUYWcgPSBmdW5jdGlvbih0YWcpIHtcbiAgYXNzZXJ0Lm9rKHRhZyAhPT0gdW5kZWZpbmVkKTtcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuXG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChiICE9PSB0YWcpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgYi50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gNClcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbnRlZ2VyIHRvbyBsb25nOiAnICsgdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMuX3NpemUgLSBvKVxuICAgIHJldHVybiBudWxsO1xuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIHZhciBmYiA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK107XG4gIHZhciB2YWx1ZSA9IDA7XG5cbiAgdmFsdWUgPSBmYiAmIDB4N0Y7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlIDw8PSA4O1xuICAgIHZhbHVlIHw9ICh0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdICYgMHhmZik7XG4gIH1cblxuICBpZiAoKGZiICYgMHg4MCkgPT0gMHg4MClcbiAgICB2YWx1ZSA9IC12YWx1ZTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gTG9hZCBtb2R1bGVzXHJcblxyXG52YXIgRnMgPSByZXF1aXJlKCdmcycpO1xyXG52YXIgRXNjYXBlID0gcmVxdWlyZSgnLi9lc2NhcGUnKTtcclxuXHJcblxyXG4vLyBEZWNsYXJlIGludGVybmFsc1xyXG5cclxudmFyIGludGVybmFscyA9IHt9O1xyXG5cclxuXHJcbi8vIENsb25lIG9iamVjdCBvciBhcnJheVxyXG5cclxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIHNlZW4pIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICBvYmogPT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBzZWVuID0gc2VlbiB8fCB7IG9yaWc6IFtdLCBjb3B5OiBbXSB9O1xyXG5cclxuICAgIHZhciBsb29rdXAgPSBzZWVuLm9yaWcuaW5kZXhPZihvYmopO1xyXG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gc2Vlbi5jb3B5W2xvb2t1cF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5ld09iaiA9IChvYmogaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xyXG5cclxuICAgIHNlZW4ub3JpZy5wdXNoKG9iaik7XHJcbiAgICBzZWVuLmNvcHkucHVzaChuZXdPYmopO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAob2JqW2ldIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgQnVmZmVyKG9ialtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IERhdGUob2JqW2ldLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAnJyArIChvYmpbaV0uZ2xvYmFsID8gJ2cnIDogJycpICsgKG9ialtpXS5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKG9ialtpXS5tdWx0aWxpbmUgPyAnbScgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgUmVnRXhwKG9ialtpXS5zb3VyY2UsIGZsYWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IGV4cG9ydHMuY2xvbmUob2JqW2ldLCBzZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3T2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIE1lcmdlIGFsbCB0aGUgcHJvcGVydGllcyBvZiBzb3VyY2UgaW50byB0YXJnZXQsIHNvdXJjZSB3aW5zIGluIGNvbmZsaWMsIGFuZCBieSBkZWZhdWx0IG51bGwgYW5kIHVuZGVmaW5lZCBmcm9tIHNvdXJjZSBhcmUgYXBwbGllZFxyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgaXNOdWxsT3ZlcnJpZGUgLyogPSB0cnVlICovLCBpc01lcmdlQXJyYXlzIC8qID0gdHJ1ZSAqLykge1xyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnLCAnSW52YWxpZCB0YXJnZXQgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICBleHBvcnRzLmFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSwgJ0Nhbm5vdCBtZXJnZSBhcnJheSBvbnRvIGFuIG9iamVjdCcpO1xyXG4gICAgICAgIGlmIChpc01lcmdlQXJyYXlzID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNNZXJnZUFycmF5cyBkZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IG5vdCBjaGFuZ2UgdGFyZ2V0IGFzc2lnbm1lbnRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFtrZXldICE9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5jbG9uZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgaXNOdWxsT3ZlcnJpZGUsIGlzTWVyZ2VBcnJheXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgIC8vIEV4cGxpY2l0IHRvIHByZXNlcnZlIGVtcHR5IHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsT3ZlcnJpZGUgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcblxyXG4vLyBBcHBseSBvcHRpb25zIHRvIGEgY29weSBvZiB0aGUgZGVmYXVsdHNcclxuXHJcbmV4cG9ydHMuYXBwbHlUb0RlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09ICdvYmplY3QnLCAnSW52YWxpZCBkZWZhdWx0cyB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgIGV4cG9ydHMuYXNzZXJ0KCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zIHZhbHVlOiBtdXN0IGJlIHRydWUsIGZhbHN5IG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghb3B0aW9ucykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBvcHRpb25zLCByZXR1cm4gbnVsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb3B5ID0gZXhwb3J0cy5jbG9uZShkZWZhdWx0cyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGlvbnMgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHBvcnRzLm1lcmdlKGNvcHksIG9wdGlvbnMsIGZhbHNlLCBmYWxzZSk7XHJcbn07XHJcblxyXG5cclxuLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpdGVtcyBmcm9tIGFycmF5XHJcblxyXG5leHBvcnRzLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSwga2V5KSB7XHJcblxyXG4gICAgdmFyIGluZGV4ID0ge307XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBpZCA9IChrZXkgPyBhcnJheVtpXVtrZXldIDogYXJyYXlbaV0pO1xyXG4gICAgICAgIGlmIChpbmRleFtpZF0gIT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgICAgICAgICAgaW5kZXhbaWRdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBDb252ZXJ0IGFycmF5IGludG8gb2JqZWN0XHJcblxyXG5leHBvcnRzLm1hcFRvT2JqZWN0ID0gZnVuY3Rpb24gKGFycmF5LCBrZXkpIHtcclxuXHJcbiAgICBpZiAoIWFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG9ialthcnJheVtpXVtrZXldXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ialthcnJheVtpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIEZpbmQgdGhlIGNvbW1vbiB1bmlxdWUgaXRlbXMgaW4gdHdvIGFycmF5c1xyXG5cclxuZXhwb3J0cy5pbnRlcnNlY3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcclxuXHJcbiAgICBpZiAoIWFycmF5MSB8fCAhYXJyYXkyKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21tb24gPSBbXTtcclxuICAgIHZhciBoYXNoID0gKGFycmF5MSBpbnN0YW5jZW9mIEFycmF5ID8gZXhwb3J0cy5tYXBUb09iamVjdChhcnJheTEpIDogYXJyYXkxKTtcclxuICAgIHZhciBmb3VuZCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkyLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoaGFzaFthcnJheTJbaV1dICYmICFmb3VuZFthcnJheTJbaV1dKSB7XHJcbiAgICAgICAgICAgIGNvbW1vbi5wdXNoKGFycmF5MltpXSk7XHJcbiAgICAgICAgICAgIGZvdW5kW2FycmF5MltpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29tbW9uO1xyXG59O1xyXG5cclxuXHJcbi8vIEZpbmQgd2hpY2gga2V5cyBhcmUgcHJlc2VudFxyXG5cclxuZXhwb3J0cy5tYXRjaEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XHJcblxyXG4gICAgdmFyIG1hdGNoZWQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGtleXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVkO1xyXG59O1xyXG5cclxuXHJcbi8vIEZsYXR0ZW4gYXJyYXlcclxuXHJcbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnJheSwgdGFyZ2V0KSB7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHRhcmdldCB8fCBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuZmxhdHRlbihhcnJheVtpXSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBSZW1vdmUga2V5c1xyXG5cclxuZXhwb3J0cy5yZW1vdmVLZXlzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5cykge1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5c1tpXV07XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gQ29udmVydCBhbiBvYmplY3Qga2V5IGNoYWluIHN0cmluZyAoJ2EuYi5jJykgdG8gcmVmZXJlbmNlIChvYmplY3RbYV1bYl1bY10pXHJcblxyXG5leHBvcnRzLnJlYWNoID0gZnVuY3Rpb24gKG9iaiwgY2hhaW4pIHtcclxuXHJcbiAgICB2YXIgcGF0aCA9IGNoYWluLnNwbGl0KCcuJyk7XHJcbiAgICB2YXIgcmVmID0gb2JqO1xyXG4gICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xyXG5cclxuICAgICAgICBpZiAocmVmKSB7XHJcbiAgICAgICAgICAgIHJlZiA9IHJlZltsZXZlbF07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlZjtcclxufTtcclxuXHJcblxyXG4vLyBJbmhlcml0cyBhIHNlbGVjdGVkIHNldCBvZiBtZXRob2RzIGZyb20gYW4gb2JqZWN0LCB3cmFwcGluZyBmdW5jdGlvbnMgaW4gYXN5bmNocm9ub3VzIHN5bnRheCBhbmQgY2F0Y2hpbmcgZXJyb3JzXHJcblxyXG5leHBvcnRzLmluaGVyaXRBc3luYyA9IGZ1bmN0aW9uIChzZWxmLCBvYmosIGtleXMpIHtcclxuXHJcbiAgICBrZXlzID0ga2V5cyB8fCBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5cyBpbnN0YW5jZW9mIEFycmF5ICYmXHJcbiAgICAgICAgICAgICAgICBrZXlzLmluZGV4T2YoaSkgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYucHJvdG90eXBlW2ldID0gKGZ1bmN0aW9uIChmbikge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChudWxsLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkob2JqW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5mb3JtYXRTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge1xyXG5cclxuICAgIHZhciB0cmFjZSA9IFtdO1xyXG4gICAgc3RhY2suZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cclxuICAgICAgICB0cmFjZS5wdXNoKFtpdGVtLmdldEZpbGVOYW1lKCksIGl0ZW0uZ2V0TGluZU51bWJlcigpLCBpdGVtLmdldENvbHVtbk51bWJlcigpLCBpdGVtLmdldEZ1bmN0aW9uTmFtZSgpLCBpdGVtLmlzQ29uc3RydWN0b3IoKV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRyYWNlO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZm9ybWF0VHJhY2UgPSBmdW5jdGlvbiAodHJhY2UpIHtcclxuXHJcbiAgICB2YXIgZGlzcGxheSA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XHJcblxyXG4gICAgICAgIGRpc3BsYXkucHVzaCgocm93WzRdID8gJ25ldyAnIDogJycpICsgcm93WzNdICsgJyAoJyArIHJvd1swXSArICc6JyArIHJvd1sxXSArICc6JyArIHJvd1syXSArICcpJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmNhbGxTdGFjayA9IGZ1bmN0aW9uIChzbGljZSkge1xyXG5cclxuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpXHJcblxyXG4gICAgdmFyIHY4ID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChlcnIsIHN0YWNrKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNhcHR1cmUgPSB7fTtcclxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGNhcHR1cmUsIGFyZ3VtZW50cy5jYWxsZWUpO1xyXG4gICAgdmFyIHN0YWNrID0gY2FwdHVyZS5zdGFjaztcclxuXHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHY4O1xyXG5cclxuICAgIHZhciB0cmFjZSA9IGV4cG9ydHMuZm9ybWF0U3RhY2soc3RhY2spO1xyXG5cclxuICAgIGlmIChzbGljZSkge1xyXG4gICAgICAgIHJldHVybiB0cmFjZS5zbGljZShzbGljZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYWNlO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZGlzcGxheVN0YWNrID0gZnVuY3Rpb24gKHNsaWNlKSB7XHJcblxyXG4gICAgdmFyIHRyYWNlID0gZXhwb3J0cy5jYWxsU3RhY2soc2xpY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBzbGljZSArIDEpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLmZvcm1hdFRyYWNlKHRyYWNlKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmFib3J0VGhyb3cgPSBmYWxzZTtcclxuXHJcblxyXG5leHBvcnRzLmFib3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGhpZGVTdGFjaykge1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnIHx8IGV4cG9ydHMuYWJvcnRUaHJvdyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YWNrID0gJyc7XHJcbiAgICBpZiAoIWhpZGVTdGFjaykge1xyXG4gICAgICAgIHN0YWNrID0gZXhwb3J0cy5kaXNwbGF5U3RhY2soMSkuam9pbignXFxuXFx0Jyk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZygnQUJPUlQ6ICcgKyBtZXNzYWdlICsgJ1xcblxcdCcgKyBzdGFjayk7XHJcbiAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uIC8qLCBtc2cxLCBtc2cyLCBtc2czICovKSB7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbXNncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICBtc2dzID0gbXNncy5tYXAoZnVuY3Rpb24gKG1zZykge1xyXG5cclxuICAgICAgICByZXR1cm4gdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiBtc2cgaW5zdGFuY2VvZiBFcnJvciA/IG1zZy5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkobXNnKTtcclxuICAgIH0pO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5sb2FkRGlyTW9kdWxlcyA9IGZ1bmN0aW9uIChwYXRoLCBleGNsdWRlRmlsZXMsIHRhcmdldCkgeyAgICAgIC8vIHRhcmdldChmaWxlbmFtZSwgbmFtZSwgY2FwTmFtZSlcclxuXHJcbiAgICB2YXIgZXhjbHVkZSA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZXhjbHVkZUZpbGVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBleGNsdWRlW2V4Y2x1ZGVGaWxlc1tpXSArICcuanMnXSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgRnMucmVhZGRpclN5bmMocGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZW5hbWUpIHtcclxuXHJcbiAgICAgICAgaWYgKC9cXC5qcyQvLnRlc3QoZmlsZW5hbWUpICYmXHJcbiAgICAgICAgICAgICFleGNsdWRlW2ZpbGVuYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKSk7XHJcbiAgICAgICAgICAgIHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2NhcE5hbWVdID0gcmVxdWlyZShwYXRoICsgJy8nICsgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQocGF0aCArICcvJyArIG5hbWUsIG5hbWUsIGNhcE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5yZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBmcm9tLCB0bykge1xyXG5cclxuICAgIG9ialt0b10gPSBvYmpbZnJvbV07XHJcbiAgICBkZWxldGUgb2JqW2Zyb21dO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5yZXNldCgpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMudHMgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIucHJvdG90eXBlLmVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnRzO1xyXG59O1xyXG5cclxuXHJcbi8vIExvYWQgYW5kIHBhcnNlIHBhY2thZ2UuanNvbiBwcm9jZXNzIHJvb3Qgb3IgZ2l2ZW4gZGlyZWN0b3J5XHJcblxyXG5leHBvcnRzLmxvYWRQYWNrYWdlID0gZnVuY3Rpb24gKGRpcikge1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBmaWxlcGF0aCA9IChkaXIgfHwgcHJvY2Vzcy5lbnYuUFdEKSArICcvcGFja2FnZS5qc29uJztcclxuICAgIGlmIChGcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoRnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIEVzY2FwZSBzdHJpbmcgZm9yIFJlZ2V4IGNvbnN0cnVjdGlvblxyXG5cclxuZXhwb3J0cy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICAvLyBFc2NhcGUgXiQuKistPz0hOnxcXC8oKVtde30sXHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXF5cXCRcXC5cXCpcXCtcXC1cXD9cXD1cXCFcXDpcXHxcXFxcXFwvXFwoXFwpXFxbXFxdXFx7XFx9XFwsXS9nLCAnXFxcXCQmJyk7XHJcbn07XHJcblxyXG5cclxuLy8gUmV0dXJuIGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50IG9mIGEgY2FsbGJhY2tcclxuXHJcbmV4cG9ydHMudG9zcyA9IGZ1bmN0aW9uIChjb25kaXRpb24gLyosIFttZXNzYWdlXSwgbmV4dCAqLykge1xyXG5cclxuICAgIHZhciBtZXNzYWdlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBhcmd1bWVudHNbMV0gOiAnJyk7XHJcbiAgICB2YXIgbmV4dCA9IChhcmd1bWVudHMubGVuZ3RoID09PSAzID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzFdKTtcclxuXHJcbiAgICB2YXIgZXJyID0gKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvciA/IG1lc3NhZ2UgOiAobWVzc2FnZSA/IG5ldyBFcnJvcihtZXNzYWdlKSA6IChjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciA/IGNvbmRpdGlvbiA6IG5ldyBFcnJvcigpKSkpO1xyXG5cclxuICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciB8fFxyXG4gICAgICAgICFjb25kaXRpb24pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBCYXNlNjR1cmwgKFJGQyA0NjQ4KSBlbmNvZGVcclxuXHJcbmV4cG9ydHMuYmFzZTY0dXJsRW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgcmV0dXJuIChuZXcgQnVmZmVyKHZhbHVlLCAnYmluYXJ5JykpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xyXG59O1xyXG5cclxuXHJcbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGRlY29kZVxyXG5cclxuZXhwb3J0cy5iYXNlNjR1cmxEZWNvZGUgPSBmdW5jdGlvbiAoZW5jb2RlZCkge1xyXG5cclxuICAgIGlmIChlbmNvZGVkICYmXHJcbiAgICAgICAgIWVuY29kZWQubWF0Y2goL15bXFx3XFwtXSokLykpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAobmV3IEJ1ZmZlcihlbmNvZGVkLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC86L2csICcvJyksICdiYXNlNjQnKSkudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJldHVybiBlcnI7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gRXNjYXBlIGF0dHJpYnV0ZSB2YWx1ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVyXHJcblxyXG5leHBvcnRzLmVzY2FwZUhlYWRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcclxuXHJcbiAgICAvLyBBbGxvd2VkIHZhbHVlIGNoYXJhY3RlcnM6ICEjJCUmJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fiBhbmQgc3BhY2UsIGEteiwgQS1aLCAwLTksIFxcLCBcIlxyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KGF0dHJpYnV0ZS5tYXRjaCgvXlsgXFx3XFwhI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC1cXC5cXC9cXDo7PFxcPT5cXD9AXFxbXFxdXFxeYFxce1xcfFxcfX5cXFwiXFxcXF0qJC8pLCAnQmFkIGF0dHJpYnV0ZSB2YWx1ZSAoJyArIGF0dHJpYnV0ZSArICcpJyk7XHJcblxyXG4gICAgcmV0dXJuIGF0dHJpYnV0ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNjYXBlIHF1b3RlcyBhbmQgc2xhc2hcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVIdG1sKHN0cmluZyk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVKYXZhU2NyaXB0ID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIHJldHVybiBFc2NhcGUuZXNjYXBlSmF2YVNjcmlwdChzdHJpbmcpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbnZhciBldmVudCA9IHtcclxuICAgIHRpbWVzdGFtcDogbm93LmdldFRpbWUoKSxcclxuICAgIHRhZ3M6IFsndGFnJ10sXHJcbiAgICBkYXRhOiB7IHNvbWU6ICdkYXRhJyB9XHJcbn07XHJcbiovXHJcblxyXG5leHBvcnRzLmNvbnNvbGVGdW5jID0gY29uc29sZS5sb2c7XHJcblxyXG5leHBvcnRzLnByaW50RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAodmFsdWUgPCAxMCA/ICcwJyA6ICcnKSArIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKTtcclxuICAgIHZhciB0aW1lc3RyaW5nID0gKG5vdy5nZXRZZWFyKCkgLSAxMDApLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0TW9udGgoKSArIDEpICtcclxuICAgICAgICBwYWQobm93LmdldERhdGUoKSkgK1xyXG4gICAgICAgICcvJyArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRIb3VycygpKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRNaW51dGVzKCkpICtcclxuICAgICAgICBwYWQobm93LmdldFNlY29uZHMoKSkgK1xyXG4gICAgICAgICcuJyArXHJcbiAgICAgICAgbm93LmdldE1pbGxpc2Vjb25kcygpO1xyXG5cclxuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcclxuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSAnSlNPTiBFcnJvcjogJyArIGUubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IHRpbWVzdHJpbmcgKyAnLCAnICsgZXZlbnQudGFnc1swXSArICcsICcgKyBkYXRhO1xyXG4gICAgZXhwb3J0cy5jb25zb2xlRnVuYyhvdXRwdXQpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufTtcclxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gTG9hZCBtb2R1bGVzXG5cbnZhciBEZ3JhbSA9IHJlcXVpcmUoJ2RncmFtJyk7XG52YXIgRG5zID0gcmVxdWlyZSgnZG5zJyk7XG52YXIgSG9layA9IHJlcXVpcmUoJ2hvZWsnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy50aW1lID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzZXR0aW5ncyA9IEhvZWsuY2xvbmUob3B0aW9ucyk7XG4gICAgc2V0dGluZ3MuaG9zdCA9IHNldHRpbmdzLmhvc3QgfHwgJ3Bvb2wubnRwLm9yZyc7XG4gICAgc2V0dGluZ3MucG9ydCA9IHNldHRpbmdzLnBvcnQgfHwgMTIzO1xuICAgIHNldHRpbmdzLnJlc29sdmVSZWZlcmVuY2UgPSBzZXR0aW5ncy5yZXNvbHZlUmVmZXJlbmNlIHx8IGZhbHNlO1xuXG4gICAgLy8gRGVjbGFyZSB2YXJpYWJsZXMgdXNlZCBieSBjYWxsYmFja1xuXG4gICAgdmFyIHRpbWVvdXRJZCA9IDA7XG4gICAgdmFyIHNlbnQgPSAwO1xuXG4gICAgLy8gRW5zdXJlIGNhbGxiYWNrIGlzIG9ubHkgY2FsbGVkIG9uY2VcblxuICAgIHZhciBpc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGltZW91dElkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIFVEUCBzb2NrZXRcblxuICAgIHZhciBzb2NrZXQgPSBEZ3JhbS5jcmVhdGVTb2NrZXQoJ3VkcDQnKTtcblxuICAgIHNvY2tldC5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblxuICAgICAgICByZXR1cm4gZmluaXNoKGVycik7XG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gaW5jb21pbmcgbWVzc2FnZXNcblxuICAgIHNvY2tldC5vbignbWVzc2FnZScsIGZ1bmN0aW9uIChidWZmZXIsIHJpbmZvKSB7XG5cbiAgICAgICAgdmFyIHJlY2VpdmVkID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBpbnRlcm5hbHMuTnRwTWVzc2FnZShidWZmZXIpO1xuICAgICAgICBpZiAoIW1lc3NhZ2UuaXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaChuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmVyIHJlc3BvbnNlJyksIG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3JpZ2luYXRlVGltZXN0YW1wICE9PSBzZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKG5ldyBFcnJvcignV3Jvbmcgb3JpZ2luYXRlIHRpbWVzdGFtcCcpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWVzdGFtcCBOYW1lICAgICAgICAgIElEICAgV2hlbiBHZW5lcmF0ZWRcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIE9yaWdpbmF0ZSBUaW1lc3RhbXAgICAgIFQxICAgdGltZSByZXF1ZXN0IHNlbnQgYnkgY2xpZW50XG4gICAgICAgIC8vIFJlY2VpdmUgVGltZXN0YW1wICAgICAgIFQyICAgdGltZSByZXF1ZXN0IHJlY2VpdmVkIGJ5IHNlcnZlclxuICAgICAgICAvLyBUcmFuc21pdCBUaW1lc3RhbXAgICAgICBUMyAgIHRpbWUgcmVwbHkgc2VudCBieSBzZXJ2ZXJcbiAgICAgICAgLy8gRGVzdGluYXRpb24gVGltZXN0YW1wICAgVDQgICB0aW1lIHJlcGx5IHJlY2VpdmVkIGJ5IGNsaWVudFxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcm91bmR0cmlwIGRlbGF5IGQgYW5kIHN5c3RlbSBjbG9jayBvZmZzZXQgdCBhcmUgZGVmaW5lZCBhczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZCA9IChUNCAtIFQxKSAtIChUMyAtIFQyKSAgICAgdCA9ICgoVDIgLSBUMSkgKyAoVDMgLSBUNCkpIC8gMlxuXG4gICAgICAgIHZhciBUMSA9IG1lc3NhZ2Uub3JpZ2luYXRlVGltZXN0YW1wO1xuICAgICAgICB2YXIgVDIgPSBtZXNzYWdlLnJlY2VpdmVUaW1lc3RhbXA7XG4gICAgICAgIHZhciBUMyA9IG1lc3NhZ2UudHJhbnNtaXRUaW1lc3RhbXA7XG4gICAgICAgIHZhciBUNCA9IHJlY2VpdmVkO1xuXG4gICAgICAgIG1lc3NhZ2UuZCA9IChUNCAtIFQxKSAtIChUMyAtIFQyKTtcbiAgICAgICAgbWVzc2FnZS50ID0gKChUMiAtIFQxKSArIChUMyAtIFQ0KSkgLyAyO1xuICAgICAgICBtZXNzYWdlLnJlY2VpdmVkTG9jYWxseSA9IHJlY2VpdmVkO1xuXG4gICAgICAgIGlmICghc2V0dGluZ3MucmVzb2x2ZVJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5zdHJhdHVtICE9PSAnc2Vjb25kYXJ5Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSByZWZlcmVuY2UgSVAgYWRkcmVzc1xuXG4gICAgICAgIERucy5yZXZlcnNlKG1lc3NhZ2UucmVmZXJlbmNlSWQsIGZ1bmN0aW9uIChlcnIsIGRvbWFpbnMpIHtcblxuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZmVyZW5jZUhvc3QgPSBkb21haW5zWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFNldCB0aW1lb3V0XG5cbiAgICBpZiAoc2V0dGluZ3MudGltZW91dCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGltZW91dElkID0gMDtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2gobmV3IEVycm9yKCdUaW1lb3V0JykpO1xuICAgICAgICB9LCBzZXR0aW5ncy50aW1lb3V0KTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgTlRQIG1lc3NhZ2VcblxuICAgIHZhciBtZXNzYWdlID0gbmV3IEJ1ZmZlcig0OCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ODsgaSsrKSB7ICAgICAgICAgICAgICAgICAgICAgIC8vIFplcm8gbWVzc2FnZVxuICAgICAgICBtZXNzYWdlW2ldID0gMDtcbiAgICB9XG5cbiAgICBtZXNzYWdlWzBdID0gKDAgPDwgNikgKyAoNCA8PCAzKSArICgzIDw8IDApICAgICAgICAgLy8gU2V0IHZlcnNpb24gbnVtYmVyIHRvIDQgYW5kIE1vZGUgdG8gMyAoY2xpZW50KVxuICAgIHNlbnQgPSBEYXRlLm5vdygpO1xuICAgIGludGVybmFscy5mcm9tTXNlY3Moc2VudCwgbWVzc2FnZSwgNDApOyAgICAgICAgICAgICAgIC8vIFNldCB0cmFuc21pdCB0aW1lc3RhbXAgKHJldHVybnMgYXMgb3JpZ2luYXRlKVxuXG4gICAgLy8gU2VuZCBOVFAgcmVxdWVzdFxuXG4gICAgc29ja2V0LnNlbmQobWVzc2FnZSwgMCwgbWVzc2FnZS5sZW5ndGgsIHNldHRpbmdzLnBvcnQsIHNldHRpbmdzLmhvc3QsIGZ1bmN0aW9uIChlcnIsIGJ5dGVzKSB7XG5cbiAgICAgICAgaWYgKGVyciB8fFxuICAgICAgICAgICAgYnl0ZXMgIT09IDQ4KSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goZXJyIHx8IG5ldyBFcnJvcignQ291bGQgbm90IHNlbmQgZW50aXJlIG1lc3NhZ2UnKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLk50cE1lc3NhZ2UgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cbiAgICB0aGlzLmlzVmFsaWQgPSBmYWxzZTtcblxuICAgIC8vIFZhbGlkYXRlXG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gNDgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIExlYXAgaW5kaWNhdG9yXG5cbiAgICB2YXIgbGkgPSAoYnVmZmVyWzBdID4+IDYpO1xuICAgIHN3aXRjaCAobGkpIHtcbiAgICAgICAgY2FzZSAwOiB0aGlzLmxlYXBJbmRpY2F0b3IgPSAnbm8td2FybmluZyc7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHRoaXMubGVhcEluZGljYXRvciA9ICdsYXN0LW1pbnV0ZS02MSc7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHRoaXMubGVhcEluZGljYXRvciA9ICdsYXN0LW1pbnV0ZS01OSc7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHRoaXMubGVhcEluZGljYXRvciA9ICdhbGFybSc7IGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFZlcnNpb25cblxuICAgIHZhciB2biA9ICgoYnVmZmVyWzBdICYgMHgzOCkgPj4gMyk7XG4gICAgdGhpcy52ZXJzaW9uID0gdm47XG5cbiAgICAvLyBNb2RlXG5cbiAgICB2YXIgbW9kZSA9IChidWZmZXJbMF0gJiAweDcpO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIDE6IHRoaXMubW9kZSA9ICdzeW1tZXRyaWMtYWN0aXZlJzsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogdGhpcy5tb2RlID0gJ3N5bW1ldHJpYy1wYXNzaXZlJzsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogdGhpcy5tb2RlID0gJ2NsaWVudCc7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IHRoaXMubW9kZSA9ICdzZXJ2ZXInOyBicmVhaztcbiAgICAgICAgY2FzZSA1OiB0aGlzLm1vZGUgPSAnYnJvYWRjYXN0JzsgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDc6IHRoaXMubW9kZSA9ICdyZXNlcnZlZCc7IGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFN0cmF0dW1cblxuICAgIHZhciBzdHJhdHVtID0gYnVmZmVyWzFdO1xuICAgIGlmIChzdHJhdHVtID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RyYXR1bSA9ICdkZWF0aCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0cmF0dW0gPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdHJhdHVtID0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdHVtIDw9IDE1KSB7XG4gICAgICAgIHRoaXMuc3RyYXR1bSA9ICdzZWNvbmRhcnknO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zdHJhdHVtID0gJ3Jlc2VydmVkJztcbiAgICB9XG5cbiAgICAvLyBQb2xsIGludGVydmFsIChtc2VjKVxuXG4gICAgdGhpcy5wb2xsSW50ZXJ2YWwgPSBNYXRoLnJvdW5kKE1hdGgucG93KDIsIGJ1ZmZlclsyXSkpICogMTAwMDtcblxuICAgIC8vIFByZWNpc2lvbiAobXNlY3MpXG5cbiAgICB0aGlzLnByZWNpc2lvbiA9IE1hdGgucG93KDIsIGJ1ZmZlclszXSkgKiAxMDAwO1xuXG4gICAgLy8gUm9vdCBkZWxheSAobXNlY3MpXG5cbiAgICB2YXIgcm9vdERlbGF5ID0gMjU2ICogKDI1NiAqICgyNTYgKiBidWZmZXJbNF0gKyBidWZmZXJbNV0pICsgYnVmZmVyWzZdKSArIGJ1ZmZlcls3XTtcbiAgICB0aGlzLnJvb3REZWxheSA9IDEwMDAgKiAocm9vdERlbGF5IC8gMHgxMDAwMCk7XG5cbiAgICAvLyBSb290IGRpc3BlcnNpb24gKG1zZWNzKVxuXG4gICAgdGhpcy5yb290RGlzcGVyc2lvbiA9ICgoYnVmZmVyWzhdIDw8IDgpICsgYnVmZmVyWzldICsgKChidWZmZXJbMTBdIDw8IDgpICsgYnVmZmVyWzExXSkgLyBNYXRoLnBvdygyLCAxNikpICogMTAwMDtcblxuICAgIC8vIFJlZmVyZW5jZSBpZGVudGlmaWVyXG5cbiAgICB0aGlzLnJlZmVyZW5jZUlkID0gJyc7XG4gICAgc3dpdGNoICh0aGlzLnN0cmF0dW0pIHtcbiAgICAgICAgY2FzZSAnZGVhdGgnOlxuICAgICAgICBjYXNlICdwcmltYXJ5JzpcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlSWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclsxMl0pICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMTNdKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyWzE0XSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclsxNV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZGFyeSc6XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZUlkID0gJycgKyBidWZmZXJbMTJdICsgJy4nICsgYnVmZmVyWzEzXSArICcuJyArIGJ1ZmZlclsxNF0gKyAnLicgKyBidWZmZXJbMTVdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUmVmZXJlbmNlIHRpbWVzdGFtcFxuXG4gICAgdGhpcy5yZWZlcmVuY2VUaW1lc3RhbXAgPSBpbnRlcm5hbHMudG9Nc2VjcyhidWZmZXIsIDE2KTtcblxuICAgIC8vIE9yaWdpbmF0ZSB0aW1lc3RhbXBcblxuICAgIHRoaXMub3JpZ2luYXRlVGltZXN0YW1wID0gaW50ZXJuYWxzLnRvTXNlY3MoYnVmZmVyLCAyNCk7XG5cbiAgICAvLyBSZWNlaXZlIHRpbWVzdGFtcFxuXG4gICAgdGhpcy5yZWNlaXZlVGltZXN0YW1wID0gaW50ZXJuYWxzLnRvTXNlY3MoYnVmZmVyLCAzMik7XG5cbiAgICAvLyBUcmFuc21pdCB0aW1lc3RhbXBcblxuICAgIHRoaXMudHJhbnNtaXRUaW1lc3RhbXAgPSBpbnRlcm5hbHMudG9Nc2VjcyhidWZmZXIsIDQwKTtcblxuICAgIC8vIFZhbGlkYXRlXG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSA0ICYmXG4gICAgICAgIHRoaXMuc3RyYXR1bSAhPT0gJ3Jlc2VydmVkJyAmJlxuICAgICAgICB0aGlzLm1vZGUgPT09ICdzZXJ2ZXInICYmXG4gICAgICAgIHRoaXMub3JpZ2luYXRlVGltZXN0YW1wICYmXG4gICAgICAgIHRoaXMucmVjZWl2ZVRpbWVzdGFtcCAmJlxuICAgICAgICB0aGlzLnRyYW5zbWl0VGltZXN0YW1wKSB7XG5cbiAgICAgICAgdGhpcy5pc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuaW50ZXJuYWxzLnRvTXNlY3MgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcblxuICAgIHZhciBzZWNvbmRzID0gMDtcbiAgICB2YXIgZnJhY3Rpb24gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgc2Vjb25kcyA9IChzZWNvbmRzICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSA0OyBpIDwgODsgKytpKSB7XG4gICAgICAgIGZyYWN0aW9uID0gKGZyYWN0aW9uICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKChzZWNvbmRzIC0gMjIwODk4ODgwMCArIChmcmFjdGlvbiAvIE1hdGgucG93KDIsIDMyKSkpICogMTAwMCk7XG59O1xuXG5cbmludGVybmFscy5mcm9tTXNlY3MgPSBmdW5jdGlvbiAodHMsIGJ1ZmZlciwgb2Zmc2V0KSB7XG5cbiAgICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IodHMgLyAxMDAwKSArIDIyMDg5ODg4MDA7XG4gICAgdmFyIGZyYWN0aW9uID0gTWF0aC5yb3VuZCgodHMgJSAxMDAwKSAvIDEwMDAgKiBNYXRoLnBvdygyLCAzMikpO1xuXG4gICAgYnVmZmVyW29mZnNldCArIDBdID0gKHNlY29uZHMgJiAweEZGMDAwMDAwKSA+PiAyNDtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMV0gPSAoc2Vjb25kcyAmIDB4MDBGRjAwMDApID4+IDE2O1xuICAgIGJ1ZmZlcltvZmZzZXQgKyAyXSA9IChzZWNvbmRzICYgMHgwMDAwRkYwMCkgPj4gODtcbiAgICBidWZmZXJbb2Zmc2V0ICsgM10gPSAoc2Vjb25kcyAmIDB4MDAwMDAwRkYpO1xuXG4gICAgYnVmZmVyW29mZnNldCArIDRdID0gKGZyYWN0aW9uICYgMHhGRjAwMDAwMCkgPj4gMjQ7XG4gICAgYnVmZmVyW29mZnNldCArIDVdID0gKGZyYWN0aW9uICYgMHgwMEZGMDAwMCkgPj4gMTY7XG4gICAgYnVmZmVyW29mZnNldCArIDZdID0gKGZyYWN0aW9uICYgMHgwMDAwRkYwMCkgPj4gODtcbiAgICBidWZmZXJbb2Zmc2V0ICsgN10gPSAoZnJhY3Rpb24gJiAweDAwMDAwMEZGKTtcbn07XG5cblxuLy8gT2Zmc2V0IHNpbmdsZXRvblxuXG5pbnRlcm5hbHMubGFzdCA9IHtcbiAgICBvZmZzZXQ6IDAsXG4gICAgZXhwaXJlczogMCxcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiAwXG59O1xuXG5cbmV4cG9ydHMub2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjbG9ja1N5bmNSZWZyZXNoID0gb3B0aW9ucy5jbG9ja1N5bmNSZWZyZXNoIHx8IDI0ICogNjAgKiA2MCAqIDEwMDA7ICAgICAgICAgICAgICAgICAgICAvLyBEYWlseVxuXG4gICAgaWYgKGludGVybmFscy5sYXN0Lm9mZnNldCAmJlxuICAgICAgICBpbnRlcm5hbHMubGFzdC5ob3N0ID09PSBvcHRpb25zLmhvc3QgJiZcbiAgICAgICAgaW50ZXJuYWxzLmxhc3QucG9ydCA9PT0gb3B0aW9ucy5wb3J0ICYmXG4gICAgICAgIG5vdyA8IGludGVybmFscy5sYXN0LmV4cGlyZXMpIHtcblxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGludGVybmFscy5sYXN0Lm9mZnNldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBleHBvcnRzLnRpbWUob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdGltZSkge1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJuYWxzLmxhc3QgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IE1hdGgucm91bmQodGltZS50KSxcbiAgICAgICAgICAgIGV4cGlyZXM6IG5vdyArIGNsb2NrU3luY1JlZnJlc2gsXG4gICAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3QsXG4gICAgICAgICAgICBwb3J0OiBvcHRpb25zLnBvcnRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgaW50ZXJuYWxzLmxhc3Qub2Zmc2V0KTtcbiAgICB9KTtcbn07XG5cblxuLy8gTm93IHNpbmdsZXRvblxuXG5pbnRlcm5hbHMubm93ID0ge1xuICAgIGludGVydmFsSWQ6IDBcbn07XG5cblxuZXhwb3J0cy5zdGFydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxzLm5vdy5pbnRlcnZhbElkKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBleHBvcnRzLm9mZnNldChvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBvZmZzZXQpIHtcblxuICAgICAgICBpbnRlcm5hbHMubm93LmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGV4cG9ydHMub2Zmc2V0KG9wdGlvbnMsIGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH0sIG9wdGlvbnMuY2xvY2tTeW5jUmVmcmVzaCB8fCAyNCAqIDYwICogNjAgKiAxMDAwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhaWx5XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydHMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghaW50ZXJuYWxzLm5vdy5pbnRlcnZhbElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhckludGVydmFsKGludGVybmFscy5ub3cuaW50ZXJ2YWxJZCk7XG4gICAgaW50ZXJuYWxzLm5vdy5pbnRlcnZhbElkID0gMDtcbn07XG5cblxuZXhwb3J0cy5pc0xpdmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gISFpbnRlcm5hbHMubm93LmludGVydmFsSWQ7XG59O1xuXG5cbmV4cG9ydHMubm93ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKCFleHBvcnRzLmlzTGl2ZSgpIHx8XG4gICAgICAgIG5vdyA+PSBpbnRlcm5hbHMubGFzdC5leHBpcmVzKSB7XG5cbiAgICAgICAgcmV0dXJuIG5vdztcbiAgICB9XG5cbiAgICByZXR1cm4gbm93ICsgaW50ZXJuYWxzLmxhc3Qub2Zmc2V0O1xufTtcblxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgSHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBOb2RlVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBIb2VrID0gcmVxdWlyZSgnaG9laycpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuQm9vbSA9IGZ1bmN0aW9uICgvKiAobmV3IEVycm9yKSBvciAoY29kZSwgbWVzc2FnZSkgKi8pIHtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuY29uc3RydWN0b3IgPT09IGludGVybmFscy5Cb29tLCAnRXJyb3IgbXVzdCBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgbmV3Jyk7XG5cbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaXNCb29tID0gdHJ1ZTtcblxuICAgIHRoaXMucmVzcG9uc2UgPSB7XG4gICAgICAgIGNvZGU6IDAsXG4gICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgICAvLyB0eXBlOiAnY29udGVudC10eXBlJ1xuICAgIH07XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcblxuICAgICAgICAvLyBFcnJvclxuXG4gICAgICAgIHZhciBlcnJvciA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLmRhdGEgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5yZXNwb25zZS5jb2RlID0gZXJyb3IuY29kZSB8fCA1MDA7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIC8vIGNvZGUsIG1lc3NhZ2VcblxuICAgICAgICB2YXIgY29kZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIWlzTmFOKHBhcnNlRmxvYXQoY29kZSkpICYmIGlzRmluaXRlKGNvZGUpICYmIGNvZGUgPj0gNDAwLCAnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciAoNDAwKyknKTtcblxuICAgICAgICB0aGlzLnJlc3BvbnNlLmNvZGUgPSBjb2RlO1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc3BvbnNlIGZvcm1hdFxuXG4gICAgdGhpcy5yZWZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlVXRpbC5pbmhlcml0cyhpbnRlcm5hbHMuQm9vbSwgRXJyb3IpO1xuXG5cbmludGVybmFscy5Cb29tLnByb3RvdHlwZS5yZWZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMucmVzcG9uc2UucGF5bG9hZC5jb2RlID0gdGhpcy5yZXNwb25zZS5jb2RlO1xuICAgIHRoaXMucmVzcG9uc2UucGF5bG9hZC5lcnJvciA9IEh0dHAuU1RBVFVTX0NPREVTW3RoaXMucmVzcG9uc2UuY29kZV0gfHwgJ1Vua25vd24nO1xuICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZS5wYXlsb2FkLm1lc3NhZ2UgPSBIb2VrLmVzY2FwZUh0bWwodGhpcy5tZXNzYWdlKTsgICAgICAgICAvLyBQcmV2ZW50IFhTUyBmcm9tIGVycm9yIG1lc3NhZ2VcbiAgICB9XG59O1xuXG5cbi8vIFV0aWxpdGllc1xuXG5pbnRlcm5hbHMuQm9vbS5iYWRSZXF1ZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20oNDAwLCBtZXNzYWdlKTtcbn07XG5cblxuaW50ZXJuYWxzLkJvb20udW5hdXRob3JpemVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNjaGVtZSwgYXR0cmlidXRlcykgeyAgICAgICAgICAvLyBPciBmdW5jdGlvbiAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICB2YXIgZXJyID0gbmV3IGludGVybmFscy5Cb29tKDQwMSwgbWVzc2FnZSk7XG5cbiAgICBpZiAoIXNjaGVtZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIHZhciB3d3dBdXRoZW50aWNhdGUgPSAnJztcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIChtZXNzYWdlLCBzY2hlbWUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgd3d3QXV0aGVudGljYXRlID0gc2NoZW1lO1xuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBuYW1lcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcsJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgLy8gVmFsdWUgY2FuIGJlIHplcm9cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gJyAnICsgbmFtZXNbaV0gKyAnPVwiJyArIEhvZWsuZXNjYXBlSGVhZGVyQXR0cmlidXRlKHZhbHVlLnRvU3RyaW5nKCkpICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gJyBlcnJvcj1cIicgKyBIb2VrLmVzY2FwZUhlYWRlckF0dHJpYnV0ZShtZXNzYWdlKSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIuaXNNaXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICAgICAgdmFyIHd3d0FycmF5ID0gc2NoZW1lO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB3d3dBcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSAnLCAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gd3d3QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlcnIucmVzcG9uc2UuaGVhZGVyc1snV1dXLUF1dGhlbnRpY2F0ZSddID0gd3d3QXV0aGVudGljYXRlO1xuXG4gICAgcmV0dXJuIGVycjtcbn07XG5cblxuaW50ZXJuYWxzLkJvb20uY2xpZW50VGltZW91dCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKDQwOCwgbWVzc2FnZSk7XG59O1xuXG5cbmludGVybmFscy5Cb29tLnNlcnZlclRpbWVvdXQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbSg1MDMsIG1lc3NhZ2UpO1xufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5mb3JiaWRkZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbSg0MDMsIG1lc3NhZ2UpO1xufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5ub3RGb3VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKDQwNCwgbWVzc2FnZSk7XG59O1xuXG5cbmludGVybmFscy5Cb29tLmludGVybmFsID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgIHZhciBlcnIgPSBuZXcgaW50ZXJuYWxzLkJvb20oNTAwLCBtZXNzYWdlKTtcblxuICAgIGlmIChkYXRhICYmIGRhdGEuc3RhY2spIHtcbiAgICAgICAgZXJyLnRyYWNlID0gZGF0YS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGVyci5vdXR0ZXJUcmFjZSA9IEhvZWsuZGlzcGxheVN0YWNrKDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyLnRyYWNlID0gSG9lay5kaXNwbGF5U3RhY2soMSk7XG4gICAgfVxuXG4gICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgIGVyci5yZXNwb25zZS5wYXlsb2FkLm1lc3NhZ2UgPSAnQW4gaW50ZXJuYWwgc2VydmVyIGVycm9yIG9jY3VycmVkJzsgICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIGFjdHVhbCBlcnJvciBmcm9tIHVzZXJcblxuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbmludGVybmFscy5Cb29tLnBhc3NUaHJvdWdoID0gZnVuY3Rpb24gKGNvZGUsIHBheWxvYWQsIGNvbnRlbnRUeXBlLCBoZWFkZXJzKSB7XG5cbiAgICB2YXIgZXJyID0gbmV3IGludGVybmFscy5Cb29tKDUwMCwgJ1Bhc3MtdGhyb3VnaCcpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNTAwIGNvZGUgaXMgb25seSB1c2VkIHRvIGluaXRpYWxpemVcblxuICAgIGVyci5kYXRhID0ge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgIH07XG5cbiAgICBlcnIucmVzcG9uc2UuY29kZSA9IGNvZGU7XG4gICAgZXJyLnJlc3BvbnNlLnR5cGUgPSBjb250ZW50VHlwZTtcbiAgICBlcnIucmVzcG9uc2UuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgZXJyLnJlc3BvbnNlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgcmV0dXJuIGVycjtcbn07XG5cblxuIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7Ly8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZXNjYXBlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGVzY2FwZWQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcblxuICAgICAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUphdmFTY3JpcHRDaGFyKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGVkO1xufTtcblxuXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbnB1dC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cbiAgICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUphdmFTY3JpcHRDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XG4gICAgICAgIHJldHVybiAnXFxcXHUnICsgaW50ZXJuYWxzLnBhZExlZnQoJycgKyBjaGFyQ29kZSwgNCk7XG4gICAgfVxuXG4gICAgdmFyIGhleFZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiAnXFxcXHgnICsgaW50ZXJuYWxzLnBhZExlZnQoaGV4VmFsdWUsIDIpO1xufTtcblxuXG5pbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIHZhciBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWxbY2hhckNvZGVdO1xuICAgIGlmICh0eXBlb2YgbmFtZWRFc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYW1lZEVzY2FwZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XG4gICAgfVxuXG4gICAgdmFyIGhleFZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiAnJiN4JyArIGludGVybmFscy5wYWRMZWZ0KGhleFZhbHVlLCAyKSArICc7Jztcbn07XG5cblxuaW50ZXJuYWxzLnBhZExlZnQgPSBmdW5jdGlvbiAoc3RyLCBsZW4pIHtcblxuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIHN0ciA9ICcwJyArIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuXG5pbnRlcm5hbHMuaXNTYWZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICByZXR1cm4gKHR5cGVvZiBpbnRlcm5hbHMuc2FmZUNoYXJDb2Rlc1tjaGFyQ29kZV0gIT09ICd1bmRlZmluZWQnKTtcbn07XG5cblxuaW50ZXJuYWxzLm5hbWVkSHRtbCA9IHtcbiAgICAnMzgnOiAnJmFtcDsnLFxuICAgICc2MCc6ICcmbHQ7JyxcbiAgICAnNjInOiAnJmd0OycsXG4gICAgJzM0JzogJyZxdW90OycsXG4gICAgJzE2MCc6ICcmbmJzcDsnLFxuICAgICcxNjInOiAnJmNlbnQ7JyxcbiAgICAnMTYzJzogJyZwb3VuZDsnLFxuICAgICcxNjQnOiAnJmN1cnJlbjsnLFxuICAgICcxNjknOiAnJmNvcHk7JyxcbiAgICAnMTc0JzogJyZyZWc7J1xufTtcblxuXG5pbnRlcm5hbHMuc2FmZUNoYXJDb2RlcyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgc2FmZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcblxuICAgICAgICBpZiAoKGkgPj0gOTcgJiYgaSA8PSAxMjIpIHx8ICAgICAgICAgLy8gYS16XG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgICAvLyBBLVpcbiAgICAgICAgICAgIChpID49IDQ4ICYmIGkgPD0gNTcpIHx8ICAgICAgICAgIC8vIDAtOVxuICAgICAgICAgICAgaSA9PT0gMzIgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIC5cbiAgICAgICAgICAgIGkgPT09IDQ0IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vICxcbiAgICAgICAgICAgIGkgPT09IDQ1IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIC1cbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIDpcbiAgICAgICAgICAgIGkgPT09IDk1KSB7ICAgICAgICAgICAgICAgICAgICAgIC8vIF9cblxuICAgICAgICAgICAgc2FmZVtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2FmZTtcbn0oKSk7XG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEJvb20gPSByZXF1aXJlKCdib29tJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbi8vIEdlbmVyYXRlIGEgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIHBzZXVkby1yYW5kb20gZGF0YVxuXG5leHBvcnRzLnJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIChzaXplKSB7XG5cbiAgICB2YXIgYnVmZmVyID0gZXhwb3J0cy5yYW5kb21CaXRzKChzaXplICsgMSkgKiA2KTtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgc2l6ZSk7XG59O1xuXG5cbmV4cG9ydHMucmFuZG9tQml0cyA9IGZ1bmN0aW9uIChiaXRzKSB7XG5cbiAgICBpZiAoIWJpdHMgfHxcbiAgICAgICAgYml0cyA8IDApIHtcblxuICAgICAgICByZXR1cm4gQm9vbS5pbnRlcm5hbCgnSW52YWxpZCByYW5kb20gYml0cyBjb3VudCcpO1xuICAgIH1cblxuICAgIHZhciBieXRlcyA9IE1hdGguY2VpbChiaXRzIC8gOCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIENyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIEJvb20uaW50ZXJuYWwoJ0ZhaWxlZCBnZW5lcmF0aW5nIHJhbmRvbSBiaXRzOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbn07XG5cblxuLy8gQ29tcGFyZSB0d28gc3RyaW5ncyB1c2luZyBmaXhlZCB0aW1lIGFsZ29yaXRobSAodG8gcHJldmVudCB0aW1lLWJhc2VkIGFuYWx5c2lzIG9mIE1BQyBkaWdlc3QgbWF0Y2gpXG5cbmV4cG9ydHMuZml4ZWRUaW1lQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBiICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWlzbWF0Y2ggPSAoYS5sZW5ndGggPT09IGIubGVuZ3RoID8gMCA6IDEpO1xuICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICBiID0gYTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIGFjID0gYS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYmMgPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIG1pc21hdGNoICs9IChhYyA9PT0gYmMgPyAwIDogMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChtaXNtYXRjaCA9PT0gMCk7XG59O1xuXG5cbiIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gTG9hZCBtb2R1bGVzXHJcblxyXG52YXIgRnMgPSByZXF1aXJlKCdmcycpO1xyXG52YXIgRXNjYXBlID0gcmVxdWlyZSgnLi9lc2NhcGUnKTtcclxuXHJcblxyXG4vLyBEZWNsYXJlIGludGVybmFsc1xyXG5cclxudmFyIGludGVybmFscyA9IHt9O1xyXG5cclxuXHJcbi8vIENsb25lIG9iamVjdCBvciBhcnJheVxyXG5cclxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIHNlZW4pIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICBvYmogPT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBzZWVuID0gc2VlbiB8fCB7IG9yaWc6IFtdLCBjb3B5OiBbXSB9O1xyXG5cclxuICAgIHZhciBsb29rdXAgPSBzZWVuLm9yaWcuaW5kZXhPZihvYmopO1xyXG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gc2Vlbi5jb3B5W2xvb2t1cF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5ld09iaiA9IChvYmogaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xyXG5cclxuICAgIHNlZW4ub3JpZy5wdXNoKG9iaik7XHJcbiAgICBzZWVuLmNvcHkucHVzaChuZXdPYmopO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAob2JqW2ldIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgQnVmZmVyKG9ialtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IERhdGUob2JqW2ldLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAnJyArIChvYmpbaV0uZ2xvYmFsID8gJ2cnIDogJycpICsgKG9ialtpXS5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKG9ialtpXS5tdWx0aWxpbmUgPyAnbScgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgUmVnRXhwKG9ialtpXS5zb3VyY2UsIGZsYWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IGV4cG9ydHMuY2xvbmUob2JqW2ldLCBzZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3T2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIE1lcmdlIGFsbCB0aGUgcHJvcGVydGllcyBvZiBzb3VyY2UgaW50byB0YXJnZXQsIHNvdXJjZSB3aW5zIGluIGNvbmZsaWMsIGFuZCBieSBkZWZhdWx0IG51bGwgYW5kIHVuZGVmaW5lZCBmcm9tIHNvdXJjZSBhcmUgYXBwbGllZFxyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgaXNOdWxsT3ZlcnJpZGUgLyogPSB0cnVlICovLCBpc01lcmdlQXJyYXlzIC8qID0gdHJ1ZSAqLykge1xyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnLCAnSW52YWxpZCB0YXJnZXQgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICBleHBvcnRzLmFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSwgJ0Nhbm5vdCBtZXJnZSBhcnJheSBvbnRvIGFuIG9iamVjdCcpO1xyXG4gICAgICAgIGlmIChpc01lcmdlQXJyYXlzID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNNZXJnZUFycmF5cyBkZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IG5vdCBjaGFuZ2UgdGFyZ2V0IGFzc2lnbm1lbnRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgIGZvciAodmFyIGsgPSAwLCBrbCA9IGtleXMubGVuZ3RoOyBrIDwga2w7ICsraykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBleHBvcnRzLmNsb25lKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBpc051bGxPdmVycmlkZSwgaXNNZXJnZUFycmF5cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc051bGxPdmVycmlkZSAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcblxyXG4vLyBBcHBseSBvcHRpb25zIHRvIGEgY29weSBvZiB0aGUgZGVmYXVsdHNcclxuXHJcbmV4cG9ydHMuYXBwbHlUb0RlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09ICdvYmplY3QnLCAnSW52YWxpZCBkZWZhdWx0cyB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgIGV4cG9ydHMuYXNzZXJ0KCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zIHZhbHVlOiBtdXN0IGJlIHRydWUsIGZhbHN5IG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghb3B0aW9ucykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBvcHRpb25zLCByZXR1cm4gbnVsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb3B5ID0gZXhwb3J0cy5jbG9uZShkZWZhdWx0cyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGlvbnMgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHBvcnRzLm1lcmdlKGNvcHksIG9wdGlvbnMsIGZhbHNlLCBmYWxzZSk7XHJcbn07XHJcblxyXG5cclxuLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpdGVtcyBmcm9tIGFycmF5XHJcblxyXG5leHBvcnRzLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSwga2V5KSB7XHJcblxyXG4gICAgdmFyIGluZGV4ID0ge307XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBpZCA9IChrZXkgPyBhcnJheVtpXVtrZXldIDogYXJyYXlbaV0pO1xyXG4gICAgICAgIGlmIChpbmRleFtpZF0gIT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgICAgICAgICAgaW5kZXhbaWRdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBDb252ZXJ0IGFycmF5IGludG8gb2JqZWN0XHJcblxyXG5leHBvcnRzLm1hcFRvT2JqZWN0ID0gZnVuY3Rpb24gKGFycmF5LCBrZXkpIHtcclxuXHJcbiAgICBpZiAoIWFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG9ialthcnJheVtpXVtrZXldXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ialthcnJheVtpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIEZpbmQgdGhlIGNvbW1vbiB1bmlxdWUgaXRlbXMgaW4gdHdvIGFycmF5c1xyXG5cclxuZXhwb3J0cy5pbnRlcnNlY3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIsIGp1c3RGaXJzdCkge1xyXG5cclxuICAgIGlmICghYXJyYXkxIHx8ICFhcnJheTIpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbW1vbiA9IFtdO1xyXG4gICAgdmFyIGhhc2ggPSAoYXJyYXkxIGluc3RhbmNlb2YgQXJyYXkgPyBleHBvcnRzLm1hcFRvT2JqZWN0KGFycmF5MSkgOiBhcnJheTEpO1xyXG4gICAgdmFyIGZvdW5kID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheTIubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChoYXNoW2FycmF5MltpXV0gJiYgIWZvdW5kW2FycmF5MltpXV0pIHtcclxuICAgICAgICAgICAgaWYgKGp1c3RGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5MltpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tbW9uLnB1c2goYXJyYXkyW2ldKTtcclxuICAgICAgICAgICAgZm91bmRbYXJyYXkyW2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoanVzdEZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XHJcbn07XHJcblxyXG5cclxuLy8gRmluZCB3aGljaCBrZXlzIGFyZSBwcmVzZW50XHJcblxyXG5leHBvcnRzLm1hdGNoS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcclxuXHJcbiAgICB2YXIgbWF0Y2hlZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSkge1xyXG4gICAgICAgICAgICBtYXRjaGVkLnB1c2goa2V5c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZWQ7XHJcbn07XHJcblxyXG5cclxuLy8gRmxhdHRlbiBhcnJheVxyXG5cclxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0IHx8IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXSkpIHtcclxuICAgICAgICAgICAgZXhwb3J0cy5mbGF0dGVuKGFycmF5W2ldLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIFJlbW92ZSBrZXlzXHJcblxyXG5leHBvcnRzLnJlbW92ZUtleXMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXlzKSB7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgZGVsZXRlIG9iamVjdFtrZXlzW2ldXTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBDb252ZXJ0IGFuIG9iamVjdCBrZXkgY2hhaW4gc3RyaW5nICgnYS5iLmMnKSB0byByZWZlcmVuY2UgKG9iamVjdFthXVtiXVtjXSlcclxuXHJcbmV4cG9ydHMucmVhY2ggPSBmdW5jdGlvbiAob2JqLCBjaGFpbikge1xyXG5cclxuICAgIHZhciBwYXRoID0gY2hhaW4uc3BsaXQoJy4nKTtcclxuICAgIHZhciByZWYgPSBvYmo7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYXRoLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAocmVmKSB7XHJcbiAgICAgICAgICAgIHJlZiA9IHJlZltwYXRoW2ldXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlZjtcclxufTtcclxuXHJcblxyXG4vLyBJbmhlcml0cyBhIHNlbGVjdGVkIHNldCBvZiBtZXRob2RzIGZyb20gYW4gb2JqZWN0LCB3cmFwcGluZyBmdW5jdGlvbnMgaW4gYXN5bmNocm9ub3VzIHN5bnRheCBhbmQgY2F0Y2hpbmcgZXJyb3JzXHJcblxyXG5leHBvcnRzLmluaGVyaXRBc3luYyA9IGZ1bmN0aW9uIChzZWxmLCBvYmosIGtleXMpIHtcclxuXHJcbiAgICBrZXlzID0ga2V5cyB8fCBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5cyBpbnN0YW5jZW9mIEFycmF5ICYmXHJcbiAgICAgICAgICAgICAgICBrZXlzLmluZGV4T2YoaSkgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYucHJvdG90eXBlW2ldID0gKGZ1bmN0aW9uIChmbikge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChudWxsLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkob2JqW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5mb3JtYXRTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge1xyXG5cclxuICAgIHZhciB0cmFjZSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc3RhY2subGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBpdGVtID0gc3RhY2tbaV07XHJcbiAgICAgICAgdHJhY2UucHVzaChbaXRlbS5nZXRGaWxlTmFtZSgpLCBpdGVtLmdldExpbmVOdW1iZXIoKSwgaXRlbS5nZXRDb2x1bW5OdW1iZXIoKSwgaXRlbS5nZXRGdW5jdGlvbk5hbWUoKSwgaXRlbS5pc0NvbnN0cnVjdG9yKCldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhY2U7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5mb3JtYXRUcmFjZSA9IGZ1bmN0aW9uICh0cmFjZSkge1xyXG5cclxuICAgIHZhciBkaXNwbGF5ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdHJhY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciByb3cgPSB0cmFjZVtpXTtcclxuICAgICAgICBkaXNwbGF5LnB1c2goKHJvd1s0XSA/ICduZXcgJyA6ICcnKSArIHJvd1szXSArICcgKCcgKyByb3dbMF0gKyAnOicgKyByb3dbMV0gKyAnOicgKyByb3dbMl0gKyAnKScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaXNwbGF5O1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuY2FsbFN0YWNrID0gZnVuY3Rpb24gKHNsaWNlKSB7XHJcblxyXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcclxuXHJcbiAgICB2YXIgdjggPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKGVyciwgc3RhY2spIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgYXJndW1lbnRzLmNhbGxlZSk7XHJcbiAgICB2YXIgc3RhY2sgPSBjYXB0dXJlLnN0YWNrO1xyXG5cclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdjg7XHJcblxyXG4gICAgdmFyIHRyYWNlID0gZXhwb3J0cy5mb3JtYXRTdGFjayhzdGFjayk7XHJcblxyXG4gICAgaWYgKHNsaWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNlLnNsaWNlKHNsaWNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhY2U7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5kaXNwbGF5U3RhY2sgPSBmdW5jdGlvbiAoc2xpY2UpIHtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBleHBvcnRzLmNhbGxTdGFjayhzbGljZSA9PT0gdW5kZWZpbmVkID8gMSA6IHNsaWNlICsgMSk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHMuZm9ybWF0VHJhY2UodHJhY2UpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuYWJvcnRUaHJvdyA9IGZhbHNlO1xyXG5cclxuXHJcbmV4cG9ydHMuYWJvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgaGlkZVN0YWNrKSB7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcgfHwgZXhwb3J0cy5hYm9ydFRocm93ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3RhY2sgPSAnJztcclxuICAgIGlmICghaGlkZVN0YWNrKSB7XHJcbiAgICAgICAgc3RhY2sgPSBleHBvcnRzLmRpc3BsYXlTdGFjaygxKS5qb2luKCdcXG5cXHQnKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCdBQk9SVDogJyArIG1lc3NhZ2UgKyAnXFxuXFx0JyArIHN0YWNrKTtcclxuICAgIHByb2Nlc3MuZXhpdCgxKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24gLyosIG1zZzEsIG1zZzIsIG1zZzMgKi8pIHtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtc2dzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIG1zZ3MgPSBtc2dzLm1hcChmdW5jdGlvbiAobXNnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IG1zZyA6IG1zZyBpbnN0YW5jZW9mIEVycm9yID8gbXNnLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtc2cpO1xyXG4gICAgfSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNncy5qb2luKCcgJykgfHwgJ1Vua25vd24gZXJyb3InKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmxvYWREaXJNb2R1bGVzID0gZnVuY3Rpb24gKHBhdGgsIGV4Y2x1ZGVGaWxlcywgdGFyZ2V0KSB7ICAgICAgLy8gdGFyZ2V0KGZpbGVuYW1lLCBuYW1lLCBjYXBOYW1lKVxyXG5cclxuICAgIHZhciBleGNsdWRlID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBleGNsdWRlRmlsZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGV4Y2x1ZGVbZXhjbHVkZUZpbGVzW2ldICsgJy5qcyddID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsZXMgPSBGcy5yZWFkZGlyU3luYyhwYXRoKTtcclxuICAgIGZvciAoaSA9IDAsIGlsID0gZmlsZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVzW2ldO1xyXG4gICAgICAgIGlmICgvXFwuanMkLy50ZXN0KGZpbGVuYW1lKSAmJlxyXG4gICAgICAgICAgICAhZXhjbHVkZVtmaWxlbmFtZV0pIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gZmlsZW5hbWUuc3Vic3RyKDAsIGZpbGVuYW1lLmxhc3RJbmRleE9mKCcuJykpO1xyXG4gICAgICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtjYXBOYW1lXSA9IHJlcXVpcmUocGF0aCArICcvJyArIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0KHBhdGggKyAnLycgKyBuYW1lLCBuYW1lLCBjYXBOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG5leHBvcnRzLnJlbmFtZSA9IGZ1bmN0aW9uIChvYmosIGZyb20sIHRvKSB7XHJcblxyXG4gICAgb2JqW3RvXSA9IG9ialtmcm9tXTtcclxuICAgIGRlbGV0ZSBvYmpbZnJvbV07XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy50cyA9IERhdGUubm93KCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lci5wcm90b3R5cGUuZWxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMudHM7XHJcbn07XHJcblxyXG5cclxuLy8gTG9hZCBhbmQgcGFyc2UgcGFja2FnZS5qc29uIHByb2Nlc3Mgcm9vdCBvciBnaXZlbiBkaXJlY3RvcnlcclxuXHJcbmV4cG9ydHMubG9hZFBhY2thZ2UgPSBmdW5jdGlvbiAoZGlyKSB7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIGZpbGVwYXRoID0gKGRpciB8fCBwcm9jZXNzLmVudi5QV0QpICsgJy9wYWNrYWdlLmpzb24nO1xyXG4gICAgaWYgKEZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShGcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gRXNjYXBlIHN0cmluZyBmb3IgUmVnZXggY29uc3RydWN0aW9uXHJcblxyXG5leHBvcnRzLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcXlxcJFxcLlxcKlxcK1xcLVxcP1xcPVxcIVxcOlxcfFxcXFxcXC9cXChcXClcXFtcXF1cXHtcXH1cXCxdL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcblxyXG4vLyBSZXR1cm4gYW4gZXJyb3IgYXMgZmlyc3QgYXJndW1lbnQgb2YgYSBjYWxsYmFja1xyXG5cclxuZXhwb3J0cy50b3NzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiAvKiwgW21lc3NhZ2VdLCBuZXh0ICovKSB7XHJcblxyXG4gICAgdmFyIG1lc3NhZ2UgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGFyZ3VtZW50c1sxXSA6ICcnKTtcclxuICAgIHZhciBuZXh0ID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMV0pO1xyXG5cclxuICAgIHZhciBlcnIgPSAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yID8gbWVzc2FnZSA6IChtZXNzYWdlID8gbmV3IEVycm9yKG1lc3NhZ2UpIDogKGNvbmRpdGlvbiBpbnN0YW5jZW9mIEVycm9yID8gY29uZGl0aW9uIDogbmV3IEVycm9yKCkpKSk7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIEVycm9yIHx8XHJcbiAgICAgICAgIWNvbmRpdGlvbikge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGVuY29kZVxyXG5cclxuZXhwb3J0cy5iYXNlNjR1cmxFbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICByZXR1cm4gKG5ldyBCdWZmZXIodmFsdWUsICdiaW5hcnknKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoL1xcPS9nLCAnJyk7XHJcbn07XHJcblxyXG5cclxuLy8gQmFzZTY0dXJsIChSRkMgNDY0OCkgZGVjb2RlXHJcblxyXG5leHBvcnRzLmJhc2U2NHVybERlY29kZSA9IGZ1bmN0aW9uIChlbmNvZGVkKSB7XHJcblxyXG4gICAgaWYgKGVuY29kZWQgJiZcclxuICAgICAgICAhZW5jb2RlZC5tYXRjaCgvXltcXHdcXC1dKiQvKSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKGVuY29kZWQucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoLzovZywgJy8nKSwgJ2Jhc2U2NCcpKS50b1N0cmluZygnYmluYXJ5Jyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBFc2NhcGUgYXR0cmlidXRlIHZhbHVlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJcclxuXHJcbmV4cG9ydHMuZXNjYXBlSGVhZGVyQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xyXG5cclxuICAgIC8vIEFsbG93ZWQgdmFsdWUgY2hhcmFjdGVyczogISMkJSYnKCkqKywtLi86Ozw9Pj9AW11eX2B7fH1+IGFuZCBzcGFjZSwgYS16LCBBLVosIDAtOSwgXFwsIFwiXHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQoYXR0cmlidXRlLm1hdGNoKC9eWyBcXHdcXCEjXFwkJSYnXFwoXFwpXFwqXFwrLFxcLVxcLlxcL1xcOjs8XFw9PlxcP0BcXFtcXF1cXF5gXFx7XFx8XFx9flxcXCJcXFxcXSokLyksICdCYWQgYXR0cmlidXRlIHZhbHVlICgnICsgYXR0cmlidXRlICsgJyknKTtcclxuXHJcbiAgICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgcXVvdGVzIGFuZCBzbGFzaFxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICByZXR1cm4gRXNjYXBlLmVzY2FwZUh0bWwoc3RyaW5nKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUphdmFTY3JpcHQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVKYXZhU2NyaXB0KHN0cmluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxudmFyIGV2ZW50ID0ge1xyXG4gICAgdGltZXN0YW1wOiBub3cuZ2V0VGltZSgpLFxyXG4gICAgdGFnczogWyd0YWcnXSxcclxuICAgIGRhdGE6IHsgc29tZTogJ2RhdGEnIH1cclxufTtcclxuKi9cclxuXHJcbmV4cG9ydHMuY29uc29sZUZ1bmMgPSBjb25zb2xlLmxvZztcclxuXHJcbmV4cG9ydHMucHJpbnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgIHZhciBwYWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA8IDEwID8gJzAnIDogJycpICsgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBub3cgPSBuZXcgRGF0ZShldmVudC50aW1lc3RhbXApO1xyXG4gICAgdmFyIHRpbWVzdHJpbmcgPSAobm93LmdldFllYXIoKSAtIDEwMCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRNb250aCgpICsgMSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0RGF0ZSgpKSArXHJcbiAgICAgICAgJy8nICtcclxuICAgICAgICBwYWQobm93LmdldEhvdXJzKCkpICtcclxuICAgICAgICBwYWQobm93LmdldE1pbnV0ZXMoKSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0U2Vjb25kcygpKSArXHJcbiAgICAgICAgJy4nICtcclxuICAgICAgICBub3cuZ2V0TWlsbGlzZWNvbmRzKCk7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xyXG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShldmVudC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZGF0YSA9ICdKU09OIEVycm9yOiAnICsgZS5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3V0cHV0ID0gdGltZXN0cmluZyArICcsICcgKyBldmVudC50YWdzWzBdICsgJywgJyArIGRhdGE7XHJcbiAgICBleHBvcnRzLmNvbnNvbGVGdW5jKG91dHB1dCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uKHByb2Nlc3MsQnVmZmVyKXsvLyBMb2FkIG1vZHVsZXNcclxuXHJcbnZhciBGcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcbnZhciBFc2NhcGUgPSByZXF1aXJlKCcuL2VzY2FwZScpO1xyXG5cclxuXHJcbi8vIERlY2xhcmUgaW50ZXJuYWxzXHJcblxyXG52YXIgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxuLy8gQ2xvbmUgb2JqZWN0IG9yIGFycmF5XHJcblxyXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaiwgc2Vlbikge1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xyXG5cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIHNlZW4gPSBzZWVuIHx8IHsgb3JpZzogW10sIGNvcHk6IFtdIH07XHJcblxyXG4gICAgdmFyIGxvb2t1cCA9IHNlZW4ub3JpZy5pbmRleE9mKG9iaik7XHJcbiAgICBpZiAobG9va3VwICE9PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBzZWVuLmNvcHlbbG9va3VwXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV3T2JqID0gKG9iaiBpbnN0YW5jZW9mIEFycmF5KSA/IFtdIDoge307XHJcblxyXG4gICAgc2Vlbi5vcmlnLnB1c2gob2JqKTtcclxuICAgIHNlZW4uY29weS5wdXNoKG5ld09iaik7XHJcblxyXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmpbaV0gaW5zdGFuY2VvZiBCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IG5ldyBCdWZmZXIob2JqW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvYmpbaV0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgRGF0ZShvYmpbaV0uZ2V0VGltZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvYmpbaV0gaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9ICcnICsgKG9ialtpXS5nbG9iYWwgPyAnZycgOiAnJykgKyAob2JqW2ldLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgKyAob2JqW2ldLm11bHRpbGluZSA/ICdtJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IG5ldyBSZWdFeHAob2JqW2ldLnNvdXJjZSwgZmxhZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gZXhwb3J0cy5jbG9uZShvYmpbaV0sIHNlZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXdPYmo7XHJcbn07XHJcblxyXG5cclxuLy8gTWVyZ2UgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBpbnRvIHRhcmdldCwgc291cmNlIHdpbnMgaW4gY29uZmxpYywgYW5kIGJ5IGRlZmF1bHQgbnVsbCBhbmQgdW5kZWZpbmVkIGZyb20gc291cmNlIGFyZSBhcHBsaWVkXHJcblxyXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBpc051bGxPdmVycmlkZSAvKiA9IHRydWUgKi8sIGlzTWVyZ2VBcnJheXMgLyogPSB0cnVlICovKSB7XHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgIGV4cG9ydHMuYXNzZXJ0KHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc291cmNlIHZhbHVlOiBtdXN0IGJlIG51bGwsIHVuZGVmaW5lZCwgb3IgYW4gb2JqZWN0Jyk7XHJcblxyXG4gICAgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGV4cG9ydHMuYXNzZXJ0KHRhcmdldCBpbnN0YW5jZW9mIEFycmF5LCAnQ2Fubm90IG1lcmdlIGFycmF5IG9udG8gYW4gb2JqZWN0Jyk7XHJcbiAgICAgICAgaWYgKGlzTWVyZ2VBcnJheXMgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpc01lcmdlQXJyYXlzIGRlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IGNoYW5nZSB0YXJnZXQgYXNzaWdubWVudFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc291cmNlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlW2ldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgZm9yICh2YXIgayA9IDAsIGtsID0ga2V5cy5sZW5ndGg7IGsgPCBrbDsgKytrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNba107XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGV4cG9ydHMuY2xvbmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIGlzTnVsbE92ZXJyaWRlLCBpc01lcmdlQXJyYXlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAvLyBFeHBsaWNpdCB0byBwcmVzZXJ2ZSBlbXB0eSBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbE92ZXJyaWRlICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59O1xyXG5cclxuXHJcbi8vIEFwcGx5IG9wdGlvbnMgdG8gYSBjb3B5IG9mIHRoZSBkZWZhdWx0c1xyXG5cclxuZXhwb3J0cy5hcHBseVRvRGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICBleHBvcnRzLmFzc2VydChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMgPT0gJ29iamVjdCcsICdJbnZhbGlkIGRlZmF1bHRzIHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgZXhwb3J0cy5hc3NlcnQoIW9wdGlvbnMgfHwgb3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMgdmFsdWU6IG11c3QgYmUgdHJ1ZSwgZmFsc3kgb3IgYW4gb2JqZWN0Jyk7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG9wdGlvbnMsIHJldHVybiBudWxsXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvcHkgPSBleHBvcnRzLmNsb25lKGRlZmF1bHRzKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb3B0aW9ucyBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHMubWVyZ2UoY29weSwgb3B0aW9ucywgZmFsc2UsIGZhbHNlKTtcclxufTtcclxuXHJcblxyXG4vLyBSZW1vdmUgZHVwbGljYXRlIGl0ZW1zIGZyb20gYXJyYXlcclxuXHJcbmV4cG9ydHMudW5pcXVlID0gZnVuY3Rpb24gKGFycmF5LCBrZXkpIHtcclxuXHJcbiAgICB2YXIgaW5kZXggPSB7fTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGlkID0gKGtleSA/IGFycmF5W2ldW2tleV0gOiBhcnJheVtpXSk7XHJcbiAgICAgICAgaWYgKGluZGV4W2lkXSAhPT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgICAgICAgICBpbmRleFtpZF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIENvbnZlcnQgYXJyYXkgaW50byBvYmplY3RcclxuXHJcbmV4cG9ydHMubWFwVG9PYmplY3QgPSBmdW5jdGlvbiAoYXJyYXksIGtleSkge1xyXG5cclxuICAgIGlmICghYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb2JqID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV1ba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2FycmF5W2ldW2tleV1dID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2JqW2FycmF5W2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbn07XHJcblxyXG5cclxuLy8gRmluZCB0aGUgY29tbW9uIHVuaXF1ZSBpdGVtcyBpbiB0d28gYXJyYXlzXHJcblxyXG5leHBvcnRzLmludGVyc2VjdCA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5MiwganVzdEZpcnN0KSB7XHJcblxyXG4gICAgaWYgKCFhcnJheTEgfHwgIWFycmF5Mikge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29tbW9uID0gW107XHJcbiAgICB2YXIgaGFzaCA9IChhcnJheTEgaW5zdGFuY2VvZiBBcnJheSA/IGV4cG9ydHMubWFwVG9PYmplY3QoYXJyYXkxKSA6IGFycmF5MSk7XHJcbiAgICB2YXIgZm91bmQgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Mi5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGhhc2hbYXJyYXkyW2ldXSAmJiAhZm91bmRbYXJyYXkyW2ldXSkge1xyXG4gICAgICAgICAgICBpZiAoanVzdEZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkyW2ldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21tb24ucHVzaChhcnJheTJbaV0pO1xyXG4gICAgICAgICAgICBmb3VuZFthcnJheTJbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChqdXN0Rmlyc3QgPyBudWxsIDogY29tbW9uKTtcclxufTtcclxuXHJcblxyXG4vLyBGaW5kIHdoaWNoIGtleXMgYXJlIHByZXNlbnRcclxuXHJcbmV4cG9ydHMubWF0Y2hLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xyXG5cclxuICAgIHZhciBtYXRjaGVkID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleXNbaV0pKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZWQucHVzaChrZXlzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlZDtcclxufTtcclxuXHJcblxyXG4vLyBGbGF0dGVuIGFycmF5XHJcblxyXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyYXksIHRhcmdldCkge1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB0YXJnZXQgfHwgW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICBleHBvcnRzLmZsYXR0ZW4oYXJyYXlbaV0sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gUmVtb3ZlIGtleXNcclxuXHJcbmV4cG9ydHMucmVtb3ZlS2V5cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleXMpIHtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgICBkZWxldGUgb2JqZWN0W2tleXNbaV1dO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIENvbnZlcnQgYW4gb2JqZWN0IGtleSBjaGFpbiBzdHJpbmcgKCdhLmIuYycpIHRvIHJlZmVyZW5jZSAob2JqZWN0W2FdW2JdW2NdKVxyXG5cclxuZXhwb3J0cy5yZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNoYWluKSB7XHJcblxyXG4gICAgdmFyIHBhdGggPSBjaGFpbi5zcGxpdCgnLicpO1xyXG4gICAgdmFyIHJlZiA9IG9iajtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhdGgubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChyZWYpIHtcclxuICAgICAgICAgICAgcmVmID0gcmVmW3BhdGhbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVmO1xyXG59O1xyXG5cclxuXHJcbi8vIEluaGVyaXRzIGEgc2VsZWN0ZWQgc2V0IG9mIG1ldGhvZHMgZnJvbSBhbiBvYmplY3QsIHdyYXBwaW5nIGZ1bmN0aW9ucyBpbiBhc3luY2hyb25vdXMgc3ludGF4IGFuZCBjYXRjaGluZyBlcnJvcnNcclxuXHJcbmV4cG9ydHMuaW5oZXJpdEFzeW5jID0gZnVuY3Rpb24gKHNlbGYsIG9iaiwga2V5cykge1xyXG5cclxuICAgIGtleXMgPSBrZXlzIHx8IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlzIGluc3RhbmNlb2YgQXJyYXkgJiZcclxuICAgICAgICAgICAgICAgIGtleXMuaW5kZXhPZihpKSA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2VsZi5wcm90b3R5cGVbaV0gPSAoZnVuY3Rpb24gKGZuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KG51bGwsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KShvYmpbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG5leHBvcnRzLmZvcm1hdFN0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XHJcblxyXG4gICAgdmFyIHRyYWNlID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzdGFjay5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFja1tpXTtcclxuICAgICAgICB0cmFjZS5wdXNoKFtpdGVtLmdldEZpbGVOYW1lKCksIGl0ZW0uZ2V0TGluZU51bWJlcigpLCBpdGVtLmdldENvbHVtbk51bWJlcigpLCBpdGVtLmdldEZ1bmN0aW9uTmFtZSgpLCBpdGVtLmlzQ29uc3RydWN0b3IoKV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmFjZTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmZvcm1hdFRyYWNlID0gZnVuY3Rpb24gKHRyYWNlKSB7XHJcblxyXG4gICAgdmFyIGRpc3BsYXkgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0cmFjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRyYWNlW2ldO1xyXG4gICAgICAgIGRpc3BsYXkucHVzaCgocm93WzRdID8gJ25ldyAnIDogJycpICsgcm93WzNdICsgJyAoJyArIHJvd1swXSArICc6JyArIHJvd1sxXSArICc6JyArIHJvd1syXSArICcpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpc3BsYXk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5jYWxsU3RhY2sgPSBmdW5jdGlvbiAoc2xpY2UpIHtcclxuXHJcbiAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avdjgvd2lraS9KYXZhU2NyaXB0U3RhY2tUcmFjZUFwaVxyXG5cclxuICAgIHZhciB2OCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoZXJyLCBzdGFjaykge1xyXG5cclxuICAgICAgICByZXR1cm4gc3RhY2s7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYXB0dXJlID0ge307XHJcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShjYXB0dXJlLCBhcmd1bWVudHMuY2FsbGVlKTtcclxuICAgIHZhciBzdGFjayA9IGNhcHR1cmUuc3RhY2s7XHJcblxyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2ODtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBleHBvcnRzLmZvcm1hdFN0YWNrKHN0YWNrKTtcclxuXHJcbiAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICByZXR1cm4gdHJhY2Uuc2xpY2Uoc2xpY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmFjZTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmRpc3BsYXlTdGFjayA9IGZ1bmN0aW9uIChzbGljZSkge1xyXG5cclxuICAgIHZhciB0cmFjZSA9IGV4cG9ydHMuY2FsbFN0YWNrKHNsaWNlID09PSB1bmRlZmluZWQgPyAxIDogc2xpY2UgKyAxKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cy5mb3JtYXRUcmFjZSh0cmFjZSk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5hYm9ydFRocm93ID0gZmFsc2U7XHJcblxyXG5cclxuZXhwb3J0cy5hYm9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBoaWRlU3RhY2spIHtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyB8fCBleHBvcnRzLmFib3J0VGhyb3cgPT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGFjayA9ICcnO1xyXG4gICAgaWYgKCFoaWRlU3RhY2spIHtcclxuICAgICAgICBzdGFjayA9IGV4cG9ydHMuZGlzcGxheVN0YWNrKDEpLmpvaW4oJ1xcblxcdCcpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ0FCT1JUOiAnICsgbWVzc2FnZSArICdcXG5cXHQnICsgc3RhY2spO1xyXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiAvKiwgbXNnMSwgbXNnMiwgbXNnMyAqLykge1xyXG5cclxuICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1zZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgbXNncyA9IG1zZ3MubWFwKGZ1bmN0aW9uIChtc2cpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogbXNnIGluc3RhbmNlb2YgRXJyb3IgPyBtc2cubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KG1zZyk7XHJcbiAgICB9KTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2dzLmpvaW4oJyAnKSB8fCAnVW5rbm93biBlcnJvcicpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMubG9hZERpck1vZHVsZXMgPSBmdW5jdGlvbiAocGF0aCwgZXhjbHVkZUZpbGVzLCB0YXJnZXQpIHsgICAgICAvLyB0YXJnZXQoZmlsZW5hbWUsIG5hbWUsIGNhcE5hbWUpXHJcblxyXG4gICAgdmFyIGV4Y2x1ZGUgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGV4Y2x1ZGVGaWxlcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgZXhjbHVkZVtleGNsdWRlRmlsZXNbaV0gKyAnLmpzJ10gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmaWxlcyA9IEZzLnJlYWRkaXJTeW5jKHBhdGgpO1xyXG4gICAgZm9yIChpID0gMCwgaWwgPSBmaWxlcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gZmlsZXNbaV07XHJcbiAgICAgICAgaWYgKC9cXC5qcyQvLnRlc3QoZmlsZW5hbWUpICYmXHJcbiAgICAgICAgICAgICFleGNsdWRlW2ZpbGVuYW1lXSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKSk7XHJcbiAgICAgICAgICAgIHZhciBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2NhcE5hbWVdID0gcmVxdWlyZShwYXRoICsgJy8nICsgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQocGF0aCArICcvJyArIG5hbWUsIG5hbWUsIGNhcE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMucmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgZnJvbSwgdG8pIHtcclxuXHJcbiAgICBvYmpbdG9dID0gb2JqW2Zyb21dO1xyXG4gICAgZGVsZXRlIG9ialtmcm9tXTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMucmVzZXQoKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnRzID0gRGF0ZS5ub3coKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyLnByb3RvdHlwZS5lbGFwc2VkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy50cztcclxufTtcclxuXHJcblxyXG4vLyBMb2FkIGFuZCBwYXJzZSBwYWNrYWdlLmpzb24gcHJvY2VzcyByb290IG9yIGdpdmVuIGRpcmVjdG9yeVxyXG5cclxuZXhwb3J0cy5sb2FkUGFja2FnZSA9IGZ1bmN0aW9uIChkaXIpIHtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICB2YXIgZmlsZXBhdGggPSAoZGlyIHx8IHByb2Nlc3MuZW52LlBXRCkgKyAnL3BhY2thZ2UuanNvbic7XHJcbiAgICBpZiAoRnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKEZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBFc2NhcGUgc3RyaW5nIGZvciBSZWdleCBjb25zdHJ1Y3Rpb25cclxuXHJcbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgLy8gRXNjYXBlIF4kLiorLT89ITp8XFwvKClbXXt9LFxyXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxeXFwkXFwuXFwqXFwrXFwtXFw/XFw9XFwhXFw6XFx8XFxcXFxcL1xcKFxcKVxcW1xcXVxce1xcfVxcLF0vZywgJ1xcXFwkJicpO1xyXG59O1xyXG5cclxuXHJcbi8vIFJldHVybiBhbiBlcnJvciBhcyBmaXJzdCBhcmd1bWVudCBvZiBhIGNhbGxiYWNrXHJcblxyXG5leHBvcnRzLnRvc3MgPSBmdW5jdGlvbiAoY29uZGl0aW9uIC8qLCBbbWVzc2FnZV0sIG5leHQgKi8pIHtcclxuXHJcbiAgICB2YXIgbWVzc2FnZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAzID8gYXJndW1lbnRzWzFdIDogJycpO1xyXG4gICAgdmFyIG5leHQgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1sxXSk7XHJcblxyXG4gICAgdmFyIGVyciA9IChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IgPyBtZXNzYWdlIDogKG1lc3NhZ2UgPyBuZXcgRXJyb3IobWVzc2FnZSkgOiAoY29uZGl0aW9uIGluc3RhbmNlb2YgRXJyb3IgPyBjb25kaXRpb24gOiBuZXcgRXJyb3IoKSkpKTtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgRXJyb3IgfHxcclxuICAgICAgICAhY29uZGl0aW9uKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gQmFzZTY0dXJsIChSRkMgNDY0OCkgZW5jb2RlXHJcblxyXG5leHBvcnRzLmJhc2U2NHVybEVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHJldHVybiAobmV3IEJ1ZmZlcih2YWx1ZSwgJ2JpbmFyeScpKS50b1N0cmluZygnYmFzZTY0JykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFw9L2csICcnKTtcclxufTtcclxuXHJcblxyXG4vLyBCYXNlNjR1cmwgKFJGQyA0NjQ4KSBkZWNvZGVcclxuXHJcbmV4cG9ydHMuYmFzZTY0dXJsRGVjb2RlID0gZnVuY3Rpb24gKGVuY29kZWQpIHtcclxuXHJcbiAgICBpZiAoZW5jb2RlZCAmJlxyXG4gICAgICAgICFlbmNvZGVkLm1hdGNoKC9eW1xcd1xcLV0qJC8pKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKG5ldyBCdWZmZXIoZW5jb2RlZC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvOi9nLCAnLycpLCAnYmFzZTY0JykpLnRvU3RyaW5nKCdiaW5hcnknKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEVzY2FwZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlclxyXG5cclxuZXhwb3J0cy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XHJcblxyXG4gICAgLy8gQWxsb3dlZCB2YWx1ZSBjaGFyYWN0ZXJzOiAhIyQlJicoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4gYW5kIHNwYWNlLCBhLXosIEEtWiwgMC05LCBcXCwgXCJcclxuXHJcbiAgICBleHBvcnRzLmFzc2VydChhdHRyaWJ1dGUubWF0Y2goL15bIFxcd1xcISNcXCQlJidcXChcXClcXCpcXCssXFwtXFwuXFwvXFw6OzxcXD0+XFw/QFxcW1xcXVxcXmBcXHtcXHxcXH1+XFxcIlxcXFxdKiQvKSwgJ0JhZCBhdHRyaWJ1dGUgdmFsdWUgKCcgKyBhdHRyaWJ1dGUgKyAnKScpO1xyXG5cclxuICAgIHJldHVybiBhdHRyaWJ1dGUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXFwiL2csICdcXFxcXCInKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZSBxdW90ZXMgYW5kIHNsYXNoXHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIHJldHVybiBFc2NhcGUuZXNjYXBlSHRtbChzdHJpbmcpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICByZXR1cm4gRXNjYXBlLmVzY2FwZUphdmFTY3JpcHQoc3RyaW5nKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG52YXIgZXZlbnQgPSB7XHJcbiAgICB0aW1lc3RhbXA6IG5vdy5nZXRUaW1lKCksXHJcbiAgICB0YWdzOiBbJ3RhZyddLFxyXG4gICAgZGF0YTogeyBzb21lOiAnZGF0YScgfVxyXG59O1xyXG4qL1xyXG5cclxuZXhwb3J0cy5jb25zb2xlRnVuYyA9IGNvbnNvbGUubG9nO1xyXG5cclxuZXhwb3J0cy5wcmludEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICByZXR1cm4gKHZhbHVlIDwgMTAgPyAnMCcgOiAnJykgKyB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKGV2ZW50LnRpbWVzdGFtcCk7XHJcbiAgICB2YXIgdGltZXN0cmluZyA9IChub3cuZ2V0WWVhcigpIC0gMTAwKS50b1N0cmluZygpICtcclxuICAgICAgICBwYWQobm93LmdldE1vbnRoKCkgKyAxKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXREYXRlKCkpICtcclxuICAgICAgICAnLycgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0SG91cnMoKSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0TWludXRlcygpKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRTZWNvbmRzKCkpICtcclxuICAgICAgICAnLicgK1xyXG4gICAgICAgIG5vdy5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkYXRhID0gJ0pTT04gRXJyb3I6ICcgKyBlLm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBvdXRwdXQgPSB0aW1lc3RyaW5nICsgJywgJyArIGV2ZW50LnRhZ3NbMF0gKyAnLCAnICsgZGF0YTtcclxuICAgIGV4cG9ydHMuY29uc29sZUZ1bmMob3V0cHV0KTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24oQnVmZmVyKXsvLyBEZWNsYXJlIGludGVybmFsc1xyXG5cclxudmFyIGludGVybmFscyA9IHt9O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG5cclxuICAgIGlmICghaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVzY2FwZWQgPSAnJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbnB1dC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcblxyXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICBlc2NhcGVkICs9IGlucHV0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnRlcm5hbHMuZXNjYXBlSmF2YVNjcmlwdENoYXIoY2hhckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXNjYXBlZDtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuXHJcbiAgICBpZiAoIWlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlc2NhcGVkID0gJyc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5wdXQubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG5cclxuICAgICAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyKGNoYXJDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVzY2FwZWQ7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLmVzY2FwZUphdmFTY3JpcHRDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XHJcblxyXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xyXG4gICAgICAgIHJldHVybiAnXFxcXHUnICsgaW50ZXJuYWxzLnBhZExlZnQoJycgKyBjaGFyQ29kZSwgNCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhleFZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgcmV0dXJuICdcXFxceCcgKyBpbnRlcm5hbHMucGFkTGVmdChoZXhWYWx1ZSwgMik7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XHJcblxyXG4gICAgdmFyIG5hbWVkRXNjYXBlID0gaW50ZXJuYWxzLm5hbWVkSHRtbFtjaGFyQ29kZV07XHJcbiAgICBpZiAodHlwZW9mIG5hbWVkRXNjYXBlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBuYW1lZEVzY2FwZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XHJcbiAgICAgICAgcmV0dXJuICcmIycgKyBjaGFyQ29kZSArICc7JztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGV4VmFsdWUgPSBuZXcgQnVmZmVyKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpLCAnYXNjaWknKS50b1N0cmluZygnaGV4Jyk7XHJcbiAgICByZXR1cm4gJyYjeCcgKyBpbnRlcm5hbHMucGFkTGVmdChoZXhWYWx1ZSwgMikgKyAnOyc7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLnBhZExlZnQgPSBmdW5jdGlvbiAoc3RyLCBsZW4pIHtcclxuXHJcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9ICcwJyArIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5pc1NhZmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcclxuXHJcbiAgICByZXR1cm4gKHR5cGVvZiBpbnRlcm5hbHMuc2FmZUNoYXJDb2Rlc1tjaGFyQ29kZV0gIT09ICd1bmRlZmluZWQnKTtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMubmFtZWRIdG1sID0ge1xyXG4gICAgJzM4JzogJyZhbXA7JyxcclxuICAgICc2MCc6ICcmbHQ7JyxcclxuICAgICc2Mic6ICcmZ3Q7JyxcclxuICAgICczNCc6ICcmcXVvdDsnLFxyXG4gICAgJzE2MCc6ICcmbmJzcDsnLFxyXG4gICAgJzE2Mic6ICcmY2VudDsnLFxyXG4gICAgJzE2Myc6ICcmcG91bmQ7JyxcclxuICAgICcxNjQnOiAnJmN1cnJlbjsnLFxyXG4gICAgJzE2OSc6ICcmY29weTsnLFxyXG4gICAgJzE3NCc6ICcmcmVnOydcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuc2FmZUNoYXJDb2RlcyA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIHNhZmUgPSB7fTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMzI7IGkgPCAxMjM7ICsraSkge1xyXG5cclxuICAgICAgICBpZiAoKGkgPj0gOTcgJiYgaSA8PSAxMjIpIHx8ICAgICAgICAgLy8gYS16XHJcbiAgICAgICAgICAgIChpID49IDY1ICYmIGkgPD0gOTApIHx8ICAgICAgICAgIC8vIEEtWlxyXG4gICAgICAgICAgICAoaSA+PSA0OCAmJiBpIDw9IDU3KSB8fCAgICAgICAgICAvLyAwLTlcclxuICAgICAgICAgICAgaSA9PT0gMzIgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VcclxuICAgICAgICAgICAgaSA9PT0gNDYgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gLlxyXG4gICAgICAgICAgICBpID09PSA0NCB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAsXHJcbiAgICAgICAgICAgIGkgPT09IDQ1IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIC1cclxuICAgICAgICAgICAgaSA9PT0gNTggfHwgICAgICAgICAgICAgICAgICAgICAgLy8gOlxyXG4gICAgICAgICAgICBpID09PSA5NSkgeyAgICAgICAgICAgICAgICAgICAgICAvLyBfXHJcblxyXG4gICAgICAgICAgICBzYWZlW2ldID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNhZmU7XHJcbn0oKSk7XG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7Ly8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUphdmFTY3JpcHQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuXHJcbiAgICBpZiAoIWlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlc2NhcGVkID0gJyc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5wdXQubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG5cclxuICAgICAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUphdmFTY3JpcHRDaGFyKGNoYXJDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVzY2FwZWQ7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcblxyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXNjYXBlZCA9ICcnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlc2NhcGVkO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5lc2NhcGVKYXZhU2NyaXB0Q2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG5cclxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFx1JyArIGludGVybmFscy5wYWRMZWZ0KCcnICsgY2hhckNvZGUsIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZXhWYWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksICdhc2NpaScpLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgIHJldHVybiAnXFxcXHgnICsgaW50ZXJuYWxzLnBhZExlZnQoaGV4VmFsdWUsIDIpO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5lc2NhcGVIdG1sQ2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG5cclxuICAgIHZhciBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWxbY2hhckNvZGVdO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lZEVzY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRFc2NhcGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xyXG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhleFZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgcmV0dXJuICcmI3gnICsgaW50ZXJuYWxzLnBhZExlZnQoaGV4VmFsdWUsIDIpICsgJzsnO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5wYWRMZWZ0ID0gZnVuY3Rpb24gKHN0ciwgbGVuKSB7XHJcblxyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuaXNTYWZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XHJcblxyXG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXNbY2hhckNvZGVdICE9PSAndW5kZWZpbmVkJyk7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLm5hbWVkSHRtbCA9IHtcclxuICAgICczOCc6ICcmYW1wOycsXHJcbiAgICAnNjAnOiAnJmx0OycsXHJcbiAgICAnNjInOiAnJmd0OycsXHJcbiAgICAnMzQnOiAnJnF1b3Q7JyxcclxuICAgICcxNjAnOiAnJm5ic3A7JyxcclxuICAgICcxNjInOiAnJmNlbnQ7JyxcclxuICAgICcxNjMnOiAnJnBvdW5kOycsXHJcbiAgICAnMTY0JzogJyZjdXJyZW47JyxcclxuICAgICcxNjknOiAnJmNvcHk7JyxcclxuICAgICcxNzQnOiAnJnJlZzsnXHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBzYWZlID0ge307XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcclxuXHJcbiAgICAgICAgaWYgKChpID49IDk3ICYmIGkgPD0gMTIyKSB8fCAgICAgICAgIC8vIGEtelxyXG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgICAvLyBBLVpcclxuICAgICAgICAgICAgKGkgPj0gNDggJiYgaSA8PSA1NykgfHwgICAgICAgICAgLy8gMC05XHJcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlXHJcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIC5cclxuICAgICAgICAgICAgaSA9PT0gNDQgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gLFxyXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAtXHJcbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIDpcclxuICAgICAgICAgICAgaSA9PT0gOTUpIHsgICAgICAgICAgICAgICAgICAgICAgLy8gX1xyXG5cclxuICAgICAgICAgICAgc2FmZVtpXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzYWZlO1xyXG59KCkpO1xufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSJdfQ==
;